
(*

    This file is part of Templot3, a computer program for the design of model railway track.
    Copyright (C) 2018  Martin Wynne.  email: martin@templot.com


    This program is free software: you may redistribute it and/or modify
    it under the terms of the GNU General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public Licence for more details.

    You should have received a copy of the GNU General Public Licence
    along with this program. See the files: licence.txt or templotmec.lpr

    Or if not, refer to the web site: https://www.gnu.org/licenses/

====================================================================================
*)

{ }
unit math_unit;

{$MODE Delphi}

//  the form is for various text inputs

interface

uses
  LCLType,
  LCLIntf,
  Messages,
  SysUtils,
  Classes,
  Graphics,
  Controls,
  Forms,
  Dialogs,
  StdCtrls,
  ExtCtrls,
  ComCtrls,
  MaskEdit,
  FileCtrl,
  Clipbrd,
  point_ex,    //  need Tpex declaration in this part for parameters to routines.
  pad_unit,    //  need Tcheck_end_diff declaration
  dummy_vehicle,
  path_interface,
  rail_data_unit,
  template, mark_unit;

type
  Tmath_form = class(TForm)
    edit_panel: TPanel;
    big_label: TLabel;
    blue_corner_panel: TPanel;
    size_updown: TUpDown;
    colour_panel: TPanel;
    colour_patch: TImage;
    math_editbox: TEdit;
    ok_button: TButton;
    datestamp_label: TLabel;
    font_button: TButton;
    cancel_button: TButton;
    reveal_timer: TTimer;
    overwrite_label: TLabel;
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormActivate(Sender: TObject);
    procedure colour_panelClick(Sender: TObject);
    procedure size_updownClick(Sender: TObject; Button: TUDBtnType);
    procedure FormCreate(Sender: TObject);
    procedure font_buttonClick(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure reveal_timerTimer(Sender: TObject);
    procedure overwrite_labelClick(Sender: TObject);
    procedure math_editboxKeyPress(Sender: TObject; var Key: Char);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

  Ttimbcentre_wait = record
    pex1: Tpex;
    pex2: Tpex;
    kq: double;
    shove_code: integer;
    valid: boolean;
  end;//record

  Tmake_trans_data = record
    // data record for the make transition from current function.
    old_rad1_orgx: double;
    old_rad1_orgy: double;
    rad_1st: double;

    old_rad2_orgx: double;
    old_rad2_orgy: double;
    rad_2nd: double;

    cen_apart: double;

    peg1x: double;
    peg1y: double;
    peg2x: double;
    peg2y: double;
  end;//record


  Tpeg_indicator_string = string

    [2];  // 208b


  Tcentre_line_path = class(IPath)
    function get_curve_length: double;
    function get_minimum_radius: double;
    function get_xy(dist: double): Tpex;
  end;


const

  pt_templates_help_str: string =
    '    `0Plain  Track  Templates`9' +
    '||Plain track templates are implemented within Templot0 as the approach track to an invisible dummy turnout.'
    +
    '||This has several important consequences which are not immediately obvious :' +
    '||1. The various settings for turnouts will continue to be accepted, but will be ignored unless and until you select the `0TEMPLATE > INSERT TURNOUT IN PLAIN TRACK`1 menu item.' + '||2. Plain track is handed LEFT and RIGHT just as for a turnout. This is important when entering the curving radius positive or negative,' + ' and when using the `0TOOLS > MAKE DOUBLE TRACK`1 functions. The current hand is always shown in the information panel, and can be swapped over without disturbing the alignment' + ' by selecting the `0TEMPLATE > INVERT HANDING`1 menu item.' + '||3. For mouse action adjustments to the overall length of a plain track template, either the `0F3`2 or the `0F4`2 mouse action can be used.' + '||4. The ends of a length of plain track are at the fixing peg positions `0PEG ON DATUM`1 (`0CTRL-0`2, zero) at the left-hand datum end on startup; and `0PEG ON JOINT`1 (`0CTRL-1`2) at the right-hand end on startup.' + '||5. The sleeper spacing and numbering, and the rail length joints, commence from the right-hand (`0CTRL-1`2) end on startup. For easier recognition this end is marked across on the screen (but not on the printed templates).' + '||To swap the plain track length end-for-end on the existing alignment, so that the numbering and joints commence from the opposite end, click the `0TEMPLATE > SWAP END-FOR-END`1 menu item (`0CTRL-N`2).' + '||To change the plain track rail lengths and sleeper spacings select the `0REAL > PLAIN TRACK OPTIONS > RAIL LENGTHS AND SLEEPER SPACINGS...`1 menu item.' + '||To change the sleeper sizes and randomizing settings select the `0REAL > TIMBERING >`1 menu items.' + '||When you change to plain track using the `0TEMPLATE > CONVERT TO PLAIN TRACK`1 menu item, your current turnout or half-diamond is replaced with a length of plain track on the same alignment.' + ' You can restore a turnout with the same settings by selecting the `0TEMPLATE > INSERT TURNOUT IN PLAIN TRACK`1 menu item.' + ' The current peg position is used to locate the switch front rail joint (`0CTRL-1`2) position of the inserted turnout.' + ' If the peg is not in a sensible position for this, the peg is reset to the datum (`0CTRL-0`2).' + '||( Note that if the turnout included any blanking, this will be cancelled and the full length of the turnout template will be converted to plain track.' + ' Blanking is not available for plain track, as the same effect is more easily obtained by simply changing the overall length.)' + '||You may need to click the `0TEMPLATE > SWAP FACING-TRAILING`1 menu item (`0CTRL-N`2) to get the inserted turnout correctly aligned and facing in the required direction.' + '||You can remove the inserted turnout by clicking the `0TEMPLATE > CONVERT TO PLAIN TRACK`1 menu item.';

  make_trans_help_str: string =
    '    `0Make  Transition  Curve  from`9|    `0Control Template to Background Template`9' +
    '||For diagrams and a tutorial sequence showing the use of this function, please refer to the Templot0 Companion pages on the Templot web site at  templot.com .' + '||This function creates a new control template on a transition curve alignment, which can be used to link two existing templates.' + '||The 1st radius and radial centres are taken from the existing control template. The 2nd radius and radial centres are taken from the selected background template.' + '||The existing control template is automatically stored on the background.' + '||N.B. In order to produce a usable result in all circumstances, this function uses a lower level of calculation precision than other Templot0 functions.' + ' Occasionally you may notice small discrepancies in the rail alignments when viewed zoomed-in to high magnification on the screen. This will be of no consequence in practical track planning.' + '||There are two possible transition curves in any given case, one of each hand. In many cases it is not obvious which hand is required.' + ' If the first one tried is not correct, the dialog which appears allows a template of the opposite hand to be easily created instead.' + '||For this function to work the following conditions must be fulfilled:' + '||1. One of the original templates can be straight, but not both.' + '||2. The track centre-lines must not intersect (cross), even if extended.' + '||(This means that no part of the imaginary full circle or straight line which would be created by extending the track centre-line of one original template may intersect (cross)' + ' any part of the imaginary full circle or straight line which would be created by extending the track centre-line of the other original template.)' + '||3. If the two imaginary circles are completely separate, the result will be an S-curve transition.' + '||4. If the smaller imaginary circle is completely contained within the larger imaginary circle, the result will be a C-curve transition.' + '||5. If the two circles are just touching (for example if the two templates have been aligned at a common boundary using the peg and notch functions), the result will be a zero-length transition at the boundary.' + '||6. The resulting transition must not be more gentle than the current `0MAX SPIRAL`1 setting permits. For a C-curve transition, this means that there must be a sufficient difference between the two radii.' + ' For more information click the `0PROGRAM > EXPERT > TRANSITION MATHS > MAX SPIRAL...`1 item on the `0PROGRAM PANEL`1 menus.' + '||The new control template will have a temporary 1 chain (66ft) (scale) length of 1st radius before the transition start position, and a similar length of 2nd radius beyond the transition end position.' + '||The final task is then to extend or shorten the new template at each end, and/or do likewise with the original templates, in order to position the template boundaries and create a full linking template between them.' + '||You can do this using the `0peg/align tools > extend/shorten the control template >`1 functions. (Or you can adjust the lengths of the templates manually using the `0F4`2 overall length mouse action.)' + '||Often when using this function the original templates are dummy templates created solely for the purpose. These are then deleted and the new transition template is extended at each end to replace them.' + ' If the `0delete the original templates`1 box is ticked, the templates will be deleted automatically when you click the `0yes - continue`1 green bar to accept the new transition curve template.' + '||If one of the original templates is itself containing a transition curve a dialog will appear asking how you want to proceed. The new transition curve can be matched to 1st or 2nd radius on the original template,' + ' or matched to the radius at the current position of its fixing peg. If this is within the transition zone, you will need to shorten the' + ' original template to this position in order to make a correct boundary with the new control template. Use the `0DO > SNAP TO PEG`1 menu item, possibly preceded by `0TEMPLATE > SWAP END-FOR-END`1.' + ' Repeat `0TEMPLATE > SWAP END-FOR-END`1 on the original template if necessary after creating the new transition (for example if the original template is a turnout).' + '||This function is not available if one of the original templates contains a slew. If a slew is needed it can be applied after creating the transition curve.' + '||For more information about using transition curves, click the button below.';

  output_mode_help_str: string = 'Output Mode<br><br>Sorry notes not yet available.';

  ladder_help_str: string = '    `0Make  Ladder  Crossover`9' +
    '||A `0ladder`3 track is one which crosses multiple running lines diagonally, comprised of a string of diamond-crossings and/or slips.' + '||In Templot0 a ladder is created by clicking the `0TOOLS > MAKE LADDER CROSSOVER >`1 menu items repeatedly, once for each diamond-crossing.' + ' This makes it possible to change the adjacent track spacing for each diamond-crossing as necessary -- click the `0GEOMETRY > ADJACENT TRACK CENTRES...`1 menu item.' + '||If slip roads are needed, they are added to the diamond-crossings afterwards.' + '||There are two types of ladder track: ' + '||1. In a `0regular`3 ladder, the diagonal-road has the same radius as the main-road (or both are straight), and all crossing angles are therefore equal.' + ' Regular ladder tracks are comprised of `0regular`3 diamond-crossings, and are commonly seen in station throats, often as single or double slips.' + '||2. In a `0curviform`3 ladder, the diagonal-road radius and main-road radius differ, and all the crossing angles therefore differ also.' + ' Most commonly the diagonal-road is more sharply curved than the main roads, creating short diamond-crossings.' + ' The diagonal road follows the initial curve of the turnout road from the running line (or can in some cases be straight across curved main roads).' + ' Curviform ladders are comprised of `0irregular`3 diamond-crossings, and are often used to form double-junctions, and to gain access to goods yards, engine sheds and industrial sidings.' + ' Slips are less common in curviform ladders because of the usually shorter crossing angles.' + '||The type of ladder is determined by the type of V-crossing which is set for the control template.' + ' To change it click the `0REAL > V-CROSSING Options >`1 menu options. Change the V-crossing type as required before making the ladder crossover.' + '||For a `0regular`3 ladder set a `0regular`3 or `0generic`3 type of V-crossing.' + '|For a `0curviform`3 ladder set a `0curviform`3 type of V-crossing.' + '||<I>Experienced users:</I> It is possible to create a curviform ladder from an initial template having a regular or generic type of V-crossing. This makes it possible to adjust the radius of the ladder track independently of the turnout.' + ' To do this use the `0tools > make double-track TS`z and `0tools > make branch track`1 functions. Adjust the branch track to the desired radius,' + 'and then use the `0peg/align tools > make diamond-crossing at intersection`1 function.';

var
  math_form: Tmath_form;

  //________________________________________

  list_factor_x, list_factor_y: double;

  trans_terms: integer = 8;
  trans_auto: boolean = True;

  omit_neg_brackets: boolean = False;
  zero_supp: integer = 1;

  adjust_trans_rad: integer = 2;

  spot_mod: integer = 0;
  zoom_mod: integer = 0;
  datum_mod: integer = 0;

  shove_along_mod: integer = 0;
  shove_throw_mod: integer = 0;
  shove_crab_mod: integer = 0;
  shove_length_mod: integer = 0;
  shove_width_mod: integer = 0;
  shove_twist_mod: integer = 0;

  trans_length_mod: integer = 0;
  trans_start_mod: integer = 0;

  slew_factor_mod: integer = 0;
  slew_amount_mod: integer = 0;
  slew_length_mod: integer = 0;
  slew_start_mod: integer = 0;

  length_mod: integer = 0;
  approach_mod: integer = 0;
  blanking_mod: integer = 0;
  turnout_road_mod: integer = 0;   // 209a
  main_road_mod: integer = 0;      // 217a

  roll_mod: integer = 0;
  roam_mod: integer = 0;

  dv_mod: integer = 0;
  dv_clear_mod: integer = 0;

  adjacent_ts_mod: integer = 0;     // 213a
  adjacent_ms_mod: integer = 0;

  shift_mod: integer = 0;
  slide_mod: integer = 0;
  snake_mod: integer = 0;

  zoffset_mod: integer = 0;

  bunch_mod: integer = 0;
  twist_mod: integer = 0;
  orbit_mod: integer = 0;
  both_mod: integer = 0;
  sx_mod: integer = 0;
  curving_mod: integer = 0;
  swell_mod: integer = 0;

  entry_straight_mod: integer = 0;  // 0.91.b

  plat_ts_start_mod: integer = 0;  // 0.93.a ...
  plat_ts_length_mod: integer = 0;
  plat_ts_width1_mod: integer = 0;
  plat_ts_width2_mod: integer = 0;
  plat_ts_skew1_mod: integer = 0;  // 207a..
  plat_ts_skew2_mod: integer = 0;

  plat_ms_start_mod: integer = 0;
  plat_ms_length_mod: integer = 0;
  plat_ms_width1_mod: integer = 0;
  plat_ms_width2_mod: integer = 0;
  plat_ms_skew1_mod: integer = 0;  // 207a..
  plat_ms_skew2_mod: integer = 0;

  edge_ts_start_mod: integer = 0;  // 215a ...
  edge_ts_length_mod: integer = 0;

  edge_ms_start_mod: integer = 0;
  edge_ms_length_mod: integer = 0;

  gaunt_offset_mod: integer = 0;  // SHIFT+F12  // 0.93.a ex 081
  gaunt_radius_mod: integer = 0;  // 217b

  vee_mod: integer = 0;           // F9         // 0.93.a ex 081
  hdk_mod: integer = 0;           // F10        // 0.93.a ex 081

  check_diffs_len_mod: integer = 0;    // check rails 0.94.a
  check_diffs_flare_mod: integer = 0;  // check rails 0.94.a
  check_diffs_gap_mod: integer = 0;    // check rails 0.94.a


  switch_modify_mode: boolean;

  mouse_labels: boolean;

  peg_rail: integer = 8;               // move peg along rail 8 = main-road centre-line (aq=24).

  pegx: double = 0;
  pegy: double = 0;

  notchx_now, notchy_now: double;
  xring_now, yring_now: double;
  ring_dia_now: double;

  ruler_startx_now, ruler_starty_now, ruler_endx_now, ruler_endy_now: double;   // 0.78.a

  shapes_shiftx_now: double = 0;
  shapes_shifty_now: double = 0;

  shifted_already_x: double = 0;
  shifted_already_y: double = 0;

  shapes_scaled_already: double = 1.0;

  shapes_rot_now: double = 0;
  shapes_rotated_already: double = 0;

  screenx_zoom_now: double;
  xorg_now, turnoutx_now, startx_now: double;
  tb_roll_percent_now, tb_roll_factor: double;
  y_datum_now: double;
  tst_now, os_now: double;

  fixed_sl_now, min_sl_offset, min_sl: double;  // 0.91.b

  slew_s_now, slew_l_now, slew_now, slew2_kmax_now: double;

  screenx_spot_now: double;

  out_factor_now: double;

  endx_now: double;
  nomrad_now: double;
  curvature_now: double;
  ends_apart_now: double;
  k3n_now: double;
  xshift_now, yshift_now, kform_now: double;
  arm_angle_now, pegangle_now: double;
  swing_0, swing_9, total_swing: double;

  // 0.93.a ...

  platform_ms_start_width_ins_now: double;
  platform_ms_end_width_ins_now: double;

  platform_ts_start_width_ins_now: double;
  platform_ts_end_width_ins_now: double;

  platform_ms_start_mm_now: double;
  platform_ms_length_mm_now: double;

  platform_ts_start_mm_now: double;
  platform_ts_length_mm_now: double;

  platform_ms_start_skew_mm_now: double = 0;  // 207a
  platform_ms_end_skew_mm_now: double = 0;    // 207a
  platform_ts_start_skew_mm_now: double = 0;  // 207a
  platform_ts_end_skew_mm_now: double = 0;    // 207a

  trackbed_ms_start_mm_now: double;      // 215a
  trackbed_ms_length_mm_now: double;     // 215a

  trackbed_ts_start_mm_now: double;      // 215a
  trackbed_ts_length_mm_now: double;     // 215a

  turnout_road_endx_now: double = 0;  // 209a

  main_road_endx_now: double = 0;  // 217a


  xlabels_now: double = 0;  // 0.82.d
  ylabels_now: double = 0;  // 0.82.d

  pegx_now: double = 0;
  pegy_now: double = 0;
  udpegx_now: double = 0;

  k3n: double = 6.0;     // V-crossing unit angle
  hdkn: double = 6.0;    // K-crossing unit angle  //^^^ 0.93.a

  sl: double = 12; // 1mm flangeway 1:6


  hide_current_flag: boolean = False;
  current_is_showing: boolean = False;

  trace_mouse: boolean = True;         // trace mouse actions with redraws.

  min_rad_warn: integer = 0;

  // 0.75.a 14-10-01...

  bn_wide: double = 0.75;      // full-size inches.  3/4" blunt nose BH default.
  bn_to_a: double = 4.0;       // full-size inches - 4" to A timber centre.
  wingj_sp: double = 25;       // full-size inches - 25" timber spacing at wing rail joint.
  mvj_sp: double = 12.5;       // full-size inches - 12.5" spacing to vee point rail joint.

  wingtimb_sp: double = 30;
  // full-size inches - 30" timber spacing for wing rail front part of crossing (up to "A").
  veetimb_sp: double = 30;
  // full-size inches - 30" timber spacing for vee point rail part of crossing (on from "A").

  // number of timbers spanned by vee rail including the "A" timber...

  vee_spco1: byte = 4;  // less than 1:4
  vee_spco2: byte = 5;  // up to 1:6.3/4
  vee_spco3: byte = 6;  // up to 1:10
  vee_spco4: byte = 7;  // up to 1:15
  vee_spco5: byte = 8;  // up to 1:20
  vee_spco6: byte = 9;  // over 1:20 improvised.

  // number of timbers spanned by wing rail front from joint but excluding the "A" timber...

  wing_spco1: byte = 2;    // less than 1:4
  wing_spco2: byte = 3;    // up to 1:6.3/4
  wing_spco3: byte = 3;    // up to 1:10
  wing_spco4: byte = 4;    // up to 1:15
  wing_spco5: byte = 5;    // up to 1:20
  wing_spco6: byte = 6;    // over 1:20


  // for half-diamond, 0.77.a 28-08-02...

  kck1_long: double = 185;   // inches full-size 15'5" k-crossing check rails, BH 1:6 and shorter.
  kck2_long: double = 197;   // 16'5" over 1:6

  // 0.95.a K wing rails ..

  k_custom_wing_long: double = 185;
  // inches full-size 15'5" k-crossing wing rails, BH 1:6.5 - 1:8
  k_custom_point_long: double = 144;  // inches full-size 12' k-crossing point rails   NYI
  use_k_custom_wing_rails: boolean = False;
  use_k_custom_point_rails: boolean = False;


  //kckmsmod:double=0;      // main side modifier.// out of use 0.94.a .
  //kckdsmod:double=0;      // diamond side modifier.// out of use 0.94.a

  k_flare_len: double = 36;
  // 0.94.a  was kck_fl_long:double=36;  // inches full-size flare length on k-crossing check rails.

  //kck_k5:double=0;        // out 0.94.a flare angle.

  // in mm...

  // out 0.94.a  kck_jbend:double=0;     // width across rail bend.
  // out 0.94.a  kckflgf_mm:double=0;    // gauge-face flare length in mm.
  // out 0.94.a  kckfloe_mm:double=0;    // ditto flare length along outer edge.

  kckdsx: double = 0;        // x to start of DS check rail, gf. aq=28.
  kckdsox: double = 0;       // ditto oe.                        aq=29.

  kckdsflx: double = 0;      // x to DS flare bend, gf.
  kckdsflox: double = 0;     // ditto oe.

  kckdsflendx: double = 0;   // x to end of DS check rail, gf.
  kckdsflendox: double = 0;  // ditto oe.

  //--

  kckmsx: double = 0;        // x to start of MS check rail, gf. aq=26.
  kckmsox: double = 0;       // ditto oe.                        aq=27.

  kckmsflx: double = 0;      // x to MS flare bend, gf.
  kckmsflox: double = 0;     // ditto oe.

  kckmsflendx: double = 0;   // x to end of MS check rail, gf.
  kckmsflendox: double = 0;  // ditto oe.

  g: double;

  nodraw, fw, k1n, h, h_inches, p, ph, k2n, toel, hdk, //^^^ 0.93.a irregular diamonds


  slwide, jt_slwide,   // 212a

  trtscent, trmscent,{adj_an,adj_af,adj_amn,adj_amf,}      // renamed adj_  0.82.d     out 0.93.a

  ckl_ms, ckl_ts, veelong, xing_flare_len, // mm  // 0.94.a  was xing_fl,
  fw_end          // mm  // 0.94.a  was fwe,
  : double;

  flare_type: integer = 0;
  // 0.94.a was flared_ends:integer=0;        // 0=straight bent  1=straight machined.

  knuckle_code: integer = 0;         // 214a   0=normal, -1=sharp, 1=use knuckle_radius
  knuckle_radius: double = 72.0;   // 214a   custom setting - default to 72 inches full size

  knuck_rad: double = 33.0;      // 214a   mm used in calcs. 6ft rad at 5.5mm/ft
  wing_bend_offset: double = 0;  // 214a   mm offset at end of knuckle curve  -- used for marks.


  k5_mw,          // 0.94.a  was k5, ...
  k5_me, k5_mr, k5_tw, k5_te, k5_tr, k5_mk, k5_dk, jbend_mw,
  // 0.94.a  was jbend, ...
  jbend_me, jbend_mr, jbend_tw, jbend_te, jbend_tr, jbend_mk, jbend_dk, flen_mw,
  // 0.94.a ...
  flen_me, flen_mr, flen_tw, flen_te, flen_tr, flen_mk, flen_dk, flen_mk_oe,
  flen_dk_oe, ftimbspmax, j, k1, kpl, k2, k3, swrad, equiv_rad, th,

  //trad,csrad,

  tradius, csradius,   // 0.93.a renamed

  k2sint, k3sint, k1sinsw, k2sinsw, k2cost, k3cost, k1cossw, ofb, ifb, joggle_deep,
  joggle_long, k2cossw, tl, scl, pl, lh, lh_inches, ipx,  // 208a

  fpx, dpx, tcpx, tcpy, txpx, txpy, txpk, trpx, trpy, mcpx, mxpx, mrpx, tvjpx,
  tvjpk, pegx_on_pad, pegy_on_pad: double;

  pegangle: double = 0;
  arm_angle: double = 0;

  now_peg_x, now_peg_y, now_peg_k, now_peg600: double;    // 0.79.a

  udpegx: double = 0;
  udpegy: double = 0;
  udpegangle: double = 0;

  toex, toeoxhd, toemidx, setx, setox, plx, plox, plx3, plox11, stox, heelx,
  heelox, tx, bnx, bnxx, atx, wingendx_ms, csrfpx, csrfpox, torgx, sworgx,
  bnox, vendx, vendox, csrendx, csrendox, k4, ckendx, ckflarex, ckx_ms, ckfwx,
  ckflarox, ckendox, ckox, ckfwox, wingx, wingox, wingcx, wingcox, wflarex,
  wflarox, wingendox, wingcfpx, wingcfpox, wl, wfp, k6, k7, flarecx, flarecox,
  flcendx, flcendox, cuckrad, cuckflrad_tw, cuckflrad_te, cuckfpx, cuckfpox,
  cucklb, k10, cuckla, wingx_plus, wingx_minus, wingox_plus, wingox_minus,
  // 214a for knuckle radius
  wingcx_plus, wingcx_minus, wingcox_plus, wingcox_minus, k11,  // 0.96.a

  k8, k9, cuckfwx, cuckfwox, cuckx, cuckox, cuckflx, cuckflox, cuckendx,
  cuckendox,{stxmax,}ys, xb, xe, xs, ks, rsw, gmi, gmo, tbl, tbq, tbred, yns, ynsred,

  // 208a tbnumy,

  tbnumy_screen, tbnumy_output,    // 208a

  xtba,{xingtb,}xtbz, frackeq, xtb, xtbzz, xclose, xtbswend, tbints, tb_xing_end,
  xclosespace, maintimb, xns, xfs, yfs, yfsred, keq,{xeq,}yeq, randend, randmod,
  ynsnorm, yfsnorm, eqendmod, randangle, randk, rety, retr, retx, retrorgx,
  retrorgy, retrmod, retcent,//fleg,
  torgy, sworgy, min_radius, fbtip, fbsetx, fbsetox, fbtoex, fbplx, fbplox,
  fbplx3, fbplox11, fbstox, fbheelx, fbheelox: double;
  // all above f.p. values 10-bytes for calcs.


  total_template_timber_length: double = 0; // 0.96.a

  smallest_radius: double = 1.0E8 - 5000;      // 208a for box data    init=max_rad ="straight"

  // was turnout_road  208g mod for easier searching..

  turnout_road_i: integer = 0;       // -1=crossover,  0=normal, 1=long, 2=adjustable,  3=minimum

  main_road_i: integer = 0;
  // -1=crossover,  0=normal,         2=adjustable,  3=minimum     // 217a


  centre_lines: boolean = True;                // track centre-lines on.
  gen_centre_lines_were_off: boolean = False;  // flag used in copy_keep.

  reduced_ends: boolean = True;        // sleeper reduced end marks wanted.

  chair_marks: boolean = True;         // 213b

  guide_marks, joint_marks, timber_marks, rad_ends: boolean;

  random_flag: boolean = False;        // no timber randomising.

  shove_index: integer = 0;

  other_k3n_i: integer;

  clrad1, clrad2, ssrad1, ssrad2: double;
  xt1, yt1, xt0, xt2, yt2: double;

  os, ts1, tst{,ycurv}: double;
  r1, r2, tos, t0, t1, t2: double;
  orbit_rad: double;
  xtrans1, ytrans1, xtrans2, ytrans2: double;
  trans_k: double;

  rad1_orgx: double = 0;     // radial centres on pad.
  rad1_orgy: double = 0;
  rad2_orgx: double = 0;
  rad2_orgy: double = 0;

  slew_s: double = 0;           // slewing dims 7-7-99...
  slew_l: double = 600;         // 600 mm default startup slew length
  slew_t: double = 0;
  // slewing angle at centre of slewing zone (used to mark slewed over rad centres).
  slew: double = 0;             // total amount of slew

  slew2_kmax: double = 2.0;    // kmax radians for slew mode 2 (tanh).
  slew2_rot: double = 0;       // rotation needed to straighten tanh curve (in trig units).
  slew2_ymax: double = 0;
  slew2_ymin: double = 0;

  slew_angle: double = 0;       // twist introduced by the slew.

  length_in_degs: double = 0;
  length_in_mm: double = 0;

  saved_pegging_shiftx: double = 0;
  saved_pegging_shifty: double = 0;
  saved_pegging_rot: double = 0;

  old_notchx: double = 0;      // 21-1-01.
  old_notchy: double = 0;
  old_notch_angle: double = 0;

  approach_last_xtb: double = 0;
  exit_last_xtb: double = 0;

  pre_examine_peg_x: double = 0;
  pre_examine_peg_y: double = 0;
  pre_examine_peg_screen: double = 0;
  examined_peg_x: double = 0;
  examined_peg_y: double = 0;
  examined_peg_screen: double = 0;

  snap_proximity_limit: double = 36;   // F7 snap limit 36" prototype  0.79.a  29-05-06

  gen_platforms: boolean = True;     // 0.93.a  generator switch for trackbed and platforms

  //adjacent_lines_code:integer=0;    // 0.82.d   0=no, 1=adjacent tracks,  2=trackbed edges.

  adjacent_edges: boolean = True;
  // 0.93.a   False=adjacent tracks,  True=trackbed edges and platform edges.

  // trackbed ...

  //trackbed_width_ins_old:double=180;       // 0.82.d   180 inches full-size 15ft. out of use, 215a

  draw_ms_trackbed_edge: boolean = False;
  draw_ts_trackbed_edge: boolean = False;

  //cess_width_ins_old:double=24;            // 206a ...    was 30    out of use, 215a
  //draw_trackbed_cess_edge_old:boolean=False;    // out of use 215a

  // 215a ...

  trackbed_ms_start_mm: double = 0;            // 215a
  trackbed_ms_length_mm: double = 0 - 1.0E300;
  // 215a   (def_req)    // set to template end in strails()

  trackbed_ts_start_mm: double = 0;            // 215a
  trackbed_ts_length_mm: double = 0 - 1.0E300;
  // 215a   (def_req)    // set to template end in strails()

  trackbed_ms_width_ins: Single = 90;
  // Single   215a  7ft-6in full-size  half-trackbed width  MS
  trackbed_ts_width_ins: Single = 90;
  // Single   215a  7ft-6in full-size  half-trackbed width  TS

  cess_ms_width_ins: Single = 27;         // Single   215a  2ft-3in full-size cess width MS
  cess_ts_width_ins: Single = 27;         // Single   215a  2ft-3in full-size cess width TS

  draw_ms_trackbed_cess_edge: boolean = False;       // 215a
  draw_ts_trackbed_cess_edge: boolean = False;       // 215a

  // platforms ...

  platform_ms_front_edge_ins: double = 57;
  //  215a  from centre       was 2ft-4.3/4in from rail
  platform_ts_front_edge_ins: double = 57;
  //  215a  from centre       was 2ft-4.3/4in from rail

  platform_ms_start_width_ins: double = 144;             // 12ft defaults
  platform_ms_end_width_ins: double = 144;               // 12ft

  platform_ts_start_width_ins: double = 144;             // 12ft
  platform_ts_end_width_ins: double = 144;               // 12ft


  platform_ms_start_skew_mm: double = 0;      // 207a
  platform_ms_end_skew_mm: double = 0;        // 207a

  platform_ts_start_skew_mm: double = 0;      // 207a
  platform_ts_end_skew_mm: double = 0;        // 207a


  platform_ms_start_mm: double = 0;
  platform_ms_length_mm: double = 0 - 1.0E300;   // (def_req)    // set to template end

  platform_ts_start_mm: double = 0;
  platform_ts_length_mm: double = 0 - 1.0E300;   // (def_req)    // set to template end


  draw_ms_platform: boolean = False;

  draw_ms_platform_rear_edge: boolean = True;
  draw_ms_platform_start_edge: boolean = True;
  draw_ms_platform_end_edge: boolean = True;

  draw_ts_platform: boolean = False;

  draw_ts_platform_rear_edge: boolean = True;
  draw_ts_platform_start_edge: boolean = True;
  draw_ts_platform_end_edge: boolean = True;

  turnout_i: integer = 0;           // free length

  switch_free: boolean = True;
  xing_free: boolean = True;
  generate_nearest: boolean = False;   // 0.76.a 29-4-02.

  timbers_equalized: boolean = False;  // 0.93.a    was True  // False=square-on,   True=equalized.
  equalizing_fixed: boolean = False;   // False=incremental, True=constant.
  square_on_angled: boolean = False;
  // False=square-on to main road, True=square-on to turnout road.
  no_timbering: boolean = False;       // True = omit all timbering.

  exp_chairing: boolean = False;           // 214a  True = draw experimental chairing

  make_trans_data: Tmake_trans_data;  // data for make transition from current function.

  exittb_i: integer;

  udpeg_rail: integer = 8;             // rail for user-defined peg position.

  notch_linked_code: integer = 0;      // for notch linking.
  undo_index: integer = 0;             // rollbacks...
  notch_index: integer = 0;

  repeat_last_index: integer = 25;  // curving F6 default repeat mouse action.

  label_mousedown_X: integer = 0;
  label_mousedown_Y: integer = 0;

  beginner_mousedown_X: integer = 0;  // 0.93.a
  beginner_mousedown_Y: integer = 0;  // 0.93.a

  link_mousedown_X: integer = 0;  // 0.93.a
  link_mousedown_Y: integer = 0;  // 0.93.a

  zoff_now_x, zoff_now_y: integer;         // 0.91.c moved for MouseDown.
  allow_left_button_pan: boolean = False;    // 0.91.c


  outer_edges, gauge_faces, midline: boolean;

  include_front_timbers: boolean = True;    // 218a ..
  include_switch_timbers: boolean = True;
  include_closure_timbers: boolean = True;
  include_xing_timbers: boolean = True;

  approach_rails_only: boolean = False;  // 218a


  f5_quarter_steps: boolean = True;       // mouse adjusts crossing angles in 1/4 steps.
  f9_quarter_steps: boolean = False;   // F9 mouse action any V-crossing angle.
  f10_quarter_steps: boolean = False;  // F10 mouse action any K-crossing angle.

  f9_gaunt_rad: boolean = True;
  //  217a  F9 keeps gaunt radius fixed (modify offset)               (for tandem inserted crossings).
  f9_hd_rad: boolean = False;
  //  218b  F9 keeps half_diamond radius fixed (modify K-xing angle)  (for tandem inserted crossings).

  f6_swing_fixed: boolean = False;     // 0.91.b   F6 curving option.

  printer_setup_done: boolean = False;

  mouse_action_button_down: boolean = False;     // flag to indicate he is holding the button down.

  keep_added: boolean = False;       // flag for the MAKE tools.

  udpeg_valid: boolean = False;          // no user-defined peg position data yet set.

  select_centre: boolean = False;

  mouse_draw_lines: boolean = False;

  zoom_rectangle: boolean = False;
  group_fence_rectangle: boolean = False;
  output_boundary_rectangle: boolean = False;  // 0.93.a
  drawn_shape_rectangle: boolean = False;      // 214a

  //ms_ends:boolean=False;             // centralized timbering.
  ms_ends: boolean = True;             // 0.93.a default ends-in-line.

  program_help_str: string = 'program help';

  park_name_str: array[0..2] of string;        // template names in parking bay.
  park_memo_str: array[0..2] of string;        // template memo notes in parking bay.

  current_diff_code: EMarkCode = eMC_0_Ignore;  // 0.94.a check rails ...
  null_diff: Tcheck_end_diff;    // used for errors
  mouse_diff: Tcheck_end_diff;   // current diff for mouse action

  retain_diffs_on_make: boolean = False;
  retain_diffs_on_mint: boolean = False;

  retain_shoves_on_make: boolean = False;
  retain_shoves_on_mint: boolean = False;

  retain_entry_straight_on_mint: boolean = False;  // 212b
  retain_entry_straight_on_make: boolean = False;  // 212b

  hidden_on_store: integer = 0;
  // 205c  >0 = control template was hidden on storing to background - delay wanted

  reveal_limit_count: integer = 0; // 206a  0=time limit - abandon slide and jump it back
  slide_on_store: integer = 0;
  // 206a  >0 = control template was shifted on storing to background - slide wanted
  stored_xshift: double = 0;     // 206a
  stored_yshift: double = 0;     // 206a
  slide_inc: double = 0;         // 206a


  wheel_zoom_code: integer = 0;
  // 0.97.d  0=zoom on centre  1=zoom on mouse location  2=jump mouse location (and mouse cursor) to centre, then zoom on centre

  // init current dummy vehicle dims, prototype inches  0.98.a ...

  cdvi: Tdummy_vehicle_info;
  centre_line_path: Tcentre_line_path;


  // position of dummy vehicle corners (control template) ...

  dv_corners_calc: Tdummy_vehicle_corners = (pt1: (x: 0; y: 0);
  pt2: (x: 0; y: 0);
  b1: (x: 0; y: 0);
  b2: (x: 0; y: 0);
  b3: (x: 0; y: 0);
  b4: (x: 0; y: 0);
  c1: (x: 0; y: 0);
  c2: (x: 0; y: 0);
  c3: (x: 0; y: 0);
  c4: (x: 0; y: 0);
  m1: (x: 0; y: 0);
  m2: (x: 0; y: 0);
  o1: (x: 0; y: 0);
  o2: (x: 0; y: 0);
  o3: (x: 0; y: 0);
  o4: (x: 0; y: 0));        // 0.98.a

  dv_envelopes: Tdv_envelope_list;

  radius_for_obtain: double = 1000;  // 205e  for obtain to the control   1000mm arbitrary init

  curviform_timbering: boolean = False;  // 215a

  no_spacings_confirm: boolean = False;   // 215b


function xy_to_dwg100(pin: Tpex): TPex;
// this function and next prepare x,y data for lists.
function xy_to_list(pin: Tpex): TPoint;        // prepare x,y data for list.
function blank_start(x: double): double;   // 17-10-02 0,76.a  blanking mods.

function SGN(x: double): double;
function SGZ(x: double): double;

function round_float(x: double; n: integer): double;
function round_str(x: double; n: integer): string;
function rad_str(r: double; dp: integer): string; // get radius as a string.

function limits(min, max, d: double; var return_code: integer): double;
function limits_i(min, max, i: integer): integer;

function max_i(n, m: integer): integer;              // return greatest of 2 integers.

function max(a, b: double): double;              // return greatest of 2 floats.
function min(a, b: double): double;              // return smallest of 2 floats.

function remove_esc_str(msg_str: string): string;
function insert_crlf_str(msg_str: string): string;
function remove_invalid_str(msg_str: string): string;
// remove characters invalid in filenames.

function lower_case_filename(name_str: string): string;
// 0.79.a lower case all filenames and change spaces to underscores.

function invalid_85a_file_name(str: string): boolean;

function space_lead(s: string): string;
// replace any leading 0 chars in string with a space.
function remove_space_str(msg_str: string): string;
// remove all space characters from string.
function remove_multispace_str(msg_str: string): string;
// reduce multiple spaces in string to singles.
function captext(d: double): string;

function fact(a: integer): double;        // return (a! = a factorial)

function transcalcs(draw_in_progress, auto_terms: boolean; k, tsn: double;
  var xn, yn, tn, rn: double): boolean;
//  Transition equations.
function calc_transition(rad1, rad2, zonel: double;
  var cen1x, cen1y, cen2x, cen2y, apartl, kval: double): boolean;

function set_font(fname: string; fsize: integer; fstyle: TFontStyles; fcolour: integer): TFont;

function time_now_modified(def: integer): integer; // modify Delphi float time format to integer;

function check_limit(bunch, shear: boolean; var p: TPoint): boolean;
// safety check on one pair of drawing co-ordinates.
function check_limits(var p1, p2: TPoint): boolean;
// safety check on both pairs of drawing co-ordinates.

function check_draw_dim_l(d: integer): boolean;         // check on a single drawing dimension.
function check_draw_dim_w(d: integer): boolean;         // 0.93.a mods

function extract_tbnumber_str(var tbnum_str: string): string;
// return next timber numbering string from the acummulated string.

procedure normalize_angle(var k: double);
function k_ram_str(k: double): string;
// get k angle as 1:n RAM string (up to 1:1)
procedure dotransform(krot, xrot, yrot: double; pin: Tpex; var pout: Tpex);

function rad_tanp1_p2(p1, p2: Tpex; tn: double; var rad, swing: double): boolean;    // 15-9-99.

procedure memory_alert;             // do memory fail message.

function calc_geo_radius(rout, xp, yp, kp: double; var rin, kin, krin, gpx: double): boolean;

procedure print_control_template(pdf: boolean);  // 0.91.d
procedure print_entire_pad(pdf: boolean);        // 0.91.d

procedure mouse_action_selected(caption_str, mouse_str, trail_str: string);
procedure unlock_both;

procedure cancel_paper_bunching;

procedure tick_not_normal;  // not printing 100%, change menu ticks.

procedure pad_mouse_move(shift_state: TShiftState; X, Y: integer);
procedure pad_mouse_down(mouse_button: TMouseButton; shift_state: TShiftState; X, Y: integer);

procedure click_bgnd_to_current(bgnd_options: boolean);
procedure click_bgnd_to_selected;

function check_peg_on_main: boolean;

procedure align_current_over_bgnd(index: integer; facing_facing, clicked: boolean);

procedure snake_onto_bgnd_peg(index: integer; facing_facing, alerts: boolean);

procedure get_cpi;     // copy/calculate current prototype info from current list.

procedure toggle_radius_lamp;
procedure toggle_ring_lamp;


procedure pad_mouse_up(mouse_button: TMouseButton; shift_state: TShiftState; X, Y: integer);


procedure swap_hand;

procedure select_switch;

procedure reset_defaults;

procedure pad_all_grey;
procedure pad_bright;
procedure pad_silver;
procedure pad_normal;
procedure pad_caption(Text: string);

procedure set_xing_k_i;     // set selector list index to match current k3n.

procedure docurving(transform_flag, slew_flag: boolean; xs, ys: double;
  var xc, yc, tn, rn: double);

procedure rotate_turnout(k: double; draw: boolean);    // rotate turnout k radians around peg.
procedure peg_curve;
// do curving calcs for the current peg position.

function check_radius(warn: boolean; var r: double): boolean;
// return true if curving radius was within limits.

procedure clear_transform_data;

procedure invert_curving;
procedure invert_handing;
procedure swap_end_for_end;

procedure crop_approach;

procedure make_double_track_calcs(side: integer);

procedure enable_slewing(mode: integer; do_peg_calcs_first: boolean);

procedure insert_half_diamond;

//procedure convert_to_half_diamond;
procedure convert_to_regular_half_diamond;  // 0.93.a

procedure convert_to_turnout;

procedure convert_to_or_from_gaunt(to_gaunt: boolean);  // 0.93.a ex 081

function make_mirror_on_peg: boolean;

function make_diamond_crossing: boolean;
function make_crossover(simple, allow_curviform, for_slip: boolean): boolean;  // 215a  209c

procedure snap_onto_bgnd_pegs;  // 0.79.a   27-05-06

procedure quick_gauge_click(i: integer);   // quick change of gauge and scale.

procedure lengths_click(degs: boolean);

function check_black_white: boolean;
// return True if he cancels (called from change printer colours).

procedure fix_radius(rad: double; click: boolean);     // set up fixed-radius curving.

function clrad_at_x(x: double): double;      // return the track centre-line radius at this xs.

procedure transition_clicked(trans_code: integer);
procedure make_transition_click(trans_hand: integer);
function make_transition_from_current_calcs: integer;

function do_auto_trans_swing_adjust(old_rad2_orgx, old_rad2_orgy: double): integer;

function do_degs_length_adjust(length_in_degs: double; var length_in_mm: double): integer;

function set_black_and_white: boolean;

procedure pt_convert;   // convert turnout to plain track on same alignment.

function check_infill_ok(str: string): boolean;
// ensure generator is on if he wants timber infill.

procedure adjacent_redraw;     //  do a re-draw after selecting/deselecting adjacent rails.
procedure normalize_kform;

procedure keep_colours1;           // scheme 1 colours for the keep form...
procedure keep_colours2;           // scheme 2 colours for the keep form...
procedure keep_colours3;           // scheme 3 colours for the keep form...

procedure railedges(gf, oe, cl: boolean);

procedure no_rails_warn;

procedure pad_view_fit_bgnd(group_only: boolean);  // zoom to fit background templates.

procedure explode_shrink(new_screenx: double; loop, wheel: boolean);
// mouse wheel mode added 0.97.d

procedure calc_peg_pad_pos;    // calculate position of peg on screen.

procedure new_notch(notch_data: Tnotch; link_group: boolean);    // set new notch position on pad.

procedure shift_radial_centre(to_notch: boolean);

function get_peg_for_notch: Tnotch;
function get_current_notch: Tnotch;

procedure shift_rotate_group(x_move, y_move, k_rot: double; egg_timer: boolean);

procedure do_group_link_to_notch;
procedure do_linked_notch;         // link notch to control template.

procedure peg_indicator_click;

procedure normal_adjust_menu_entry_click;

procedure make_double_track(side: integer);
// change to plain track in place of the current adjacent track.

procedure make_pt_geo_rad(int_ext: integer; click: boolean);

procedure make_separate_approach(click: boolean);

function normalize_transition: boolean; // normalize to template extents if zone outside them.

procedure set_plain_track(pt, new_label: boolean);

function shove_number_clicked(X, Y: integer): boolean;
// screen co-ords of a click, is it on a timber number?
procedure mouse_on_timber_number(X, Y: integer);
// highlight timber number if mouse currently over it.

function checkrail_label_clicked(X, Y: integer): boolean;
// 0.94.a screen co-ords of a click, is it on a check-rail label?
procedure mouse_on_check_label(X, Y: integer);
// 0.94.a highlight check-rail label if mouse currently over it.


procedure clear_current_name;

function snake_onto_this_peg(keep_dims: Tkeep_dims; facing_facing, alerts: boolean): boolean;

function aq25offset(xs: double; var k: double): double;
// return offset at xs on turnout road centre-line.

function curved_onto_calc(org_rad, onto_rad: double): double;
function equiv_rad_calc(curved_rad, onto_rad: double): double;    // 217a

function aq3offset(xtb: double; var k: double): double;
//  general utility - return offset at any xtb on aq=3 (curved stock rail).
function aq2offset(xtb: double; var k: double): double;
//  general utility - return offset at any xtb on aq=2 (curved turnout rail).

procedure shift_all_group;  // add current xshift_keeps, yshift_keeps to all group templates.
procedure twist_all_group;  // rotate all group templates.

function check_shove: boolean;    // check some timbers there for shove / select.

procedure fix_approach_length(snap: boolean; lmod: double);
procedure fix_exit_length(lmod: double);

procedure mirror_keeps_x;     // X mirror a group of templates about the notch.

procedure insert_turnout;

procedure set_trans_position_from_ctrl_0(os_offset, zone_len: double);
procedure set_slew_position_from_ctrl_0(start_offset, zone_len: double);

procedure new_label_position;

procedure warn_group_colour;

procedure snap_current_to_bgnd(notch_pos: Tnotch; facing_to_trailing: boolean);   // 0.79.a

procedure match_rolled_lengths(ctrl: integer);

procedure show_switch_info(full_size_mm, already_showing: boolean);  // 208a

function calc_switch(sw_info: Tswitch_info; h_diamond, current_calc: boolean): integer;
// calculate switch - return error code,

function set_csi_from_switch_info(sw_info: Tswitch_info): boolean;
// set current switch from supplied info.

function find_shove(str: string; create_new: boolean): integer;
// find str in current shove list, or create an empty slot for it.

procedure show_and_redraw(on_idle, allow_rollback_to_this: boolean);  // F12 reset.
procedure redraw_pad(on_idle, allow_rollback_to_this: boolean);

procedure cancel_adjusts(new_action: boolean);  //  cancel all adjusts and restore flags, etc..

procedure clear_shovedata;             // clear any current timber shoves.

procedure clear_check_diffs;           // clear any check-rail end diffs. 0.94.a

procedure delete_null_shove_entries;   // remove any unshoved entries from current shove list.

procedure shove_along_mouse_action;
procedure shove_throw_mouse_action;
procedure shove_crab_mouse_action;
procedure shove_length_mouse_action;
procedure shove_width_mouse_action;
procedure shove_twist_mouse_action;

procedure fill_kd(var keep_info: Ttemplate_info);
// copy control template data to the keep record.
procedure copy_keep(keep_info: Ttemplate_info);    // get control template data from a keep.

procedure update_lengths(var box_kd: Tkeep_dims);
// update stored plain track settings to match the control template.
procedure update_timbering(var box_kd: Tkeep_dims);
// update stored timbering to match the control template.
procedure update_customize_xing(var box_kd: Tkeep_dims);
// 214b  update V-crossing customizing
procedure update_trackbed_edges(var box_kd: Tkeep_dims);
// update stored trackbed edges settings to match the control template.
procedure update_centre_lines(var box_kd: Tkeep_dims);
// update stored track centre-line settings to match the control template.
procedure update_centre_line_offset_options(var box_kd: Tkeep_dims);
// update stored centre-line offset options to match the control template.
procedure update_rail_section(var box_kd: Tkeep_dims);
// update stored rail-section data to match the control template.
procedure update_radius_warning(var box_kd: Tkeep_dims);
// update stored radius warning limit to match the control template.


procedure copy_template_info_from_to(delete_shoves: boolean;
  var from_info, to_info: Ttemplate_info);

procedure alert_no_bgnd;
procedure alert_no_unused;
procedure alert_no_library;
function alert_no_group: boolean;    // return False if any get selected.

procedure mint_new_current(locked_length: integer);  // 208d locked_length added

procedure normalize_transforms;     // update shifts so that xform, yform can be zero,

procedure gocalc(calcs_code, mode: integer);    //  a new turnout wanted - let's do some calcs.

//091c procedure shift_onto_notch(click:boolean);  // click=True if he clicked the menu.
procedure shift_onto_notch(click, min_rot: boolean); // 0.93.a ex 081

function outoflist(aq: ERailData; nl: integer): TPoint;

function calc_snap_peg_data(code: integer): Tnotch;      // 0.79.a  27-05-06

procedure do_hide_current;      // set flags to hide control template.

procedure unlink_group;

procedure caption_add(Text: string);       // replace '...' in pad caption with '=' + text.

procedure redraw(on_idle: boolean);           // do a screen redraw.

procedure obtain_switch(n: integer);
// obtain control template switch from template in list.
procedure obtain_plain_track(n: integer);
// obtain control template plain-track settings from template in list.

function gauge_dims(from_list, mod_rads, mod_gauge_data: boolean): double;
// set up gauge and scale from selected item in list.

procedure set_y_datum;          // set up default y position.

procedure rescale_notch(ratio: double);

procedure printer_setup(cal_in_progress, black_white_setup: boolean);

function ask_impact_matrix(prindex: integer; prstr: string): boolean;
// ask if printer is dot-matrix impact type.

procedure mouse_symbol_click;  // symbol clicked on action form.

procedure action_label_click;

function mouse_x(X: integer): double;     // return x mm at this pad X pixels.
function mouse_y(X, Y: integer): double;   // return y mm at this pad Y pixels.

function check_grey_paper: boolean;     // return True if the paper colour is near to mid grey.
function check_dark_paper: boolean;     // return True if the paper colour is black or very dark.


procedure set_grid_spacings(calling_form: TForm);

procedure set_six_foot_ring;
procedure get_ring_size;
procedure get_ring_location;

procedure do_railedges;      // called from rail_options_unit


procedure error_b6_lh_reset;  // 0.93.a

procedure set_pad_start_colours(change_flag: boolean);

function calcturnout: boolean;             // calc all the turnout dimensions.

procedure update_rollback_register;       // maintain the roll-back register.

procedure enable_peg_positions;  // enable/disable the peg options (for Ctrl-# KB shortcuts).

procedure do_info_colours; // indicate if control template visible and accessible...


procedure init_rollbacks;    // init all roll-backs.
procedure templot_init;      // this routine runs only once.


procedure check_pad_views;   // 0.91.c  process pad view rollbacks once per second.

procedure mouse_action_release(cancelling_adjusts: boolean);   // 0.79.a  moved 0.91.c

procedure do_nothing;

procedure update_ruler_div;   // 0.93.a

function check_control_template_is_valid(cancel_str: string): boolean;   // 0.93.a

function store_and_background(click, zero_it: boolean): boolean;
// 0.93.a click=True means direct click by user.

procedure extend_template_from_zero;  // 0.93.a

procedure debug(str: string; abc: double); // 0.93.a

function make_curviform_ladder: boolean; // 0.93.a

function get_checkrail_diff(code: EMarkCode): Tcheck_end_diff;    // 0.94.a

procedure set_checkrail_diff(code: EMarkCode; this_diff: Tcheck_end_diff); // 0.94.a

procedure draw_dummy_vehicle_on_control_template(on_canvas: TCanvas);   // 0.98.a

function get_current_diffed_dims: string;

procedure action_panel_hint(hint_str: string);   // 205c  set hollow-triangle mouse action hint

function create_id_number_str(idnum, hand: integer; startx, turnoutx, ipx, fpx: double;
  plain_track, half_diamond, any_omitted: boolean): string;    // 208a

function get_store_beginner_help: string;  // 208a

function get_arc_centre(p1, p2, p3: Tpex; var arc_centre: Tpex): boolean;  // 208a

function make_branch_crossover: boolean;     // 209c

function do_show_modal(modal_form: TForm): TModalResult;   // 212a Wine bug
procedure show_modal_message(msg: string);                // 212a Wine bug

procedure retain_on_make;  // 213a

function ram_clm_str(ram_kn: double): string;

procedure companion_help(topic_url_str: string);     // 214a

function count_substrings(sub_str, text_str: string): integer;      // 215a

function calculate_turnout_radius(curving_rad: double;
  var heel_notch, mid_notch, xing_notch: Tnotch): double;
// 218a
function calculate_turnout_radius_beyond(curving_rad: double;
  var xing_notch, mid_notch, end_notch: Tnotch): double;  // 218b
function calculate_return_curve_radius(var exit_notch, mid_notch, trp_notch: Tnotch): double;
// 218d

function calc_peg_dims(code: integer; var pegx, pegy, pegangle: double): Tpeg_indicator_string;
// 218a moved to interface for make tandem

function tpex_from_tnotch(notch: Tnotch): Tpex;
function get_nearer_pex(p0, p1, p2: Tpex): Tpex;
function get_notch_distance(n1, n2: Tnotch): double;
function get_snap_peg_xy_data(code: integer): Tnotch;

procedure shift_group_into_positive_quadrant(warn: boolean);    // 219a

function title_swap(str: string): string;      // OT-FIRST


//______________________________________________________________________________

implementation

{$BOOLEVAL ON}


{$R *.lfm}

uses
  Math,
  Printers,
  alert_unit,
  config_unit,
  control_room,
  help_sheet,
  colour_unit,
  dxf_unit,
  mint_unit,
  info_unit,
  plain_track_unit,
  edit_memo_unit,
  keep_select,
  print_settings_unit,
  panning_unit,
  action_unit,
  preview_unit,
  gauge_unit,
  grid_unit,
  xing_select,
  jotter_unit,
  shove_timber,
  entry_sheet,
  bgnd_unit,
  switch_select,
  wait_message,
  print_unit,
  enter_timber,
  calibration_unit,
  pdf_unit,
  export_unit,
  platform_unit,
  data_memo_unit,
  background_shapes,
  math2_unit,
  check_diffs_unit,
  rail_options_unit, { OT-FIRST file_viewer, chairs_unit,}
  trackbed_unit,
  create_tandem,
  xtc_unit,
  shoved_timber,
  curve;

const

  grid_help_all_str: string = '        Grid  Spacings' +
    '||The grid line spacings entered here will apply to both the screen trackpad and the printed templates.'
    + '||The grid lines are intended only to provide a "graph-paper" background to aid planning and alignment;'
    + ' changing these spacings has no effect on the design of the templates or their position on the drawing.'
    + '||It is possible to use different spacings for the horizontal and vertical grid lines' +
    ' ( so that the grid boxes are no longer squares ), but the units for both must be the same (i.e. you'
    + ' can''t for example have mm dimensions for one direction and inches for the other).' +
    '||If the current trackpad zoom setting causes the grid lines to be too closely spaced, Templot0 will omit some of them'
    + ' from the screen.' +
    '||If the current print size setting causes the grid lines to be too closely spaced, Templot0 will omit some of them'
    + ' from the printed output.' +
    '||The minimum grid spacing is 0.1 mm (or 0.004") which is useful when zooming in to examine fine detail.';

var
  last_code_generated: integer = 0;
  int_size: integer;                 // size in bytes of integers (4 at present);
  temp_font: TFont;

  no_rad_confirm: boolean = False;

  switch_type: integer = -1;
  // type of switch.  0 = curved planing or straight switch; -1 = semi-curved switch;  1 = double-curved switch.

  //   k4_limit:double=Pi/2-0.001;   // turnout road mustn't swing more than 90 degrees (for straight turnout).
  k4_limit: double = Pi / 3;
  // 0.93.a turnout road mustn't swing more than 60 degrees (for straight turnout).

  sep_limit: double = 0.0001;
  // make transition rad centres, separation limit 0.0001 mm for a match (arbitrary).

  shovetimbx_now: double = 0;
  shovex_now: double = 0;
  shovek_now: double = 0;
  shoveo_now: double = 0;
  shovel_now: double = 0;
  shovew_now: double = 0;
  shovec_now: double = 0;

  yd: double;                      // y datum for drawing.

  wing_tbcount: integer;

  switch_only: integer;              // = X div form width.

  f7_snap_allow: boolean = True;       // 0.82.a  allow F7 snapping (Shift key toggle).

  f6_swing_angle: double = 0;        // 0.91.b  F6 options.

  in_progress: boolean;            // gocalc no re-entry flag.

  tbn: integer;

  // 208a number_point:Tpex;

  number_point_screen, number_point_output: Tpex;   // 208a

  length_now, xing_now, curving_now: integer;
  shift_now_x, shift_now_y: integer;

  labels_now_x: integer = 0;     // 0.82.d
  labels_now_y: integer = 0;     // 0.82.d

  ring_now_x, ring_now_y: integer;
  ringdia_now_y: integer;
  peg_now_x, peg_now_y: integer;
  notch_now_x, notch_now_y: integer;
  ruler1_now_x, ruler1_now_y, ruler2_now_x, ruler2_now_y: integer;

  shovetimb_now: integer;
  shove_now_x, shove_now_y: integer;

  approach_now, blanking_now, roll_now, roam_now, zoom_now, spot_now, datum_now,
  trans_length_now, trans_start_now, slew_start_now, slew_length_now, slew_amount_now: integer;
  slew_factor_now: integer;
  porg_now_x, porg_now_y: integer;

  entry_straight_now: integer;  // 0.91.b

  turnout_road_now_X: integer = 0;  // 209a
  main_road_now_X: integer = 0;     // 217a

  // 0.93.a

  platform_ms_start_width_now_Y: integer;
  platform_ms_end_width_now_Y: integer;

  platform_ts_start_width_now_Y: integer;
  platform_ts_end_width_now_Y: integer;

  platform_ms_start_now_X: integer;
  platform_ms_length_now_X: integer;

  platform_ts_start_now_X: integer;
  platform_ts_length_now_X: integer;

  platform_ms_start_skew_now_X: integer = 0;   // 207a
  platform_ms_end_skew_now_X: integer = 0;     // 207a
  platform_ts_start_skew_now_X: integer = 0;   // 207a
  platform_ts_end_skew_now_X: integer = 0;     // 207a


  trackbed_ms_start_now_X: integer;      // 215a ...
  trackbed_ms_length_now_X: integer;
  trackbed_ts_start_now_X: integer;
  trackbed_ts_length_now_X: integer;


  gaunt_now: integer = 0;
  veexing_now: integer = 0;
  hdxing_now: integer = 0;

  gaunt_offset_now_mm: double = 0;
  vee_now: double = 0;
  hdkn_now: double = 0;

  gaunt_rad_now: integer = 0;      // 217b
  gaunt_curvature_now: double = 0;  // 217b

  rect_now_X: integer = 0;
  rect_now_Y: integer = 0;

  output_rectangle_x_now: double = 0;
  output_rectangle_y_now: double = 0;


  dv_now: integer = 0;              // 0.98.a  dummy vehicle
  dv_clear_now: integer = 0;
  dv_start_now: double = 0;
  dv_copy_start_now: double = 0;  // 215c
  dv_clearance_now: double = 0;

  ts_adj_now: integer = 0;          // 213a
  trtscent_pi_now: double = 0;

  ms_adj_now: integer = 0;
  trmscent_pi_now: double = 0;


  mouse_diffs_now_X: integer = 0;       // 0.94.a ...
  mouse_diffs_now_Y: integer = 0;

  mouse_check_len_mm_now: double = 0;
  mouse_check_flare_mm_now: double = 0;
  mouse_check_gap_mm_now: double = 0;

  diff_dir: double = 1.0;  // +/-1 mouse diffing direction

  printsize_now_X: integer;

  shapes_now_x, shapes_now_y: integer;

  rectangle_in_progress: boolean = False;
  rectangle_exists: boolean = False;

  mouse_drawing_in_progress: boolean = False;

  mouse_down_x: double = 0;
  mouse_down_y: double = 0;

  draw_mouse_down_X: integer = 0;
  draw_mouse_down_Y: integer = 0;

  temp_mouse_X: integer = 0;
  temp_mouse_Y: integer = 0;

  toggle_1: integer = 0;     // flashing lamps toggles.
  toggle_2: integer = 0;

  twist_dir: double = 1;
  orbit_dir: double = 1;

  opposite_way: boolean = False;
  // reverse sense of mouse actions for turnout facing opposite way.

  panel_mousedown_X: integer = 0;
  panel_mousedown_Y: integer = 0;

  now_pen, prior_pen: integer;

  done_rails: boolean = False;

  pad_pegx, pad_pegy: integer;         // peg screen co-ords.
  rad_centx, rad_centy: integer;       // screen co-ords for curving rad centre.

  peg_arm1: Tmark;
  peg_arm2: Tmark;

  timbcentre_wait: Ttimbcentre_wait;

  highlighted_timbnum_X: integer = 0;
  highlighted_timbnum_Y: integer = 0;
  highlighted_timbnum_str: string = '';      // flag no timber highlighted.

  highlighted_round_rect_x1: integer = 0;    // 0.94.a for check-rail label locations
  highlighted_round_rect_y1: integer = 0;
  highlighted_round_rect_x2: integer = 0;
  highlighted_round_rect_y2: integer = 0;

  timb_str: string = '';
  current_switch_name: string = '';

  auto_spiral_adjust: boolean = True;   // for make double track.

  wing_reach1: double = 48;
  // full-size inches - size 1 wing rail reach length (forward from "A").
  wing_reach2: double = 78;
  // full-size inches - size 2 wing rail reach length (forward from "A").

  ck_working1: double = 78;
  // full-size inches - size 1 check rail working length (back from "A").
  ck_working2: double = 108;
  // full-size inches - size 2 check rail working length (back from "A").
  ck_working3: double = 138;
  // full-size inches - size 3 check rail working length (back from "A").

  ck_ext1: double = 48;
  // full-size inches - size 1 check rail extension length (forward from "A").
  ck_ext2: double = 78;
  // full-size inches - size 2 check rail extension length (forward from "A").

  check_ms_wklen: double = 108;   // control template check MS lengths
  check_ms_extlen: double = 48;
  wgl_ms_len: double = 48;        // ditto wing.

  check_ts_wklen: double = 108;   // control template check TS lengths
  check_ts_extlen: double = 48;
  wgl_ts_len: double = 48;        // ditto wing.

  wgl_ms: double = 0;            // wing reach in mm.
  wgl_ts: double = 0;            // ditto wing.

  kckl_dk: double = 0;           // K check lengths in mm (half-length)
  kckl_mk: double = 0;

  ckmidx_ms: double = 0;
  cktsmid_offset: double = 0;


  min_diff: double = 0;    // 0.94.a mouse diffs limits
  max_diff: double = 0;


  sliptipsl: double;
  // approx slip switch tips from hd-toe for timber extension calcs. 0.77.b  10-11-02.
  sliprad: double;      // approx slip radius (mm).

  datumx_on_pad, datumy_on_pad: double;

  sw_front_inches: double = 65;   // f.s. inches. (arbitrary);

  shovex: double = 0;
  shovek: double = 0;
  shoveo: double = 0;
  shovel: double = 0;
  shovew: double = 0;
  shovec: double = 0;

  view_delay_count: integer = 0;     // 0.91.c
  pad_view_now: Tpad_view_data;    // 0.91.c

  _i: integer;        // more 32-bit integers (these 2 were 16-bit in GFA)

  done_calcs: boolean = False;  // 0.93.a


  rmin_mm: double = 0;  // 0.98.a moved to global for dummy vehicle calcs.


  old_mouse_move_X: integer = 0;   // 205e
  old_mouse_move_Y: integer = 0;   // 205e


  //-----------------------------------------------------------------------
  //      arrays...

  seg_termx: array[0..4, ERailData] of double;        // only aq=2, 3, 10, 11 actually used.

  //_________________________________________________________________________________________

  form_overwrite_mode: boolean = False;  // 214a

  making_a_diamond: boolean = False;  // 215a

function f28000(aq: ERailData; xs, ys: double): integer; forward;
function f29000(aq: ERailData; pc: Tpex): integer; forward;
//  Put xc,yc (in pc) in rail-data array.

function intolist(aq: ERailData; nl: integer; pt: TPoint): integer; forward;

function new_calc_draw(on_canvas: TCanvas; calcs_code, mode: integer): boolean;
  forward;   // calc and draw all rail lines and marks.

function turnoutst_main(aq: ERailData; xb, xe, xs: double): double; forward;
function turnoutst_wing(aq: ERailData; {fl,}xb, xe, xs: double): double; forward;
function turnoutst_check(aq: ERailData; {fl,}xb, xe, xs: double): double; forward;

function flarerad(aq: ERailData; {fl,k5,}xs: double{; flinout:integer}): double;
  forward;   // calc instantaneous radius in curved flares.


function cuflare(fl, flk, flb, fle, xs: double; fld: integer): double; forward;

function radcurve(aq: ERailData; {fl,k5,}xs: double{; flway:integer}): double;
  forward;  // 0.93.a ex 081

function returncurve(xs, radmod: double): double; forward;
function calc_curving: boolean; forward;

function convert_point(p: Tpex): Tpoint; forward;
// input in mm f.p. , convert to 1/100ths mm. integer.

function do_auto_trans_start_adjust(old_rad1_orgx, old_rad1_orgy, old_rad2_orgx,
  old_rad2_orgy: double): integer;
  forward;
function do_auto_trans_length_adjust(apart_len_wanted: double): integer; forward;

function pad_marks_current(on_canvas: TCanvas; ink: boolean): boolean; forward;
// draw all the marks (control template). (not rail ends)

procedure set_current_notch(notch_data: Tnotch); forward;

function oneline(aq: ERailData): boolean; forward; //  Calc a rail-line.

procedure doradcurve(aq: ERailData; {fl,}xb, xe: double); forward;
procedure dostr(aq: ERailData; xb, xe, ys: double); forward;
procedure dostr_joggle(aq: ERailData; xb, xe, ys: double); forward;

procedure turnroad_cl; forward;                           // turnout road track centre-line.

procedure k_checkrail_ds(aq: ERailData); forward;    // K-crossing check rail, DS.

procedure stflare(aq: ERailData; fl, flk, xb, xe, yfl: double; fldir: integer;
  flsgn: double; machined_end: boolean); forward;
procedure stckrail(aq: ERailData{; fl:extended}); forward;
procedure cuckrail(aq: ERailData{; fl:extended}); forward;

function strails(aq: ERailData): boolean; forward;  // 093a ex 081  all straight rails.

procedure knuckle(aq: ERailData); forward;     // knuckle radius  214a

procedure retrails(aq: ERailData); forward;
procedure cuwing(aq: ERailData{; fl:extended}); forward;
procedure curails(aq: ERailData{; fl:extended}); forward;
procedure stxrail(aq: ERailData{; fl:extended}); forward;
procedure stwing(aq: ERailData{; fl:extended}); forward;
procedure stcurail(aq: ERailData{; fl:extended}); forward;
procedure stvee(aq: ERailData); forward;
procedure cuvee(aq: ERailData{; fl:extended}); forward;
procedure docrossing(aq: ERailData;{fl,}xb, xe: double; flway: integer); forward;
procedure doreturn(aq: ERailData; xb, xe, radmod: double); forward;

procedure init_rotate(x, y: double; rad_centre: boolean); forward;
// set up transform constants for rotates.

function show_a_line(on_canvas: TCanvas; aq: ERailData; pen_width: integer;
  erasing: boolean): boolean;
  forward;  //  draw a rail-line on the screen.

procedure trail_xing(X: integer); forward;
procedure trail_curving(Y: integer); forward;
procedure trail_swell(Y: integer); forward;

procedure init_turnout(gauge_index: integer); forward;
procedure do_railends; forward;                                         // calc rail end marks.
procedure draw_rail_endmarks(on_canvas: TCanvas; ink: boolean); forward;  // draw the rail ends.
procedure guidemarks; forward;

procedure add_check_labels; forward;          // 0.94.a

procedure calctimbers; forward;
procedure toesleeper(joint: boolean); forward;
procedure plain_sleepers(xtb: double; dir: integer; full_length, retcurve: boolean); forward;
procedure switchtimbers; forward;
procedure dotimber(retcurve, joint: boolean); forward;
procedure drawtimbol(retcurve, joint: boolean); forward;

//procedure drawchairs(retcurve:boolean);forward;                      // mark chair outlines on timber

procedure tbnumber(retcurve: boolean); forward;
procedure endsleeper(x: double; full_length, retcurve, joint: boolean; dir: integer); forward;

procedure drawtimbcl(retcurve: boolean); forward;
// mark timber centre-line
procedure drawtimber(full_length, retcurve: boolean); forward;     // mark timber outline.

procedure timberend(size: integer); forward;

function xdims: boolean; forward;
// 0.93.a as 081   //  calculate rail x dimensions from origin.

procedure update_check_diff_panels; forward;  // 0.94.a

procedure trail_check_len_mm(X: integer); forward;    // 0.94.a  check rail diffs
procedure trail_check_flare_mm(X: integer); forward;  // 0.94.a  check rail diffs
procedure trail_check_gap_mm(Y: integer); forward;    // 0.94.a  check rail diffs

function pad_X(x: double): integer; forward;   // return pad X pixels at this x mm.
function pad_Y(y: double): integer; forward;   // return pad Y pixels at this y mm.

function draw_xing_label(k, xlabel, yms, yts, ymid, xnote, ynote: double): Tpex; forward;
// 211b mark the crossing labels

//______________________________________________________________________________________

procedure do_nothing;

begin
end;
//_____________________________________________________________________________________

function title_swap(str: string): string;      // OT-FIRST

begin
  Result := StringReplace(str, 'Templot0', Application.Title, [rfReplaceAll, rfIgnoreCase]);
end;
//______________________________________________________________________________

procedure debug(str: string; abc: double);

begin
  show_modal_message(str + ' = ' + FloatToStr(abc));
end;
//______________________________________________________________________________

procedure Tmath_form.FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);

begin
  if Key = VK_PAUSE then
    Application.Minimize;    //  hide TEMPLOT on PAUSE key.

  if Key = VK_INSERT      // 214a
  then begin
    form_overwrite_mode := not form_overwrite_mode;
    if form_overwrite_mode = True then
      overwrite_label.Caption := 'OVR'
    else
      overwrite_label.Caption := 'INS';

    Key := 0;
  end;
end;
//___________________________________________________________________________________

procedure Tmath_form.FormActivate(Sender: TObject);

begin
  math_editbox.SetFocus;
end;
//__________________________________________________________________________________________

function count_substrings(sub_str, text_str: string): integer;      // 215a

begin
  if (Length(sub_str) = 0) or (Length(text_str) = 0) or (Pos(sub_str, text_str) = 0) then
    Result := 0
  else
    Result := (Length(text_str) - Length(StringReplace(text_str, sub_str, '', [rfReplaceAll]))) div
      Length(sub_str);
end;
//______________________________________________________________________________

procedure redraw(on_idle: boolean);           // do a screen redraw.

begin
  if on_idle = True then begin
    calcs_done_and_valid := False;      // calcs have not been done.
    data_changed := True;               // for on_idle re-draw.
  end
  else begin
    gocalc(2, 0);

    if (do_rollback = True) and (pad_form.Active = True) then
      update_rollback_register;                 // maintain the roll-back register.
    do_rollback := True;                                // default setting for next call.
  end;
end;
//_______________________________________________________________________________________

procedure show_and_redraw(on_idle, allow_rollback_to_this: boolean);  // F12 reset.

begin
  cancel_adjusts(False);
  normal_adjust_menu_entry_click;
  hide_current_flag := False;
  save_hide := False;

  with pad_form do begin
    // 209c hide_current_menu_entry.Checked:=False;
    //hide_current_popup_entry.Checked:=False;

    show_control_template_menu_entry.Checked := True;   // 209c   radio item
    show_control_template_popup_entry.Checked := True;  // 209c   radio item
  end;//with

  do_rollback := allow_rollback_to_this;
  redraw(on_idle);
end;
//______________________________________________________________________________________

procedure redraw_pad(on_idle, allow_rollback_to_this: boolean);

begin
  do_rollback := allow_rollback_to_this;
  redraw(on_idle);
end;
//______________________________________________________________________________________

procedure reset_defaults;            // establish any resettable defaults.
// come here before every re-calc (from turnout_dims).
begin

  if out_factor = 0 then
    out_factor := 1;                        // default full size print.

  if ABS(aspect_distortion_factor) < minfp then
    aspect_distortion_factor := 1; // div zero so no distortion.
  if ABS(x_distortion_factor) < minfp then
    x_distortion_factor := 1;
  if ABS(y_distortion_factor) < minfp then
    y_distortion_factor := 1;

  list_factor_x := x_distortion_factor * aspect_distortion_factor;
  // for data lists. need to do calc once only per redraw.
  list_factor_y := y_distortion_factor / aspect_distortion_factor;

  if incx = def_req then
    incx := SQRT(9 * scale);      // default step size is SQRT of 9ft scale,
  // = 6 mm steps for 4mm scale;
  // = 8 mm approx steps for 7mm scale.
  turnoutx_max := xy_pts_c * incx;                   // limit overall length.

  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;
  if xorg > turnoutx then
    xorg := turnoutx;

  if g = def_req then
    g := 56.5 * inscale;             // default 4' 8.5" gauge.

  // set up all the proto-info gauge defaults...

  with cpi do begin

    if gauge_pi = def_req then
      gauge_pi := 56.5 * inscale;     // default 4' 8.5" gauge.

    if fw_pi = def_req then
      fw_pi := 1.75 * inscale;           // default 1.75" dead-scale flangeway.
    if fwe_pi = def_req then
      fwe_pi := fw_pi + 1.75 * inscale;   // default 1.75" flare-out.

    // new check and wing dimensioning : v:0.71.a 25-5-01...

    if wing_ms_reach1_pi = def_req then
      wing_ms_reach1_pi := 48;   // size 1 wing rails 48" reach default from centre of "A" timber.
    if wing_ms_reach2_pi = def_req then
      wing_ms_reach2_pi := 78;   // size 2 wing rails 78" reach default from centre of "A" timber.


    if ck_ms_working1_pi = def_req then
      ck_ms_working1_pi := 78;
    // full-size  78 inches - size 1 MS check rail working length (back from "A").
    if ck_ms_working2_pi = def_req then
      ck_ms_working2_pi := 108;
    // full-size 108 inches - size 2 MS check rail working length (back from "A").
    if ck_ms_working3_pi = def_req then
      ck_ms_working3_pi := 138;
    // full-size 138 inches - size 3 MS check rail working length (back from "A").


    if ck_ms_ext1_pi = def_req then
      ck_ms_ext1_pi := 48;
    // full-size 48 inches - size 1 MS check rail extension length (forward from "A").
    if ck_ms_ext2_pi = def_req then
      ck_ms_ext2_pi := 78;
    // full-size 78 inches - size 2 MS check rail extension length (forward from "A").


    // old check rail dimensioning - included in file for use in earlier versions than 0.71.a...

    if old_winglongs_pi = def_req then
      old_winglongs_pi := 48;      // default 4'0" short wing rails.
    if old_winglongl_pi = def_req then
      old_winglongl_pi := 78;      //   ditto 6'6" long wing rails.

    if old_cklongs_pi = def_req then
      old_cklongs_pi := 126;      // default 10'6" short check rails.
    if old_cklongm_pi = def_req then
      old_cklongm_pi := 156;      //  ditto 13'0" medium check rails.
    if old_cklongl_pi = def_req then
      old_cklongl_pi := 186;      //  ditto 15'6" long check rails.
    if old_cklongxl_pi = def_req then
      old_cklongxl_pi := 216;    //  ditto 18'0" extra-long check rails.

    if xing_fl_pi = def_req then
      xing_fl_pi := 36 * inscale;     // default 3'0" flare on wing/check rails (not h-d).

    if railtop_pi = def_req then
      railtop_pi := 2.75 * inscale;          // default rail top width, scale 2.75".
    if railbottom_pi = def_req then
      railbottom_pi := 5.5 * inscale;
    // default flatbottom base, scale 5.5" (FB-109, BS-110A, BS-113A). 11-5-01.

    if rail_section = 2    // head and foot - assume flatbottom rail..
    then begin
      if rail_height_pi = def_req then
        rail_height_pi := 6.25; // default rail height, scale 6.25" (flatbottom). 16-5-01.
      if seat_thick_pi = def_req then
        seat_thick_pi := 1.250;  // default FB baseplate seating thickness 1.250" (for 3D in DXF).
    end
    else begin        // assume bullhead..
      if rail_height_pi = def_req then
        rail_height_pi := 5.71875;
      // default rail height, scale 5.23/32" (BS-95R bullhead). 16-5-01.
      if seat_thick_pi = def_req then
        seat_thick_pi := 1.75;
      // default chair seating thickness 1.75" bullhead (for 3D in DXF).
    end;

    // these are for 3-D in DXF...

    if seat_thick_pi = def_req then
      seat_thick_pi := 1.75;      // 1.750 inches full-size chair seating thickness.

    if rail_inclination_pi = def_req then
      rail_inclination_pi := 0.0499584;    // radians (1:20).
    if foot_height_pi = def_req then
      foot_height_pi := 7 / 16;              // 7/16" inches full-size  edge thickness.

    if chair_outlen_pi = def_req then
      chair_outlen_pi := 9.25;   // 9.25 inches full-size from rail gauge-face
    if chair_inlen_pi = def_req then
      chair_inlen_pi := 5.25;    // 5.25 inches full-size from rail gauge-face
    if chair_width_pi = def_req then
      chair_width_pi := 8.0;     // 8 inches full-size
    if chair_corner_pi = def_req then
      chair_corner_pi := 1.0;    // 1 inch full-size corner rad.

    if timber_thick_pi = def_req then
      timber_thick_pi := 5.0;    // 5 inches full-size timber thickness.


    if trtscent_pi = def_req then
      trtscent_pi := 134 * inscale;   // 11' 2" track centres turnout-side
    if trmscent_pi = def_req then
      trmscent_pi := 134 * inscale;   // ditto main-side

    if retcent_pi = def_req then
      retcent_pi := trtscent_pi;     // return curve track centres

    if tbwide_pi = def_req then
      tbwide_pi := 12;             // 12" wide turnout timbers.
    if slwide_pi = def_req then
      slwide_pi := 10;             // 10" wide plain sleepers.

    if jt_slwide_pi = def_req_single then
      jt_slwide_pi := 10;       // 10" wide joint sleepers.   212a

    if xtimbsp_pi = def_req then
      xtimbsp_pi := 30;       // !!! disused in 0.75.a 14-10-01. 30" timber spacing at crossing.
    if ftimbspmax_pi = def_req then
      ftimbspmax_pi := 30;     // 30" ditto for closure space.

    if tb_pi = def_req then begin
      // TT or 00 short sleepers...
      if gauge_i = t_TT3_i then
        tb_pi := 24;   // in mm.
      if gauge_i = t_TTI_i then
        tb_pi := 24;
      if gauge_i = t_TTF_i then
        tb_pi := 24;

      if gauge_i = t_TMS_i then
        tb_pi := 25;
      if gauge_i = t_TMF_i then
        tb_pi := 25;

      if gauge_i = t_00SF_i then
        tb_pi := 32;
      if gauge_i = t_00BF_i then
        tb_pi := 32;
      if gauge_i = t_00H0_i then
        tb_pi := 32;
      if gauge_i = t_00DGF_i then
        tb_pi := 32;
      if gauge_i = t_00DGI_i then
        tb_pi := 32;
      if gauge_i = t_00BRMSB_i then
        tb_pi := 32;

      if tb_pi <> def_req   // TT or 00..
      then begin
        eight_foot_six := False;
        nine_foot := False;
        pad_form.sleepers_otherlength_menu_entry.Checked := True;   // radio item.
      end
      else begin
        if eight_foot_six = True then
          tb_pi := 102 * inscale;  // 8'6" timbers.
        if nine_foot = True then
          tb_pi := 108 * inscale;       // 9' timbers.
        if tb_pi = def_req then
          tb_pi := old_tb_pi * inscale;  // non-standard - adjust to the scale change.
      end;
    end;

    if min_radius_pi = def_req then
      min_radius_pi := 152 * scale;  //  152 ft. minimum radius warning.
    //  = 608 mm (24" approx) in 4mm scale.
    //  = 1064 mm (42" approx) in 7 mm scale.

    // mods 11-5-01 v:0.71.a...

    if random_end_pi = def_req then
      random_end_pi := 0;         //  amount of timber-end randomising.
    if random_angle_pi = def_req then
      random_angle_pi := 0;     //  amount of timber_angle randomising.

  end;//with

  get_cpi;                                       // and use these values.

  if randend = def_req then
    randend := 0;            // no end randomizing.            *
  if randangle = def_req then
    randangle := 0;        // equalizing angle not randomised *

  if fixed_sl = def_req then
    fixed_sl := fw * 2 * k3n;

  if ring_dia = def_req then
    ring_dia := 134 * inscale - g - railtop * 2;   // spacing ring dia. (6ft way)

  if peg_arm_length = def_req then
    peg_arm_length := 3 * scale;       // default 3ft.

  rings[0, 2] := ring_dia;
  rings[0, 3] := ring_dia + railtop * 2;                               // outer diameter.

end;
//____________________________________________________________________________________________

procedure reset_trans;     // reset transition and curving defaults.

begin
  nomrad := 660 * scale;    // default curving radius. (660ft / 10 chains)        *

  nomrad1 := max_rad;     // first transition radius ("straight")
  nomrad2 := nomrad;      // second transition radius (as current)

  os := 0;                // length of first radius (straight) (nil)
  tst := 66 * scale;        // transition length (66ft - 1 chain)
  //ycurv:=0;             // curving line offset
end;
//_____________________________________________________________________________________________

procedure clear_shovedata;     // clear any current timber shoves.

begin
  current_shove_list.Clear;
end;
//_________________________________________________________________________________________

procedure clear_check_diffs;  // 0.94.a  clear any current check rail diffs

begin

  with ccd do begin         // check-rail diffs (mouse modifiers)

    end_diff_mw.len_diff := 0;
    end_diff_mw.flr_diff := 0;
    end_diff_mw.gap_diff := 0;
    end_diff_mw.type_diff := 0; // byte

    end_diff_me.len_diff := 0;
    end_diff_me.flr_diff := 0;
    end_diff_me.gap_diff := 0;
    end_diff_me.type_diff := 0; // byte

    end_diff_mr.len_diff := 0;
    end_diff_mr.flr_diff := 0;
    end_diff_mr.gap_diff := 0;
    end_diff_mr.type_diff := 0; // byte

    end_diff_tw.len_diff := 0;
    end_diff_tw.flr_diff := 0;
    end_diff_tw.gap_diff := 0;
    end_diff_tw.type_diff := 0; // byte

    end_diff_te.len_diff := 0;
    end_diff_te.flr_diff := 0;
    end_diff_te.gap_diff := 0;
    end_diff_te.type_diff := 0; // byte

    end_diff_tr.len_diff := 0;
    end_diff_tr.flr_diff := 0;
    end_diff_tr.gap_diff := 0;
    end_diff_tr.type_diff := 0; // byte

    end_diff_mk.len_diff := 0;
    end_diff_mk.flr_diff := 0;
    end_diff_mk.gap_diff := 0;
    end_diff_mk.type_diff := 0; // byte

    end_diff_dk.len_diff := 0;
    end_diff_dk.flr_diff := 0;
    end_diff_dk.gap_diff := 0;
    end_diff_dk.type_diff := 0; // byte

  end;//with
end;
//______________________________________________________________________________

function get_checkrail_diff(code: EMarkCode): Tcheck_end_diff;    // 0.94.a

begin
  with null_diff do begin   // return for invalid code

    len_diff := 0;   // length differ  inches f-s
    flr_diff := 0;   // flare length   inches f-s
    gap_diff := 0;   // end gap        model mm

    type_diff := 0;   //byte   // 0=no diff   1=change to bent flare    2=change to machined flare
  end;//with

  case code of

    eMC_501_MSWorkingEnd:
      Result := ccd.end_diff_mw;
    eMC_502_MSExtensionEnd:
      Result := ccd.end_diff_me;
    eMC_503_MSWingRail:
      Result := ccd.end_diff_mr;
    eMC_504_TSWorkingEnd:
      Result := ccd.end_diff_tw;
    eMC_505_TSExtensionEnd:
      Result := ccd.end_diff_te;
    eMC_506_TSWingRail:
      Result := ccd.end_diff_tr;
    eMC_507_MSKCheckRail:
      Result := ccd.end_diff_mk;
    eMC_508_DSWingRail:
      Result := ccd.end_diff_dk;

    else
      Result := null_diff;  // ???

  end;//case
end;
//______________________________________________________________________________

procedure set_checkrail_diff(code: EMarkCode; this_diff: Tcheck_end_diff);

begin

  case code of

    eMC_501_MSWorkingEnd:
      ccd.end_diff_mw := this_diff;
    eMC_502_MSExtensionEnd:
      ccd.end_diff_me := this_diff;
    eMC_503_MSWingRail:
      ccd.end_diff_mr := this_diff;
    eMC_504_TSWorkingEnd:
      ccd.end_diff_tw := this_diff;
    eMC_505_TSExtensionEnd:
      ccd.end_diff_te := this_diff;
    eMC_506_TSWingRail:
      ccd.end_diff_tr := this_diff;
    eMC_507_MSKCheckRail:
      ccd.end_diff_mk := this_diff;
    eMC_508_DSWingRail:
      ccd.end_diff_dk := this_diff;

  end;//case
end;
//______________________________________________________________________________

procedure templot_init;         // this routine runs only once.

var
  aq: ERailData;
  n: integer;
  printers_count: integer;
  temp: double;

begin

  if initdone_flag = True then
    EXIT;

  for aq in ERailData do begin

    SetLength(xy_p[aq], 0);   // (arrays containing x rail data in 1/100 of a mm.

    nlnow_array[aq] := 0;     //  next available index into each aq array.
    nlmax_array[aq] := -1;    //  max nlnow so far used for each aq.
    nldim_array[aq] := -1;    //  array length (max index) for each aq.

  end;//for

  paper_way := 1;             // use portrait paper orientation.

  try
    Printer.Title := 'Templot';
    printers_count := Printer.Printers.Count;
    // first read of Printers creates the string list.

    if printers_count < 1                            // do we have any printers ?
    then begin
      no_printer_available := True;
      show_margins := 0;
      pad_form.page_outlines_printer_menu_entry.Enabled := False;
      pad_form.page_outlines_off_menu_entry.Checked := True;

      alert(2, '    no  printer',
        'Templot is unable to locate a printer driver on this system. On some systems this may prevent Templot0 starting.'
        + '||It is not necessary for a printer to be physically present, all that is needed is a printer driver program from the Windows CD-ROM.' + '||To install a printer driver, from the Windows taskbar click START > SETTINGS > PRINTERS > ADD PRINTER.',
        '', '', '', '', '', 'O K', 0);
    end

    else begin
      no_printer_available := False;

      with Printer do begin                   // create and init info for each printer...
        for n := 0 to printers_count - 1 do begin
          if printer_list.AddObject(Printers.Strings[n], Tprint_cal.Create) <> n then
            run_error(181);  // we come here only once.

          with Tprint_cal(printer_list.Objects[n]).cal_data do begin
            printer_impact := -1;
            // type not yet known.
            printer_calibrated := False;
            printer_head_factor := 1.0;
            printer_roller_factor := 1.0;
          end;//with

        end;//for
      end;//with

      if page_info(True, True, False, 0) = True    //  read the printer details from API.
      then begin
        //show_margins:=True;               out 0.93.a
        Printer.Orientation := poPortrait;
      end
      else begin                         // no printer or no driver.
        no_printer_available := True;
        show_margins := 0;
        pad_form.page_outlines_printer_menu_entry.Enabled := False;
        pad_form.page_outlines_off_menu_entry.Checked := True;          // radio item
      end;
    end;
  except
    no_printer_available := True;
    show_margins := 0;
    pad_form.page_outlines_printer_menu_entry.Enabled := False;
    pad_form.page_outlines_off_menu_entry.Checked := True;          // radio item
  end;//try

  // reset startup to sketchboard defaults for page outlines (0.93.a)...

  page_width := 18000;  // 180mm 0.93.a in 1/100 mm. between trim margins (actual printer),
  page_length := 26000; // 260mm 0.93.a these sizes are used for the page outlines on the pad view.


  time_now_modified(Random($7FFFFFFF));
  // init timestamp code for keeps. (this sets last_code_generated).

  init_gauge_list;                      // go fill the gauge/scale list data.

  data_changed := True;                   // to get the endless loop started o.k.
  trans_terms := 8;                       // default 8 terms in transition expansion.
  trans_auto := True;                     // but use the auto terms option instead.

  with dxf_form do begin                         // init colours and styles in the combo boxes.
    rails_combo.ItemIndex := 7;        // black
    adjrails_combo.ItemIndex := 8;     // grey
    tkclines_combo.ItemIndex := 6;     // magenta
    timbout_combo.ItemIndex := 5;      // blue
    sleeperend_combo.ItemIndex := 1;   // red
    timbcent_combo.ItemIndex := 4;     // cyan
    tbnum_combo.ItemIndex := 3;        // green
    gmarks_combo.ItemIndex := 1;       // red
    radmarks_combo.ItemIndex := 3;     // green
    radcentres_combo.ItemIndex := 0;   // none      // otherwise CAD progs scale down to fit.
    joints_combo.ItemIndex := 7;       // black
    solid_bgnd_combo.ItemIndex := 1;   // red
    dot_bgnd_combo.ItemIndex := 1;     // red
    text_combo.ItemIndex := 5;         // blue

    rails_style_combo.ItemIndex := 0;       // CONTINUOUS solid lines.
    adjrails_style_combo.ItemIndex := 0;
    tkclines_style_combo.ItemIndex := 3;    // centre-line style.
    timbout_style_combo.ItemIndex := 0;
    sleeperend_style_combo.ItemIndex := 0;  // reduced ends solid.
    timbcent_style_combo.ItemIndex := 3;    // centre-line style.
    gmarks_style_combo.ItemIndex := 0;
    radmarks_style_combo.ItemIndex := 0;    // radial ends solid.
    radcentres_style_combo.ItemIndex := 0;  // radial centres solid.
    joints_style_combo.ItemIndex := 0;
    solid_bgnd_style_combo.ItemIndex := 0;
    dot_bgnd_style_combo.ItemIndex := 2;    // short dashed style.
  end;//with

  with mint_form do begin
    turnout_combo.ItemIndex := 6;     // B-6 default.
    radius_combo.ItemIndex := 12;     // 10 chains radius.
  end;//with

  keep_canvas_clear;                   // set up keeps box drawing colours.

  xform := 0;                            // zero transform data.
  yform := 0;
  kform := 0;
  xshift := 0;
  yshift := 0;

  label_modx := 0;    // 211b labels not used for control template, but retained for when stored again
  label_mody := 0;    // 211b ditto

  re_org_x := 0;                         //  no re-origination.
  re_org_y := 0;

  out_factor := 1;                       //  output scaling 100 %

  x_distortion_factor := 1;              //  no distortions.
  y_distortion_factor := 1;
  aspect_distortion_factor := 1;

  x_distortion_factor := 1;
  y_distortion_factor := 1;

  x_coning_distortion_factor := 0;
  y_coning_distortion_factor := 0;

  x_skewing_distortion_factor := 0;
  y_skewing_distortion_factor := 0;

  mirror_x := 100;                      // mirror does conversion to 1/100th mm.
  mirror_y := 100;

  distortions := 0;                //  warning flag bits.

  guide_marks := True;             // these flags determine whether the marks are calculated,
  rad_ends := True;
  // and added to the list. pad_guides etc., below determine whether they are subsequently drawn.
  timber_marks := True;
  joint_marks := True;
  //railend_marks:=True;

  //### for i:=0 to markmax_c do mark_i[i].code:=0;    // initial wipe of marks array.

  //pad_timbers:=1;      // outlines only on the pad (control template).  0=none, 1=outlines, 2=centre-lines and numbers, 3=all, including reduced ends.
  //pad_guides:=True;    // guide marks on the pad.

  mouse_labels := True;  // mouse labels on.
  trace_mouse := True;   // trace mouse actions with redraws.

  generate_nearest := False;   // 0.76.a 29-4-02.   flag for "generate nearest turnout" menu item.

  rail_infill_i := 2;             // solid coloured rail infill.

  //current_name_str:='no-name';  // out 208a  // control template reference.

  current_name_str := '';    //  208a  control template reference.

  info_form.ref_name_label.Caption := current_name_str;

  box_project_title_str := 'Midland Central';
  // 214b   // was 'High Road';      // 028d  // was 'Market Street';    // 0.93.a was 'Town Central';     // 0.79.a was 'Tunnel Junction';

  mouse_modify := -1;
  now_pen := 0;
  prior_pen := 0;
  info_show_i := 1;

  toggle_1 := 0;
  toggle_2 := 0;

  scale_bar_i := 0;
  // scalebar colours already set frm control room statup.   0.79.a  was =1
  rail_infill_colour := clRed;           // pad only.

  nodraw := 1000000;     // this value in the list means do not draw this element.

  screengrid_flag := True;               // screen grid on.
  grid_spacex := 150;                    // 0.93.a default grid size = 150 mm  // was 50mm
  grid_spacey := 150;
  grid_labels_code_i := 6;               // labels are in mm.

  printgrid_i := 1;                               // print grid on.
  print_railedge_colour := virtual_black_colour;  // HP driver bug!!!

  snap_proximity_limit := 36;                     // F7 snapping limit.  0.79.a  29-05-06

  timbers_equalized := False;  // 0.93.a startup square-on timbering.

  // 208a mods...

  number_point_screen.x := 0;       // timber numbering position..
  number_point_screen.y := 0;
  tbnumy_screen := 0;               // default ditto when no timber centre-lines.

  number_point_output.x := 0;       // timber numbering position..
  number_point_output.y := 0;
  tbnumy_output := 0;               // default ditto when no timber centre-lines.

  init_switch_data;         // fill switch data in listbox.

  init_plain_track;         // fill plain track data.

  init_turnout(t_T55_i);    // set up for B-6 starting turnout (T-55 gauge).

  // set printer fonts - here because needs scale...

  if running_under_wine = False      // 205a
  then begin
    print_labels_font.Assign(set_font('Times New Roman', 8, [fsBold], clLime));
    printer_text_font.Assign(set_font('Arial', 11, [], clBlack));
    // 205a was Comic sans
    print_timber_numbers_font.Assign(set_font('Arial', Round(scale + 3), [], clBlack));
    shapes_label_font.Assign(set_font('Times New Roman', 18, [fsBold], clBlack));
    // 0.93.a was Comic Sans 12   // (gets changed to shapes colour default later.)
    print_corner_page_numbers_font.Assign(set_font('Arial', 6, [], clBlack));          // 0.93.a
  end
  else begin
    print_labels_font.Assign(set_font('Liberation Serif', 8, [fsBold], clLime));
    printer_text_font.Assign(set_font('Liberation Sans', 11, [], clBlack));
    print_timber_numbers_font.Assign(set_font('Liberation Sans', Round(scale + 3), [], clBlack));
    shapes_label_font.Assign(set_font('Liberation Serif', 18, [fsBold], clBlack));
    // (gets changed to shapes colour default later.)
    print_corner_page_numbers_font.Assign(set_font('Liberation Sans', 6, [], clBlack));
  end;

  //______________


  //______________________________________________________________________________

  rings[0, 0] := 0;    // init spacing ring position.
  rings[0, 1] := 0;


  slew := trtscent;                           // default slew to adjacent track.
  slew_s := 20 * scale;                         // start slew at 20ft scale.
  temp := 500 * scale * ABS(slew) * SQR(Pi) / 2;
  // set default length for 500ft scale slewing rads.
  if temp > minfp then
    slew_l := SQRT(temp)
  else
    slew_l := 600;                // ??? 600 mm otherwise.

  if slew_l < ABS(slew) then
    slew_l := ABS(slew);    // ??? arbitrary minimum. (can't go neg).
  if slew_l < 1 then
    slew_l := 1;                    // 1 mm safety minimum (div by zero).

  clear_shovedata;      // init shoves.

  clear_check_diffs;    // 0.94.a init check rail diffs

  with timbcentre_wait do begin
    pex1.x := 0;
    pex1.y := 0;
    pex2.x := 0;
    pex2.y := 0;
    kq := 0;
    shove_code := 0;
    valid := False;
  end;//with


  park_name_str[0] := 'no-name';        // template names in parking bay.
  park_name_str[1] := 'no-name';
  park_name_str[2] := 'no-name';

  park_memo_str[0] := ' your memo notes for this template ...|';  // 5-08-01.
  park_memo_str[1] := ' your memo notes for this template ...|';  // 5-08-01.
  park_memo_str[2] := ' your memo notes for this template ...|';  // 5-08-01.

  //  now ok to start - flag init done.

  initdone_flag := True;
  quit_code := 3;      // can now only quit via alert query.

end;
//____________________________________________________________________________________________

procedure init_turnout(gauge_index: integer);
// set up starting turnout - ( B-6 turnout reset ).

var
  n: integer;

begin

  plain_track := False;                               //  False = turnouts,   True = plain track
  set_plain_track(False, True);

  xorg := 350;   // 028d  was 0                       // origin to rail-joint (turnouts)    *

  half_diamond := False;                              // 0.77.a 19-8-02  normal switch calcs.

  hand_i := 1;                                        //  default left-hand turnout.
  gauge_i := gauge_index;
  //  default index (= 61 for T-55 gauge 26-1-99).
  gauge_str := gauge[gauge_i].name_str_glist;         //  current gauge name.

  turnoutx := 1250;       // default overall length of turnout mm.
  startx := 0;            // default starting point. (f28000 list entry limit) 1-11-99.
  turnout_i := 1;         // 208d length locked.  was 0 length free.

  turnout_road_i := 0;
  // normal turnout road exit length.

  gauge_dims(True, False, False);       // set up scale, switch-on defaults (ignore return).

  spiral := False;       // no transition.
  reset_trans;         // set transition defaults.

  incx := def_req;       // increment for x mm.

  if set_csi_data(2, 2) = False  // set REA size B (group 2, size 2).
  then
    run_error(82);

  k3n := 6;              // 1:6 crossing             *
  xing_k_i := 7;         // 1:6 crossing list index  *
  xing_type_i := 0;      // straight crossing         *
  wing_tbcount := 3;     // 3 crossing timbers in front of A timber.
  retpar_i := 0;         // no return curve          *
  xing_list_i := 0;      // straight crossing type list index *
  xing_ret_i := 0;       // return curve centres as adjacent track. *

  entry_straight_code := 0;        // sl radio buttons default *
  fixed_sl := def_req;             // init fixed sl dim.

  pt_i := 3;     // 0.93.a default now 60ft rails / 25 sleepers

  pad_form.snap_exit_to_return_curve_menu_entry.Enabled := False;   // no return curve.

  screenx := 1500;     // 208d was 600 (gets fit to template later)    // default screen width mm  *

  // 0.91.c init first entry in rollback view list for pad zoom/pan...

  n := pad_view_list.AddObject('null', Tpad_view.Create);
  // string not used. n should be zero.
  Tpad_view(pad_view_list.Objects[n]).pad_view_data.offset_x := zoom_offsetx;
  Tpad_view(pad_view_list.Objects[n]).pad_view_data.offset_y := zoom_offsety;
  Tpad_view(pad_view_list.Objects[n]).pad_view_data.width_x := screenx;

  pad_view_now.offset_x := zoom_offsetx;
  pad_view_now.offset_y := zoom_offsety;
  pad_view_now.width_x := screenx;

  // 0.91.c and init pre-sets...

  pad_view1.offset_x := zoom_offsetx;
  pad_view1.offset_y := zoom_offsety;
  pad_view1.width_x := screenx;

  pad_view2.offset_x := zoom_offsetx;
  pad_view2.offset_y := zoom_offsety;
  pad_view2.width_x := screenx;

  pad_view3.offset_x := zoom_offsetx;
  pad_view3.offset_y := zoom_offsety;
  pad_view3.width_x := screenx;

  pad_view4.offset_x := zoom_offsetx;
  pad_view4.offset_y := zoom_offsety;
  pad_view4.width_x := screenx;


  bunching_jump := 25 * scale;            // default 25ft scale for paper bunching.
  bunching_shear := 0;


  xform := 0;                            // zero transform data.
  yform := 0;
  kform := 0;
  xshift := 0;
  yshift := 0;

  pad_form.reset_peg_menu_entry.Checked := True;       // radio item.
  peg_code := 0;
  pegx := 0;
  pegy := g / 2;

  peg_arm_length := 3 * scale;            // 3ft default peg arms.

  exittb_i := 2;          // exit is sleepering       *

  calcs_done_and_valid := False;    // no calcs done yet.


  adjacent_edges := True;
  // 0.93.a   False=adjacent tracks,  True=trackbed edges and platform edges.

  // trackbed ...

  //trackbed_width_ins:=180;       // 0.82.d   180 inches full-size 15ft.  out of use 215a

  trackbed_ms_width_ins := 90;     // Single   215a  7ft-6in full-size  half-trackbed width  MS
  trackbed_ts_width_ins := 90;     // Single   215a  7ft-6in full-size  half-trackbed width  TS

  draw_ms_trackbed_edge := False;
  draw_ts_trackbed_edge := False;

  //cess_width_ins:=30;            // 206a ...     out of use 215a

  cess_ms_width_ins := 27;         // Single   215a  2ft-3in full-size cess width MS
  cess_ts_width_ins := 27;

  //draw_trackbed_cess_edge:=False;           out of use 215a

  draw_ms_trackbed_cess_edge := False;       // 215a
  draw_ts_trackbed_cess_edge := False;       // 215a


  // platforms ...

  platform_ms_front_edge_ins := 57;        // 4ft-9in default  215a
  platform_ts_front_edge_ins := 57;

  platform_ms_start_width_ins := 144;      // 12ft default
  platform_ms_end_width_ins := 144;        // 12ft default

  platform_ts_start_width_ins := 144;      // 12ft default
  platform_ts_end_width_ins := 144;        // 12ft default

  platform_ms_start_mm := 0;
  platform_ms_length_mm := def_req;

  platform_ts_start_mm := 0;
  platform_ts_length_mm := def_req;


  platform_ms_start_skew_mm := 0;      // 207a
  platform_ms_end_skew_mm := 0;        // 207a

  platform_ts_start_skew_mm := 0;      // 207a
  platform_ts_end_skew_mm := 0;        // 207a


  draw_ms_platform := False;

  draw_ms_platform_rear_edge := True;
  draw_ms_platform_start_edge := True;
  draw_ms_platform_end_edge := True;

  draw_ts_platform := False;

  draw_ts_platform_rear_edge := True;
  draw_ts_platform_start_edge := True;
  draw_ts_platform_end_edge := True;


  gauge_faces := True;                               // gauge-faces wanted
  outer_edges := True;                               // and outer-edges
  midline := False;                                  // but not rail-centrelines.

  railedges(gauge_faces, outer_edges, centre_lines); // set up these flags.

  //oddouter_i:=0;       // odd rail-width ////// not yet done 10-4-96 //////

  reset_defaults;     // do resettable defaults ( on def_req input )

end;
//______________________________________________________________________________

function inc_switch: boolean;   // increase the switch size (within available range).

begin
  Result := False;

  if csi.size_code < csi.group_count then begin
    if set_csi_data(csi.group_code, csi.size_code + 1) = False
    // get new switch data from listbox entries.
    then
      run_error(83);
    Result := True;
  end;
end;
//________________________________________________________________________________________

function calc_switch(sw_info: Tswitch_info; h_diamond, current_calc: boolean): integer;
  // calculate switch - return error code,

var
  alpha, beta: double;
  temp: double;
  h_inches, lh_inches, sw_front_inches: double;

begin      // calculate the switch data.

  // sw_info.pattern is type of switch.  0 = curved planing or straight switch; -1 = semi-curved switch;  1 = double-curved switch.

  fbtip := sw_info.fb_tip_offset;  // FB foot from gauge-face at tip.

  if h_diamond = True        // override - ignore sw_info and calc this switch as a half-diamond.
  // switch not used - diagonal rails are all on turnout radius.

  then begin
    joggled := False;
    joggle_long := 0;
    joggle_deep := 0;

    hdk := ARCTAN(1 / hdkn);       // K-crossing angle

    h_inches := 0;               // arbitrary heel location at intesect.
    lh_inches := 0;              // lead to "heel" at intersect.
    swrad := max_rad + g / 2;        // straight switch.
    switch_type := 0;                               // ditto.
    sw_front_inches := g * TAN(hdk / 2) / 2 / inscale;
    // front to tips. = Ctrl-0 = Ctrl-1 = Ctrl-2.

    if (startx = 0) and (mouse_modify <> 42)     // not if blanking mouse action.
    then
      startx := 0 - 18 * inscale;
    // some negative blanking needed to get both tips, 18" arbitrary.


    current_switch_name := 'half-diamond K- ' + FormatFloat('#.##', hdkn);

    k1 := hdk;
    k2 := hdk;

    case auto_diamond of
      0:
        fixed_diamond := (hdkn < 8.125);  // use switch-diamond if angle is 1:8.125 or flatter.
      1:
        fixed_diamond := True;
      2:
        fixed_diamond := False;
    end;//case

  end
  else begin               // turnout...

    if gaunt = True     // 0.81
    then begin
      joggled := False;
      joggle_long := 0;
      joggle_deep := 0;

      h_inches := gaunt_offset_in;
      lh_inches := 0;

      swrad := max_rad;

      switch_type := 0;
      sw_front_inches := 0;
      current_switch_name := 'gaunt';
    end
    else begin     // normal turnout...

      joggled := sw_info.joggled_stock_rail;
      joggle_long := sw_info.joggle_length * inscale;
      if overscale_joggles = True then
        joggle_deep := inscale * 3 / 4            // 3/4" joggle
      else
        joggle_deep := sw_info.joggle_depth * inscale;

      h_inches := sw_info.heel_offset_inches;
      lh_inches := sw_info.heel_lead_inches;

      if sw_info.switch_radius_inchormax > max_rad_test      // straight switch
      then
        swrad := max_rad + g / 2
      else
        swrad := sw_info.switch_radius_inchormax * inscale;    // switch radius.

      switch_type := sw_info.sw_pattern;
      sw_front_inches := sw_info.switch_front_inches;
      current_switch_name := sw_info.sw_name_str;
    end;
  end;

  if current_calc = True   // may need to update rail edges...
  then begin
    // defaults for turnout...

    aqyn[eRD_KCrossingCheckMainSideGaugeFace] := False;
    // h-d MS check rail. (MS check is in diagonal road.)
    aqyn[eRD_KCrossingCheckMainSideOuterEdge] := False;

    aqyn[eRD_KCrossingCheckTurnoutSideGaugeFace] := False;
    // h-d DS check rail. (DS check is in main road.)
    aqyn[eRD_KCrossingCheckTurnoutSideOuterEdge] := False;

    if (h_diamond = True) and (fixed_diamond = True) and pad_form.check_rails_menu_entry.Checked =
      True   // generator switch.
    then begin
      if k_main_side_check_rail_flag = True
      // 0.93.a      was turnout_road_check_rail_flag=True
      then begin
        aqyn[eRD_KCrossingCheckMainSideGaugeFace] := gauge_faces;
        // h-d MS check rail. (MS check is in diagonal road.)
        aqyn[eRD_KCrossingCheckMainSideOuterEdge] :=
          (full_draw or (mouse_modify <= 0)) and outer_edges;
      end;

      if k_diagonal_side_check_rail_flag = True
      // 0.93.a      was main_road_check_rail_flag=True
      then begin
        aqyn[eRD_KCrossingCheckTurnoutSideGaugeFace] := gauge_faces;
        // h-d DS check rail. (DS check is in main road.)
        aqyn[eRD_KCrossingCheckTurnoutSideOuterEdge] :=
          (full_draw or (mouse_modify <= 0)) and outer_edges;
      end;
    end;
  end;

  lh := lh_inches * inscale;      // lead, toe to heel (incl. planing).

  if gaunt = True      // gaunt template 0.81.a
  then begin
    p := 0;
    pl := 0;          // no planing.
    h := h_inches * inscale;  // gaunt offset.

    alpha := 0;  // no swing on the switch curve.
    beta := 0;   // no heel angle.
    k1 := 0;     // planing angle.
    k2 := 0;     // heel angle.

    k1n := maxfp;         // RAM unit planing angle.
    k2n := maxfp;         // RAM unit heel angle.

    k1sinsw := 0;
    k2sinsw := 0;
    k1cossw := maxfp;
    k2cossw := maxfp;
    scl := 0;             // switch curve length.
  end
  else begin

    if ((lh < minfp) and (h_diamond = False)) or (swrad < minfp) then begin
      Result := 95;
      EXIT;
    end; // can't use zero or negative values.

    if switch_type = 0         // curved planing or straight switch...
    then begin
      p := 0;
      pl := 0;
      // the switch curve starts at the toe - a straight switch is treated as a curved switch of infinite radius.
      h := h_inches * inscale;  // heel offset.

      if (h < minfp) and (h_diamond = False) then begin
        Result := 96;
        EXIT;
      end;  // can't use zero or negative values.

      if h_diamond = False then
        beta := ARCTAN(h / lh)  // (radians) average of planing angle and heel angle, k1 and k2.
      else
        beta := hdk;

      if swrad >= max_rad_test       // straight switch...
      then begin

        alpha := 0;     // no swing on the switch curve.
        k1 := beta;     // planing angle.
        k2 := beta;     // heel angle.
      end
      else begin                                 // curved planing...
        temp := SQRT(SQR(lh) + SQR(h)) / 2 / swrad;
        if ABS(temp) > 1 then begin
          Result := 97;
          EXIT;
        end;  // radius too small to fit - will give ARCSIN error.

        alpha := ARCSIN(temp);
        // swing (radians) on the switch curve.
        k1 := beta - alpha;                    // planing angle at tip.
        k2 := beta + alpha;                    // heel angle.
      end;

      if (k1 < minfp) or (k2 < minfp) then begin
        Result := 98;
        EXIT;
      end;  // most likely k1 is negative - radius too small or lead too long.

      k1n := 1 / TAN(k1);
      // RAM unit planing angle (at tip if curved).
      k2n := 1 / TAN(k2);                    // RAM unit heel angle.

      k1sinsw := swrad * SIN(k1);
      k2sinsw := swrad * SIN(k2);
      k1cossw := swrad * COS(k1);
      k2cossw := swrad * COS(k2);
      scl := k2sinsw - k1sinsw;                 // switch curve length.
    end
    else begin                   // semi-curved switch...

      k1n := sw_info.planing_angle;                       // RAM unit planing angle.
      if k1n < minfp then begin
        Result := 99;
        EXIT;
      end;    // can't have zero or negative angle.

      k1 := ARCTAN(1 / k1n);                    // radians.

      if k1 < minfp then begin
        Result := 100;
        EXIT;
      end;       // can't have zero or negative angle.

      p := sw_info.planing * inscale;
      // length of planing (along gauge-face of switch rail).
      pl := p * cos(k1);               // ditto length along stock rail to k1 point.

      if (p < 0) or (pl < 0) then begin
        Result := 101;
        EXIT;
      end;  // can't have negative planing length.

      temp := (lh - pl) / swrad + SIN(k1);
      if ABS(temp) > 1 then begin
        Result := 102;
        EXIT;
      end;  // radius too small to fit - will give ARCSIN error.
      k2 := ARCSIN(temp);
      if k2 < minfp then begin
        Result := 103;
        EXIT;
      end;     // can't have zero or negative heel angle.

      k2n := 1 / TAN(k2);                     // RAM unit heel angle.

      k1sinsw := swrad * SIN(k1);
      k2sinsw := swrad * SIN(k2);
      k1cossw := swrad * COS(k1);
      k2cossw := swrad * COS(k2);
      scl := k2sinsw - k1sinsw;               // switch curve length.

      h := pl / k1n + k1cossw - k2cossw;          // heel offset.
    end;
  end;

  toel := sw_front_inches * inscale;      // rail-joint to toe dimension.
  toex := toel + xorg;                    // x to toe (main-side).
  toeoxhd := toex + j * TAN(k1 / 2);
  // x to toe (main-side) outer (for half-diamond rail ends).

  plx := toex + pl;
  // x to start of switch curve (pl=0 for straight switch or curved planing).
  ph := p * SIN(k1);                      // gauge-face offset at plx (0 ditto).
  heelx := toex + lh;                     // x to heel.

  sworgx := heelx - k2sinsw;              // x to switch curve centre.
  sworgy := h + k2cossw;                  // y to ditto.

  // now can calculate some x dims...

  if switch_type = 0 then begin         // straight switch or curved planing...

    if gaunt = True then begin
      setx := toex;
      setox := toex;
      plx3 := toex;
      plox11 := toex;
      fbsetx := toex;
      fbsetox := toex;
    end
    else begin
      temp := SQR(swrad - g) - SQR(sworgy - g);
      if temp < 0 then begin
        Result := 104;
        EXIT;
      end;  // switch rad doesn't cut the straight (gauge-face of curved stock rail).
      setx := sworgx + SQRT(temp);

      // x to "set" in curved stock rail (gauge-face - intercept with switch curve).

      temp := SQR(swrad - g - j) - SQR(sworgy - g - j);
      if temp < 0 then begin
        Result := 105;
        EXIT;
      end;  // switch rad doesn't cut the straight (outer-edge of curved stock rail).
      setox := sworgx + SQRT(temp);
      // x to "set", outer-edge ditto.

      plx3 := setx;
      // no "planing length", switch curve starts at the "set", curved stock rail gauge-face, aq=3.
      plox11 := setox;     // ditto, outer-edge, aq=11.

      if rail_section = 2       // head+foot (FB section) ... 0.76.a 2-01-02
      then begin
        temp := SQR(swrad - g + ifb) - SQR(sworgy - g + ifb);
        if temp < 0 then begin
          Result := 134;
          EXIT;
        end;  // switch rad doesn't cut the straight (FB foot of curved stock rail).
        fbsetx := sworgx + SQRT(temp);
        // x to "set" in curved stock rail (FB foot inner - intercept with switch curve).

        temp := SQR(swrad - g - ofb) - SQR(sworgy - g - ofb);
        if temp < 0 then begin
          Result := 135;
          EXIT;
        end;  // switch rad doesn't cut the straight (FB foot of curved stock rail).
        fbsetox := sworgx + SQRT(temp);
        // x to "set", FB foot outer.
      end
      else begin             // head only (BH or no rails) - not used...
        fbsetx := setx;
        fbsetox := setox;
      end;
    end;
  end

  else begin         // REA semi-curved flexible switch, straight planing...

    setx := toex - g * TAN(k1 / 2);             // x to "set" in curved stock rail.
    setox := setx - j * TAN(k1 / 2);            // x to ditto, outer-edge.

    plx3 := plx - g * SIN(k1);
    // x to start of curve, curved stock rail gauge-face.
    plox11 := plx3 - j * SIN(k1);             // x to ditto, outer-edge.

    if rail_section = 2    // head+foot (FB section)... 0.76.a 2-01-02  (unfinished)
    then begin
      fbsetx := setx + ifb * SIN(k1 / 2);
      // x to "set" in curved stock rail (FB foot inner).
      fbsetox := setx - ofb * SIN(k1 / 2);  // x to "set" FB foot outer.
    end
    else begin             // head only (BH or no rails) - or gaunt...
      fbsetx := setx;
      fbsetox := setox;
    end;
  end;


  if gaunt = True then begin
    toemidx := toex;     // toe mark on track centre-line.
    plox := toex;
    kpl := 0;
    stox := toex;
    heelox := toex;
    fbtoex := toex;
    fbplx := toex;
    fbplox := toex;
    fbstox := toex;
    fbplx3 := toex;
    fbplox11 := toex;
    fbheelox := toex;
    fbheelx := toex;
  end
  else begin
    toemidx := (toex + setx) / 2;     // toe mark on track centre-line.

    if (rail_section = 2) and (fb_kludge = 1)
    // 0.94.a kludging inner FB foot as negative outer
    then begin
      // kludge approximations...

      if switch_type = 0    // straight or curved no plx available
      then begin
        temp := SQR(swrad + railtop) - SQR(sworgy);
        if temp < 0 then begin
          Result := 106;
          EXIT;
        end;   // switch rad doesn't cut the straight (gauge-face of straight stock rail).
        plox := sworgx + SQRT(temp);
        // x to planing intercept (outer-edge of curved turnout rail).

        if ABS(temp) < (ABS(swrad + railtop) - minfp) then
          kpl := ARCSIN(temp / (swrad + railtop))  // angle at end of planing (for FB).
        else
          kpl := k1;                           // ??
      end
      else begin
        plox := plx;    // semi-curved
        kpl := k1;
      end;

      stox := plox - g * SIN(kpl);
    end
    else begin     // 0.94.a

      temp := SQR(swrad + j) - SQR(sworgy);
      if temp < 0 then begin
        Result := 106;
        EXIT;
      end;   // switch rad doesn't cut the straight (gauge-face of straight stock rail).
      plox := sworgx + SQRT(temp);
      // x to planing intercept (outer-edge of curved turnout rail).

      if ABS(temp) < (ABS(swrad + j) - minfp) then
        kpl := ARCSIN(temp / (swrad + j))  // angle at end of planing (for FB).
      else
        kpl := k1;                     // ??

      temp := SQR(swrad - g) - SQR(sworgy - g - j);
      if temp < 0 then begin
        Result := 107;
        EXIT;
      end;   // switch rad doesn't cut the straight (outer edge of straight turnout rail).
      stox := sworgx + SQRT(temp);
      // x to straight turnout rail, outer-edge, end of planing (intercept with switch curve in stock rail).

    end; // 0.94.a

    heelox := heelx + j * SIN(k2);                       // x to heel, outer rail-edge.


    if rail_section = 2       // head+foot (FB section)... 0.76.a 2-01-02   (unfinished)
    then begin
      fbtoex := toex - fbtip * SIN(k1);

      fbplx := plox - (j + ifb) * SIN(kpl);

      temp := SQR(swrad + ofb) - SQR(sworgy - ifb);
      if temp < 0 then begin
        Result := 136;
        EXIT;
      end;   // FB inner foot of straight stock rail.
      fbplox := sworgx + SQRT(temp);

      temp := SQR(swrad - g + ifb) - SQR(sworgy - g - ofb);
      if temp < 0 then begin
        Result := 137;
        EXIT;
      end;   // FB inner foot of curved stock rail.
      fbstox := sworgx + SQRT(temp);

      fbplx3 := plx3 + ifb * SIN(k1);
      fbplox11 := plx3 - ofb * SIN(k1);

      fbheelox := heelx + ofb * SIN(k2);
      fbheelx := heelx - ifb * SIN(k2);
    end
    else begin            // head only (BH or no rails)...  (unfinished)
      fbtoex := toex;
      fbplx := plx;
      fbplox := plox;
      fbstox := stox;
      fbplx3 := plx3;
      fbplox11 := plox11;
      fbheelox := heelox;
      fbheelx := heelx;
    end;
  end;

  Result := 0;                  // switch calculated OK.
end;
//______________________________________________________________________________

function rails_sleepers(len: double; var num_rails, num_sl_over: integer;
  var percent_over: double): boolean;

  // return number of full current rail lengths and extra sleepers over in length len.
  // assumes starting from a rail joint.
var
  len_rail, len_over: double;

begin
  Result := False;       // init defaults...
  num_rails := 0;
  num_sl_over := 0;
  percent_over := 0;

  if (railen[pt_i] < minfp) or (len < minfp) then
    EXIT;

  len_rail := railen[pt_i] * inscale;

  num_rails := Trunc(len / len_rail);

  len_over := len - num_rails * len_rail;

  percent_over := len_over * 100 / len_rail;

  while (psleep[pt_i, num_sl_over] > 0) and
    (len_over > (psleep[pt_i, num_sl_over] * inscale - minfp)) do begin
    // >(-minfp) instead of  >= to avoid rounding errors.
    len_over := len_over - psleep[pt_i, num_sl_over] * inscale;
    Inc(num_sl_over);
  end;

  Result := True;
end;
//___________________________________________________________________________________________

function calcturnout: boolean;     // calc all the turnout dimensions.

const
  help_str = 'The "turnout radius" refers to the section between the end of the switch and the crossing.'
    + ' Normally, turnouts have a switch radius greater than or equal to the turnout radius to ease the running into the turnout.'
    + '||It is better to use a longer switch to achieve this, if possible.' +
    '||You may have to click USE LONGER SWITCH more than once to find a switch which fits.';
var
  i: integer;
  heel_to_xing: double;  // 0.93.a
  flend_out: double;

begin

  Result := False;   //  in case of error exit.

  try
    // mod 0.76.a 1-1-02 ...

    if vertical_rails = True then begin
      if midline = True then
        j := railtop / 2   // for rail centre-lines wanted.
      else
        j := railtop;    // or use rail-width for outer edges.

      ofb := (railtop + railbottom) / 2;
      // offset from gauge line to outer FB foot (at base of section).
      ifb := railbottom - ofb;           // ditto to inner FB foot (at base of section).
    end
    else begin        // inclined rails...

      if midline = True then
        j := railtop * COS(rail_inclination) / 2   // for rail centre-lines wanted.
      else
        j := railtop * COS(rail_inclination);    // or use rail-width for outer edges.

      ofb := (railtop + railbottom) * COS(rail_inclination) / 2 + rail_height *
        inscale * SIN(rail_inclination);
      // offset from gauge line to outer FB foot (at base of section).
      ifb := railbottom * COS(rail_inclination) - ofb;
      // ditto to inner FB foot (at base of section).
    end;

    case fb_kludge of      // 0.94.a kludged foot-lines wanted

      // 0: normal, not wanted

      1:
        j := 0 - ifb;     // override j
      2:
        j := ofb;

    end;//case


    if k3n < minfp then
      i := 103                 // can't use zero or negative crossing angle.
    else begin
      k3 := ARCTAN(1 / k3n);                     // crossing angle in radians.
      i := calc_switch(csi, half_diamond, True);
      // calculate all switch data (might be a custom switch, or half-diamond).
    end;

    if (i <> 0) or (swrad < 0) then begin
      abandon_calcs := True;
      //draw_mode:=2;             // prevent messages recurring.
      Result := False;
      EXIT;                     // abandon ship.
    end;

    if gaunt = True then
      equiv_rad := max_rad       // no switch deflection
    else begin
      if swrad >= max_rad_test then
        equiv_rad := SQR(k1n) * 0.6 * scale  // r = planing angle^2 * constant - empirical value.
      else
        equiv_rad := swrad;
    end;

    // must calc switch first to get k2...

    tradius_is_straight := (ABS(k2 - k3) < minfp);
    // ^^^ straight turnout radius if switch and crossing angles equal.
    if tradius_is_straight = True then
      xing_calc_i := 0              // calc as if a regular crossing.
    else
      xing_calc_i := xing_type_i;

    if xing_calc_i <> 0                      // ^^^ curved or generic crossing.
    then
      sl := 0                          // no entry sl.
    else begin                          // regular crossing or ^^^ straight turnout radius.
      case entry_straight_code of
        -1, 0:
          sl := fw * 2 * k3n;
        // short or init auto-fit, minimum sl to ensure knuckle is on the straight.
        1:
          sl := fixed_sl; // he's fixed it.
      end;//case
    end;

    th := g - sl / k3n;      // offset at end of turnout curve.

    temp := (COS(k2) - COS(k3));
    // switch and crossing angles equal, turnout radius is straight.
    if (ABS(temp) < minfp) or (tradius_is_straight = True) then
      tradius := max_rad + g / 2                          // this value not actually used.
    else begin
      // mods 0.93.a ...

      if xing_calc_i = 0  // regular
      then begin

        heel_to_xing := (th - h) * (SIN(k3) - SIN(k2)) / temp;
        // inter-lead length, heel to curve end (curve end at angle=k3).

        if (gaunt = True) and (heel_to_xing < (6 * scale))
        // 217b 6ft minimum length gaunt curve         was 10ft
        then begin
          h := th - (6 * scale) * temp / (SIN(k3) - SIN(k2));
          // modify offset according
          gaunt_offset_in := h / inscale;
        end;

      end
      else
      if (gaunt = True) and (gaunt_offset_in > ((g - fw - minfp) / inscale)) then begin
        gaunt_offset_in := (g - fw - minfp) / inscale;
        // curviform and generic          offset cannot exceed gauge-flangeway   217a
        h := g - fw - minfp;
        // modify offset according
      end;

      tradius := (th - h) / temp;     // turnout radius, gauge-face

    end;

    if (half_diamond = False) and (tradius > minfp) and (tradius > (equiv_rad + minfp)) and
      (entry_straight_code = 0) and (xing_calc_i = 0) and (tradius_is_straight = False)

    // turnout rad is positive non-straight and exceeds switch rad.
    // this is or is being calced as a regular crossing.
    // auto-fit entry straight is in force and this is not a half-diamond

    // so reduce turnout rad and auto-fit a longer straight (sl).

    then begin
      tradius := equiv_rad;               // reduce turnout radius to limit,
      th := h + tradius * (COS(k2) - COS(k3));  // and recalc th and sl.
      sl := (g - th) * k3n;
      if sl < (fw * 2 * k3n) then begin
        abandon_calcs := True;
        //draw_mode:=2;        // prevent messages recurring.
        Result := False;
        EXIT;                // abandon ship.
      end;
    end;


    if tradius_is_straight = False then begin
      //k2sint:=tradius*SIN(k2);       //^^^ turnout curve centres :
      //k3sint:=tradius*SIN(k3);

      //k2cost:=tradius*COS(k2);
      //k3cost:=tradius*COS(k3);

      csradius := tradius - g;     // radius in curved stock rail, gauge-face.

      tl := tradius * (SIN(k3) - SIN(k2));
      // inter-lead length, heel to curve end (curve end at angle=k3).

      torgx := heelx - tradius * SIN(k2);      // x to turnout curve centre.
      torgy := h + tradius * COS(k2);          // y to ditto.
    end
    else begin
      csradius := 0;     // ^^^ invalid rad.
      tl := (th - h) * k3n;
      //^^^ inter-lead length, heel to curve end (curve end at angle=k3).
      torgx := 0;        //^^^ invalid values..
      torgy := 0;
    end;

    // calc check-rail flare stuff...

    flen_mw := xing_flare_len + ccd.end_diff_mw.flr_diff * inscale;    // MS working end mm
    flend_out := fw_end - fw + ccd.end_diff_mw.gap_diff;
    if flend_out < 0 then
      flend_out := 0;                 // end gap can't be less than fw

    if (flen_mw < minfp) or (flen_mw < flend_out)         // no negs or division by zero
    then begin
      flen_mw := 0;
      k5_mw := 0;
    end
    else
      k5_mw := ARCSIN(flend_out / flen_mw);   // mw flaring angle.
    jbend_mw := j / COS(k5_mw / 2);                   // j width across flare bends.


    flen_me := xing_flare_len + ccd.end_diff_me.flr_diff * inscale;    // MS extension end
    flend_out := fw_end - fw + ccd.end_diff_me.gap_diff;
    if flend_out < 0 then
      flend_out := 0;

    if (flen_me < minfp) or (flen_me < flend_out) then begin
      flen_me := 0;
      k5_me := 0;
    end
    else
      k5_me := ARCSIN(flend_out / flen_me);   // me flaring angle.
    jbend_me := j / COS(k5_me / 2);                   // j width across flare bends.


    flen_mr := xing_flare_len + ccd.end_diff_mr.flr_diff * inscale;    // MS wing reach end
    flend_out := fw_end - fw + ccd.end_diff_mr.gap_diff;
    if flend_out < 0 then
      flend_out := 0;

    if (flen_mr < minfp) or (flen_mr < flend_out) then begin
      flen_mr := 0;
      k5_mr := 0;
    end
    else
      k5_mr := ARCSIN(flend_out / flen_mr);   // mr flaring angle.
    jbend_mr := j / COS(k5_mr / 2);                   // j width across flare bends.


    flen_tw := xing_flare_len + ccd.end_diff_tw.flr_diff * inscale;    // TS working end
    flend_out := fw_end - fw + ccd.end_diff_tw.gap_diff;
    if flend_out < 0 then
      flend_out := 0;

    if (flen_tw < minfp) or (flen_tw < flend_out) then begin
      flen_tw := 0;
      k5_tw := 0;
    end
    else
      k5_tw := ARCSIN(flend_out / flen_tw);   // tw flaring angle.
    jbend_tw := j / COS(k5_tw / 2);                   // j width across flare bends.


    flen_te := xing_flare_len + ccd.end_diff_te.flr_diff * inscale;    // TS extension end
    flend_out := fw_end - fw + ccd.end_diff_te.gap_diff;
    if flend_out < 0 then
      flend_out := 0;

    if (flen_te < minfp) or (flen_te < flend_out) then begin
      flen_te := 0;
      k5_te := 0;
    end
    else
      k5_te := ARCSIN(flend_out / flen_te);   // te flaring angle.
    jbend_te := j / COS(k5_te / 2);                   // j width across flare bends.


    flen_tr := xing_flare_len + ccd.end_diff_tr.flr_diff * inscale;    // TS wing reach end
    flend_out := fw_end - fw + ccd.end_diff_tr.gap_diff;
    if flend_out < 0 then
      flend_out := 0;

    if (flen_tr < minfp) or (flen_tr < flend_out) then begin
      flen_tr := 0;
      k5_tr := 0;
    end
    else
      k5_tr := ARCSIN(flend_out / flen_tr);   // tr flaring angle.
    jbend_tr := j / COS(k5_tr / 2);                   // j width across flare bends.


    if (half_diamond = True) and (fixed_diamond = True) then begin
      flen_mk := (k_flare_len + ccd.end_diff_mk.flr_diff) * inscale;    // MS k check rail end
      flend_out := fw_end - fw + ccd.end_diff_mk.gap_diff;
      if flend_out < 0 then
        flend_out := 0;

      if (flen_mk < minfp) or (flen_mk < flend_out) then begin
        flen_mk := 0;
        k5_mk := 0;
      end
      else
        k5_mk := ARCSIN(flend_out / flen_mk);   // mk flaring angle.
      jbend_mk := j / COS(k5_mk / 2);                   // j width across flare bends.

      flen_mk_oe := flen_mk - j * TAN(k5_mk / 2);   // outer-edge flare length


      flen_dk := (k_flare_len + ccd.end_diff_dk.flr_diff) * inscale;    // DS k check rail end
      flend_out := fw_end - fw + ccd.end_diff_dk.gap_diff;
      if flend_out < 0 then
        flend_out := 0;

      if (flen_dk < minfp) or (flen_dk < flend_out) then begin
        flen_dk := 0;
        k5_dk := 0;
      end
      else
        k5_dk := ARCSIN(flend_out / flen_dk);   // dk flaring angle.
      jbend_dk := j / COS(k5_dk / 2);                   // j width across flare bends.

      flen_dk_oe := flen_dk - j * TAN(k5_dk / 2);   // outer-edge flare length
    end;


    check_ms_wklen := ck_working3;            // start with size 3 MS working length check rail.

    if k3n < 12.01                            // size 2 if 1:12  to 1:6 inclusive.
    then
      check_ms_wklen := ck_working2;    // set size 2 MS check rail.

    if (k3n <= 5.99) or ((half_diamond = True) and (k3n <= 7.99) and (hd_vcheck_rails > 1))
    // less than 1:6, or shorten half-diamond MS check(=2) or both checks(=3) for slip switch (if less than 1:8).
    then
      check_ms_wklen := ck_working1;    // set size 1 ms check rail.

    check_ms_wklen := check_ms_wklen + ccd.end_diff_mw.len_diff;  // 0.94.a add mouse diff
    if check_ms_wklen < 0 then
      check_ms_wklen := 0;

    check_ts_wklen := ck_working3;            // start with size 3 TS working length check rail.

    if k3n < 12.01                            // size 2 if 1:12  to 1:6 inclusive.
    then
      check_ts_wklen := ck_working2;    // set size 2 TS check rail.

    if (k3n <= 5.99) or ((half_diamond = True) and (k3n <= 7.99) and
      ((hd_vcheck_rails = 1) or (hd_vcheck_rails = 3)))
    // less than 1:6, or shorten half-diamond TS check(=2) or both checks(=3) for slip switch (if less than 1:8).
    then
      check_ts_wklen := ck_working1;    // set size 1 TS check rail.

    check_ts_wklen := check_ts_wklen + ccd.end_diff_tw.len_diff;  // 0.94.a add mouse diff
    if check_ts_wklen < 0 then
      check_ts_wklen := 0;


    // wing rail reach length...

    wgl_ms_len := wing_reach2;           // start with size 2 MS wing rail.
    check_ms_extlen := ck_ext2;          // and size 2 MS check extension.

    wgl_ts_len := wing_reach2;           // start with size 2 TS wing rail.
    check_ts_extlen := ck_ext2;          // and size 2 TS check extension.

    if k3n < 10.01           // size 1 up to 1:10 inclusive.
    then begin
      wgl_ms_len := wing_reach1;        // no, size 1 MS wing rail wanted.
      check_ms_extlen := ck_ext1;       // and size 1 MS check extension.

      wgl_ts_len := wing_reach1;        // no, size 1 TS wing rail wanted.
      check_ts_extlen := ck_ext1;       // and size 1 TS check extension.
    end;

    wgl_ms_len := wgl_ms_len + ccd.end_diff_mr.len_diff;  // 0.94.a add mouse diff
    if wgl_ms_len < 0 then
      wgl_ms_len := 0;

    check_ms_extlen := check_ms_extlen + ccd.end_diff_me.len_diff;  // 0.94.a add mouse diff
    if check_ms_extlen < 0 then
      check_ms_extlen := 0;


    wgl_ts_len := wgl_ts_len + ccd.end_diff_tr.len_diff;  // 0.94.a add mouse diff
    if wgl_ts_len < 0 then
      wgl_ts_len := 0;

    check_ts_extlen := check_ts_extlen + ccd.end_diff_te.len_diff;  // 0.94.a add mouse diff
    if check_ts_extlen < 0 then
      check_ts_extlen := 0;

    ckl_ms := (check_ms_wklen + check_ms_extlen) * inscale;
    // mm length for main-side check rail (including extension).
    ckl_ts := (check_ts_wklen + check_ts_extlen) * inscale;
    // mm length for main-side check rail (including extension).

    wgl_ms := wgl_ms_len * inscale;     // mm length for wing rails
    wgl_ts := wgl_ts_len * inscale;

    // generic use of FB-109 dims for vee rail lengths at different crossing angles...


    // generic use of FB-109 dims for vee rail lengths at different crossing angles...

    //veelong:=17*inscale;       // 4" + 13" to joint. veelong from blunt nose.

    // mod 0.75.a 10-10-01..

    veelong := (bn_to_a + mvj_sp) * inscale;
    // init  -  4"(BH default) + 12.5"(BH default) to joint. veelong from blunt nose.

    repeat
      // (mod 0.75.a  11-10-01)...
      // these mods mean that for crossings 1:4 to 1:5 inclusive, and 1:7 to 1:7.5 inclusive,
      // default templates are now 1 timber space longer to the mvjp and tvjp positions (CTRL-8 and CTRL-6).
      // and hence also to the CTRL-9 end position.
      // mod done to comply better with prototype info, FB in particular.

      if k3n < 3.875 then begin
        veelong := veelong + (vee_spco1 - 1) * veetimb_sp * inscale;
        wing_tbcount := wing_spco1;
        BREAK;
      end;   // funnies. (mod 0.75.a  11-10-01)
      if k3n < 6.875 then begin
        veelong := veelong + (vee_spco2 - 1) * veetimb_sp * inscale;
        wing_tbcount := wing_spco2;
        BREAK;
      end;
      if k3n < 10.125 then begin
        veelong := veelong + (vee_spco3 - 1) * veetimb_sp * inscale;
        wing_tbcount := wing_spco3;
        BREAK;
      end;
      if k3n < 15.125 then begin
        veelong := veelong + (vee_spco4 - 1) * veetimb_sp * inscale;
        wing_tbcount := wing_spco4;
        BREAK;
      end;
      if k3n < 20.125 then begin
        veelong := veelong + (vee_spco5 - 1) * veetimb_sp * inscale;
        wing_tbcount := wing_spco5;
        BREAK;
      end;

      // for longer crossings, assume straight crossing, and ensure 12" separation between point and splice rails at joint...

      wing_tbcount := wing_spco6;

      veelong := veelong + (vee_spco6 - 1) * veetimb_sp * inscale;   // re-init

      // blunt nose width + offset along point rail < 1ft...

      while ((bn_wide * inscale) + (veelong / k3n)) < scale do
        veelong := veelong + veetimb_sp * inscale;
      BREAK;
    until 0 <> 0;

    Result := xdims;         // go calc remaining x dims for all rails. returns True if calcs ok.
    // and fill the termination list for curved rails.
  except
    Result := False;
  end;//try
end;
//______________________________________________________________________________

function get_current_diffed_dims: string;

var
  num_str: string;

begin
  num_str := ''; //init

  case current_diff_code of

    eMC_501_MSWorkingEnd: begin                     //MS1 MS working len
      current_diffed_len := check_ms_wklen * inscale;
      current_diffed_fl_len := flen_mw;
      current_diffed_end_gap := fw_end + ccd.end_diff_mw.gap_diff;
      num_str := 'MS1';
    end;

    eMC_502_MSExtensionEnd: begin                     //MS2 MS ext len
      current_diffed_len := check_ms_extlen * inscale;
      ;
      current_diffed_fl_len := flen_me;
      current_diffed_end_gap := fw_end + ccd.end_diff_me.gap_diff;
      num_str := 'MS2';
    end;

    eMC_503_MSWingRail: begin                     //MS3 MS wing reach
      current_diffed_len := wgl_ms_len * inscale;
      ;
      current_diffed_fl_len := flen_mr;
      current_diffed_end_gap := fw_end + ccd.end_diff_mr.gap_diff;
      num_str := 'MS3';
    end;

    eMC_504_TSWorkingEnd: begin                     //TS1 TS working len
      current_diffed_len := check_ts_wklen * inscale;
      ;
      current_diffed_fl_len := flen_tw;
      current_diffed_end_gap := fw_end + ccd.end_diff_tw.gap_diff;
      if half_diamond = True then
        num_str := 'DS1'
      else
        num_str := 'TS1';
    end;

    eMC_505_TSExtensionEnd: begin                     //TS2 TS ext len
      current_diffed_len := check_ts_extlen * inscale;
      ;
      current_diffed_fl_len := flen_te;
      current_diffed_end_gap := fw_end + ccd.end_diff_te.gap_diff;
      if half_diamond = True then
        num_str := 'DS2'
      else
        num_str := 'TS2';
    end;

    eMC_506_TSWingRail: begin                     //TS3 TS wing reach
      current_diffed_len := wgl_ts_len * inscale;
      ;
      current_diffed_fl_len := flen_tr;
      current_diffed_end_gap := fw_end + ccd.end_diff_tr.gap_diff;
      if half_diamond = True then
        num_str := 'DS3'
      else
        num_str := 'TS3';
    end;

    eMC_507_MSKCheckRail: begin                     //MS4 MS K check len
      current_diffed_len := kckl_mk;
      current_diffed_fl_len := flen_mk;
      current_diffed_end_gap := fw_end + ccd.end_diff_mk.gap_diff;
      if half_diamond = True then
        num_str := 'MS4';
    end;

    eMC_508_DSWingRail: begin                     //DS4 DS K check len
      current_diffed_len := kckl_dk;
      current_diffed_fl_len := flen_dk;
      current_diffed_end_gap := fw_end + ccd.end_diff_dk.gap_diff;
      if half_diamond = True then
        num_str := 'DS4';
    end;

  end;//case

  Result := num_str;
end;
//______________________________________________________________________________

procedure update_check_diff_panels;  // 0.94.a

var
  num_str: string;
  able: boolean;

  this_diff: Tcheck_end_diff;

  code, code_max: EMarkCode;

begin
  if check_diffs_form.Showing = True then begin

    num_str := get_current_diffed_dims;

    with check_diffs_form do begin

      if num_str = ''
      // none selected, or K-checks remain selected and not now a half-diamond
      then begin
        able := False;
        readout_label.Visible := False;
        length_panel.Font.Color := clGray;
        number_panel.Caption := '';

        length_panel.Caption := ' ( no rail end is selected )';
        flare_panel.Caption := '';
        gap_panel.Caption := '';
      end
      else begin                                 // update for selected
        able := True;
        readout_label.Visible := True;
        length_panel.Font.Color := clBlue;
        number_panel.Caption := num_str;

        if show_diffs_fs = True then begin
          length_panel.Caption :=
            ' length :  ' + round_str(current_diffed_len / inscale, 2) + ' ins';
          flare_panel.Caption :=
            ' flare length :  ' + round_str(current_diffed_fl_len / inscale, 2) + ' ins';
          gap_panel.Caption :=
            ' end gap :  ' + round_str(current_diffed_end_gap / inscale, 2) + ' ins';
        end
        else begin
          length_panel.Caption :=
            ' length :  ' + round_str(current_diffed_len, 2) + ' mm';
          flare_panel.Caption :=
            ' flare length :  ' + round_str(current_diffed_fl_len, 2) + ' mm';
          gap_panel.Caption :=
            ' end gap :  ' + round_str(current_diffed_end_gap, 2) + ' mm';
        end;
      end;

      data_button.Enabled := able;
      lengthen_button.Enabled := able;
      shorten_button.Enabled := able;

      mouse_length_button.Enabled := able;
      mouse_flare_button.Enabled := able;
      mouse_gap_button.Enabled := able;

      bent_button.Enabled := able;
      machined_button.Enabled := able;
      no_flare_button.Enabled := able;
      flare_restore_button.Enabled := able;


      // enable restore buttons only if something to restore ...

      this_diff := get_checkrail_diff(current_diff_code);

      if (this_diff.len_diff = 0) and (this_diff.flr_diff = 0) and
        (this_diff.gap_diff = 0) and (this_diff.type_diff = 0) then
        reset_button.Enabled := False
      else
        reset_button.Enabled := able;


      if half_diamond = True then
        code_max := eMC_508_DSWingRail
      else
        code_max := eMC_506_TSWingRail;

      for code := eMC_501_MSWorkingEnd to code_max do begin

        this_diff := get_checkrail_diff(code);

        if (this_diff.len_diff = 0) and (this_diff.flr_diff = 0) and
          (this_diff.gap_diff = 0) and (this_diff.type_diff = 0) then
          CONTINUE
        else begin
          reset_all_button.Enabled := able;
          EXIT;
        end;
      end;//next diff

      reset_all_button.Enabled := False;    // no adjustments to restore

    end;//with form
  end;//if showing
end;
//______________________________________________________________________________

//flare_type:integer=0;   // 0.94.a was flared_ends:integer=0;        // 0=straight bent  1=straight machined.
//type_diff:byte;         // 0=no diff   1=change to bent flare    2=change to machined flare


function get_flare_type(type_diff: byte): integer;    // for calcs

  // N.B.  !!! 0.94.a values now reversed for easier calcs
  // !!!  now 0=machined or none, 1=bent

begin
  Result := ABS(flare_type - 1);  // init as mint

  case type_diff of
    0:
      Result := ABS(flare_type - 1);  // as mint
    1:
      Result := 1;                  // bent
    2:
      Result := 0;                  // machined or none
  end;//case
end;
//______________________________________________________________________________

function xdims: boolean;          //  calculate rail x dimensions from origin.
  //  N.B. heelx and all subsequent dims (except turnout_road_endx, main_road_endx) include xorg.
var
  temp, tempx, tempy, tempk: double;
  i: integer;
  k88, angled_sl: double;
  bnw: double;
  tcosk3: double;

  swing_on_k_check: double;  // 0.93.a

  tradius_cl: double;  // 0.93.a

  ka: double;          // 214a  angle at knuckle
  knuck_max: double;

begin
  Result := False;  // default init.

  try
    //with cpi do begin
    tx := heelx + tl;                           // x to end of turnout curve.
    fpx := tx + sl;                             // x to fine point.

    // mod 0.75.a  10-10-01...

    bnx := fpx +{0.375}(bn_wide / 2) * inscale / SIN(k3 / 2);
    // x to blunt nose. (point rail gauge-face) (slightly wider if curved crossing.
    bnxx := bnx -{0.750}bn_wide * inscale * SIN(k3 / 2);
    // x to ditto (splice rail gauge-face).

    bnox := fpx + j / TAN(k3 / 2);
    // x to blunt nose outer edge (straight crossing - curved recalcs later).

    atx := bnx +{4}bn_to_a * inscale;            // x to centre "A" timber.
    wingendx_ms := atx + wgl_ms; //_mm;         // x to ms wing rail end.

    csrfpx := fpx - g * SIN(k3);       // x to curved stock rail opposite fp.
    csrfpox := csrfpx - j * SIN(k3);   // x to ditto outer-edge.

    dpx := fpx - g / 2 / TAN(k3 / 2);
    // x to deflection point (intersection of track centre-lines).

    ipx := (dpx + fpx) / 2;            // x to IP Intermediate 208a  arbitrary

    tcpx := dpx + (fpx - dpx) * COS(k3);
    // x to point on turnout road centre-line opposite fine point.
    tcpy := g / 2 + (fpx - dpx) * SIN(k3); // y ditto.

    if xing_calc_i < 1             // straight crossing, regular (0) or generic (-1)...
    then begin
      txpy := (trtscent + g) / 2;         // y to TXP, turnout-side crossover mid-point.
      txpx := dpx + k3n * trtscent / 2;     // x ditto.
      txpk := k3;                     // angle at TXP.   0.78.e  23-02-03

      tempx := bnx + veelong * COS(k3);    // x to splice rail joint, straight crossing.
      // also for parallel crossing, even if on return curve - slight error?
      tvjpx := tempx - g * SIN(k3) / 2;      // x to TVJP on track centre-line.
      tvjpk := k3;                     // angle at TVJP.


      // 218d mods for return curve ...

      //retx:=txpx*2-tcpx;       // x to return curve start (tcp for a phantom crossover turnout).
      //rety:=txpy*2-tcpy;       // y ditto

      retx := tvjpx;                    // 218d  return curve always starts at TVJP
      rety := g / 2 + (tvjpx - dpx) / k3n;

    end
    else begin                      // curviform crossing (1)
      txpy := (trtscent + g) / 2;    // y to turnout-side crossover mid-point.

      temp := SQR(tradius - g / 2) - SQR(torgy - txpy);  //^^^
      if temp < minfp then begin                 // something wrong.
        txpx := tcpx;         // set to crossing-point instead.
        txpy := tcpy;
      end
      else
        txpx := torgx + SQRT(temp) * SGZ(tradius);
      //^^^   // x to turnout-side crossover mid-point.
      try
        txpk := ARCSIN((txpx - torgx) / (tradius - g / 2));
        //^^^ // angle at TXP. 0.78.e  23-02-03.
      except
        txpk := k3;   // ??? gone wrong somewhere.
      end;//try

      try
        tvjpk := ARCSIN((bnx - torgx) / tradius) + veelong / tradius;
        //^^^ // angle at TVJP = angle to blunt nose + angle along splice rail.
        if tvjpk > k4_limit then
          tvjpk := k4_limit;              // can't exceed swing limit. (90 degs approx).
      except
        tvjpk := k4_limit;
      end;//try

      //tempx:=torgx+tradius*SIN(tvjpk); //^^^  // x to splice rail joint, curved crossing.
      //tvjpx:=tempx-g*SIN(tvjpk)/2;     // x to TVJP on track centre-line.

      tvjpx := torgx + (tradius - g / 2) * SIN(tvjpk);


      //retx:=txpx;       // x to return curve start (not used to draw - this is a curved crossing).
      //rety:=txpy;       // y ditto

      retx := tvjpx;
      // 218d  return curve always starts at TVJP
      rety := torgy - (tradius - g / 2) * COS(tvjpk);
    end;

    temp := 1 - COS(tvjpk);
    if temp < minfp then
      retr := maxfp                      // crossing so flat return rad is straight ?
    else
      retr := (trtscent + g / 2 - rety) / temp;  // return curve centre-line radius.

    if retr < minfp                  // can't use return radius zero or negative.
    then begin
      if retpar_i = 1 then begin
        alert(0, '   calculation  failure',
          'Sorry, a return curve to parallel track will not fit.' +
          '||Increase the track centre-to-centre spacing or use a flatter V-crossing angle.)',
          '', '', '', '', '', 'O K  -  cancel  parallel  V-crossing', 0);
        retpar_i := 0;
        //  and cancel the return curve.
        pad_form.snap_exit_to_return_curve_menu_entry.Enabled := False;
      end
      else
        retr := g;      //  use bare minimum for calcs - g arbitrary.
    end;

    retrorgx := retx + retr * SIN(tvjpk);    // x to return curve centre. (= end of return curve.)
    retrorgy := trtscent + g / 2 - retr;       // y to return curve centre.

    trpx := retrorgx;                  // x to turnout-side return point.
    trpy := trtscent + g / 2;              // y to ditto.

    mcpx := fpx;                      // x to ditto on main road.

    if xing_calc_i <> 1                      // straight crossing, regular or generic...
    then
      mxpx := dpx + trtscent / 2 / SIN(k3)
    // x to main-side crossover mid-point. Mod 0.78.e WAS trmscent MS spacing. 22-02-03.
    else begin
      // curved crossing...  Mod BUG FIX 0.78.e WAS as for straight crossing. 22-02-03.
      try
        mxpx := txpx - (trtscent / 2) / TAN(txpk) + (trtscent / 2) / SIN(txpk);
        // 0.78.e  23-02-03
      except
        mxpx := fpx;  // something wrong
      end;
    end;

    mrpx := retrorgx;                 // x to main-side return point.

    mvjpx := bnx + veelong;              // x to main-side vee rail joint (point rail).

    default_turnoutx := mvjpx + (psleep[pt_i, 0] + psleep[pt_i, 1]) * inscale;
    // default free length to 2nd sleeper centre beyond point rail joint.

    if turnout_i = 0         //  new turnout - reset nominal length - length free.
    then begin
      if (xing_calc_i <> 1) and (retpar_i = 1)       // set up defaults for screenx.
      then
        turnoutx := retrorgx                 // x to end of return curve,
      else
        turnoutx := default_turnoutx;
      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;
    end;

    // 209a 217a  exit mods...

    if rail_section = 2  // FB rails
    then
      min_main_road_endx := 0 - xorg + fpx + ofb / TAN(k3 / 2) + scale / 6
    // FB minimum main road is end of outer foot splice + 2" scale
    else
      min_main_road_endx := 0 - xorg + fpx + railtop / TAN(k3 / 2) + scale / 6;
    // BH minimum main road is end of head splice + 2" scale

    min_turnout_road_endx := min_main_road_endx - g * SIN(k3) / 2;
    //  217a (from CTRL-1)   (turnout-road dim is to track centre-line)

    case turnout_road_i of
      -1:
        turnout_road_endx := txpx - xorg;      // crossover
      0:
        turnout_road_endx := tvjpx - xorg;     // normal
      1:
        turnout_road_endx := turnoutx - xorg;  // long

      3:
        turnout_road_endx := min_turnout_road_endx;     // minimum 217a

      // no change to turnout_road_endx  if 2: adjustable
    end;//case

    if turnout_road_endx < min_turnout_road_endx then
      turnout_road_endx := min_turnout_road_endx;   // dims are from CTRL-1 !!!

    if (turnout_i = 0)                            //  template length free.
      and ((xorg + turnout_road_endx) > turnoutx) then
      turnout_road_endx := turnoutx - xorg;  // 209a mod  // dims to CTRL-1

    // 209a mods end.

    // 217a mods ...

    case main_road_i of
      -1:
        main_road_endx := mxpx - xorg;      // crossover
      0:
        main_road_endx := turnoutx - xorg;     // normal

      3:
        main_road_endx := min_main_road_endx;     // 217a

      // no change to main_road_endx  if 2: adjustable      1: not valid
    end;//case

    if main_road_endx < min_main_road_endx then
      main_road_endx := min_main_road_endx;   // dims are from CTRL-1 !!!

    if (turnout_i = 0)                            //  template length free.
      and ((xorg + main_road_endx) > turnoutx) then
      main_road_endx := turnoutx - xorg;     // dims to CTRL-1

    // 217a mods end.

    if xing_calc_i <> 1  // straight crossing, regular or generic:
    then begin
      if retpar_i = 1                         // return curve ?
      then begin
        vendx := retx + g / 2 * SIN(k3);
        // yes, x to end of straight portion of vee splice rail,
        csrendx := retx - g / 2 * SIN(k3);  // and stock rail opposite.
      end
      else begin
        case turnout_road_i of
          -1: begin
            vendx := txpx + (g / 2) * SIN(k3);
            // short - for crossover.
            csrendx := vendx - g * SIN(k3);
            // x to curved stock rail end (slight error for curved crossing).
          end;
          0: begin
            vendx := bnx + veelong * COS(k3) + scale / 2;
            // normal - length of splice rail only  (add 6" for luck - looks better).
            csrendx := vendx - g * SIN(k3);
            // x to curved stock rail end (slight error for curved crossing).
          end;
          1: begin
            vendx := turnoutx;
            // long - x to rail end - full length of turnout. (could be shorter than normal, e.g. catch points).
            csrendx := vendx - g * SIN(k3);
            // 209a  was vendx;  ditto x to curved stock rail end.
          end;
          2, 3: begin
            // 209a              3 added 217a
            vendx := xorg + turnout_road_endx + g * SIN(k3) / 2;
            // adjustable
            csrendx := vendx - g * SIN(k3);
            // ditto x to curved stock rail end.
          end;


          else
            run_error(237);
        end;//case
      end;

      vendox := vendx + j * SIN(k3);        // x to ditto outer edge.
      csrendox := csrendx - j * SIN(k3);    // x to ditto outer edge.
    end
    else begin           // ditto for curviform crossing...

      //temp:=SQR(tradius+j)-SQR(k3cost-j);      //^^^

      temp := SQR(tradius + j) - SQR(torgy - g - j);       //^^^
      if temp < minfp then
        bnox := fpx + j / TAN(k3 / 2)   // ???
      else
        bnox := torgx + SQRT(temp) * SGZ(tradius);  // ^^^   // x to blunt nose outer edge.

      // calc k4 swing and limit turnout road to 90 degrees less 0.001 radians max...

      tradius_cl := tradius - g / 2;     // centre-line radius, turnout road

      case turnout_road_i of
        -1:
          if ABS(tradius_cl) < minfp      // crossover  //^^^
          then
            k4 := k4_limit
          else begin
            if ABS((txpx - torgx) / tradius_cl) > (1.0 - minfp)    //^^^
            then
              k4 := k4_limit
            else
              k4 := ARCSIN((txpx - torgx) / tradius_cl);
            //^^^ // crossover - angle to end of turnout road.
          end;

        0: begin                         // normal
          k4 := tvjpk;
          // normal length, stop at vee splice rail joint.
          if ABS(tradius_cl) > minfp then
            k4 := k4 + scale / 2 / tradius_cl;  //^^^ // add 6" beyond joint for luck.
        end;

        1:
          if ABS(tradius_cl) < minfp      // long
          then
            k4 := k4_limit                                         //^^^
          else begin
            if ABS((turnoutx - torgx) / tradius_cl) > (1.0 - minfp)    //^^^
            then
              k4 := k4_limit
            else
              k4 := ARCSIN((turnoutx - torgx) / tradius_cl);
            //^^^ // angle to end of long turnout road.
          end;

        2, 3:
          if ABS(tradius_cl) < minfp      // 209a adjustable          //  3 added 216c
          then
            k4 := k4_limit
          else begin
            if ABS((xorg + turnout_road_endx - torgx) / tradius_cl) > (1.0 - minfp) then
              k4 := k4_limit
            else
              k4 := ARCSIN((xorg + turnout_road_endx - torgx) / tradius_cl);
            // angle to end of adjustable turnout road.
          end;

        else
          k4 := k3;   // !!!
      end;//case

      if ABS(k4) > k4_limit then
        k4 := SGZ(k4) * k4_limit;

      vendx := torgx + tradius * SIN(k4);     //^^^
      vendox := vendx + j * SIN(k4);
      csrendx := vendx - g * SIN(k4);
      csrendox := csrendx - j * SIN(k4);
    end;
    //--------------------

    //  main-side check rail dims:  mod: 0.71.a  17-05-01...
    //                        mod again: 0.79.a  29-05-03...

    if (timbers_equalized = False) and (half_diamond = False) then begin
      if square_on_angled = False then
        ckmidx_ms := atx                                     // square-on timbering.
      else
        ckmidx_ms := atx + ((atx - fpx) * TAN(k3 / 2) + g - fw) * TAN(k3);
      // angled-on timbering - shift ms check rail forward.
    end
    else
      ckmidx_ms := atx + ((atx - fpx) * TAN(k3 / 2) + g - fw) * TAN(k3 / 2);
    // timbering equalized - shift ms check rail forward.


    // 0.93.a old code instead ...


    ckendx := ckmidx_ms + check_ms_extlen * inscale;
    // inches full-size MS check rail end extension beyond "A".

    ckflarex := ckendx - flen_me;                   // x to check rail flare-out.
    ckflarox := ckflarex - j * TAN(k5_me / 2);          // x to check rail flare-out, outer edge.

    ckx_ms := ckendx - ckl_ms;                      // x to check rail start.

    ckfwx := ckx_ms + flen_mw;                      // x to end of flare-in.
    ckfwox := ckfwx + j * TAN(k5_mw / 2);               // x to end of flare-in, outer edge.

    ckox := ckx_ms + j * SIN(k5_mw) * get_flare_type(ccd.end_diff_mw.type_diff);
    // x to check rail start.
    ckendox := ckendx - j * SIN(k5_me) * get_flare_type(ccd.end_diff_me.type_diff);
    // x to check rail end.


    // calc the virtual knuckle points :

    if xing_calc_i <> 0  //  for original or curviform crossing, knuckle on turnout radius :
    then begin
      try
        tcosk3 := tradius * COS(k3);                                            //^^^
        wingx := torgx + SQRT(SQR(tradius) - SQR(tcosk3 + fw)) * SGZ(tradius);
        //^^^ // x to knuckle point, trg.
        wingox := torgx + SQRT(SQR(tradius + j) - SQR(tcosk3 + fw + j)) * SGZ(tradius);
        //^^^ // x to ditto, outer edge, tro.
        wingcx := torgx + SQRT(SQR(tradius - fw) - SQR(tcosk3)) * SGZ(tradius);
        //^^^ // x to knuckle point, str.
        wingcox := torgx + SQRT(SQR(tradius - fw - j) - SQR(tcosk3 - j)) * SGZ(tradius);
        //^^^ // x to ditto, outer edge.
      except
        // ??? most likely a gaunt turnout with large positive offset.
        // calc as if for regular crossing instead...

        wingx := fpx - fw * k3n;                  //  turnout rail
        wingox := wingx + j * TAN(k3 / 2);

        wingcx := fpx - fw / SIN(k3);             //  main rail
        wingcox := wingcx - j * TAN(k3 / 2);
      end;//try
    end
    else begin                                // for regular crossing :
      wingx := fpx - fw * k3n;                 // x dittos for above, on the straight.
      wingox := wingx + j * TAN(k3 / 2);

      wingcx := fpx - fw / SIN(k3);
      wingcox := wingcx - j * TAN(k3 / 2);
    end;
    // -------------------------------------------------------

    if xing_calc_i <> 0  //  for original or curviform crossing, knuckle on turnout radius :
    then begin
      try
        ka := ARCSIN((wingx - torgx) / tradius);   // knuckle angle in rail
      except
        ka := k3;     // ???
      end;//try
    end
    else
      ka := k3;  // regular crossing

    // and the knuckle radius terminal points on x   214a   ...

    // keep compiler happy - init for sharp knuckle...

    knuck_rad := 0;    // ignored

    wingx_plus := wingx;
    wingx_minus := wingx;

    wingox_plus := wingox;
    wingox_minus := wingox;

    wingcx_plus := wingcx;
    wingcx_minus := wingcx;

    wingcox_plus := wingcox;
    wingcox_minus := wingcox;

    if knuckle_code <> -1      // not sharp
    then begin
      case knuckle_code of        // 0=normal, -1=sharp, 1=use knuckle_radius

        0:
          knuck_rad := k3n * scale;       // =0 normal   calc as GWR  rad=crossing angle in feet

        1:
          knuck_rad := knuckle_radius * inscale;  // use custom setting

      end;//case

      knuck_max := ABS(fpx - wingx - inscale);
      // bend must stop 1 inch scale in front of FP. Reduce bend radius if not.

      tempx := ABS(knuck_rad * TAN(ka / 2));    // from knuckle to knuckle rad centre

      if tempx > knuck_max then begin
        tempx := knuck_max;
        try
          knuck_rad := tempx / TAN(ka / 2);
        except
          knuck_rad := tempx;  // ??? arbitrary div0 protection
        end;//try
      end;

      temp := tempx * COS(ka);         // ditto along crossing angle

      wing_bend_offset := tempx * SIN(ka);  // used for knuckle marks.

      wingx_plus := wingx + tempx;
      // knuckle radius terminal points...  turnout rail
      wingx_minus := wingx - temp;

      wingox_plus := wingx_plus;
      wingox_minus := wingx_minus + j * SIN(ka);


      wingcx_plus := wingcx + temp;      // main rail ...
      wingcx_minus := wingcx - tempx;

      wingcox_plus := wingcx_plus - j * SIN(ka);
      wingcox_minus := wingcx_minus;

    end;

    //  main-side wing rail:

    wflarex := wingendx_ms - flen_mr;           // x to wing rail flare-out.
    wflarox := wflarex - j * TAN(k5_mr / 2);        // x to wing flare-out, outer-edge.

    wingendox := wingendx_ms - j * SIN(k5_mr) * get_flare_type(ccd.end_diff_mr.type_diff);

    //  turnout-side wing rail :

    //fleg:=flen_tr/COS(k5_tr);              // length along flare leg.

    wingcfpx := fpx - fw * SIN(k3);           // x to wing rail at f.p.
    wingcfpox := wingcfpx - j * SIN(k3);      // x to ditto, outer edge.

    //wl:=wflarex-wingx+ccd.end_diff_tr.len_diff*inscale;      // length of wing rail, knuckle to flare.
    //wfp:=wflarex-fpx+ccd.end_diff_tr.len_diff*inscale;       // length of wing rail, f.p. to flare.

    // 0.94.a first part up to A timber is symmetrical with main-side..

    wl := (atx - wingx) + wgl_ts - flen_tr;   // length along ts wing rail, knuckle to flare.
    wfp := (atx - fpx) + wgl_ts - flen_tr;    // length along ts wing rail, f.p. to flare.

    case xing_calc_i of

      1: begin                         // for curviform V-crossing :
        k6 := wfp / (tradius - fw);                              // angle turned along wfp.
        k7 := flen_tr / (tradius - fw);                          // ditto along flare.
        flarecx := torgx + (tradius - fw) * SIN(k3 + k6);            // x to flare-out, gauge-face.
        flarecox := flarecx - jbend_tr * SIN(k3 + k6 + k5_tr / 2);     // x to ditto, outer edge.
        flcendx := torgx + (tradius - (fw_end + ccd.end_diff_tr.gap_diff)) * SIN(k3 + k6 + k7);
        // x to end of wing rail, gf.

        case get_flare_type(ccd.end_diff_tr.type_diff) of
          1:
            flcendox := flcendx - j * SIN(k3 + k6 + k7 + k5_tr);
            // x to ditto, outer edge, bent flares.
          else
            flcendox := flcendx - (j + fw - (fw_end + ccd.end_diff_tr.gap_diff)) *
              SIN(k3 + k6 + k7);
            // machined flares.
        end;//case
      end;

      0: begin                         // ditto for regular crossing :

        // !!! these are not correct for a return curve (parallel crossing) - not yet done 29-5-01

        flarecx := wingcx + wl * COS(k3);
        flarecox := flarecx - jbend_tr * SIN(k3 + k5_tr / 2);
        flcendx := flarecx + (flen_tr / COS(k5_tr)) * COS(k3 + k5_tr);
        // 0.94.a (flen_tr/COS(k5_tr)) = length along flare leg (was fleg)

        case get_flare_type(ccd.end_diff_tr.type_diff) of
          1:
            flcendox := flcendx - j * SIN(k3 + k5_tr);
            // x to ditto, outer edge, bent flares.
          else
            flcendox := flcendx - (j + fw - (fw_end + ccd.end_diff_tr.gap_diff)) * SIN(k3);
            // machined flares.
        end;//case

      end;
      -1: begin                              // ditto for generic crossing :
        flarecx := wingcfpx + wfp * COS(k3);
        flarecox := flarecx - jbend_tr * SIN(k3 + k5_tr / 2);
        flcendx := flarecx + flen_tr * COS(k3 + k5_tr);

        case get_flare_type(ccd.end_diff_tr.type_diff) of
          1:
            flcendox := flcendx - j * SIN(k3 + k5_tr);
            // x to ditto, outer edge, bent flares.
          else
            flcendox := flcendx - (j + fw - (fw_end + ccd.end_diff_tr.gap_diff)) * SIN(k3);
            // machined flares.
        end;//case
      end;
    end;//case

    // ---------------------------------------------------------

    //  calc turnout-side check rail dims:  mod: v0.71.a  17-5-01...

    cuckrad := csradius + fw;                              // rad to check-face.
    //cuckflrad:=csradius+fwe;                           // rad to flare-ends.

    cuckflrad_tw := csradius + fw_end + ccd.end_diff_tw.gap_diff;
    // rad to flare-end TS working end.
    cuckflrad_te := csradius + fw_end + ccd.end_diff_te.gap_diff;
    // rad to flare-end TS extension end.

    cuckfpx := fpx - (g - fw) * SIN(k3);                    // x to check rail at f.p.
    cuckfpox := cuckfpx + j * SIN(k3);                    // x to ditto, outer edge.

    //check_ts_wklen:=check_ms_wklen+ck_ts_working_mod;    // full-size inches - TS check rail working length.
    //check_ts_extlen:=check_ms_extlen+ck_ts_ext_mod;      // full-size inches - TS check rail extension length.

    // align ts mid with "A"...

    cktsmid_offset := (atx - cuckfpx) / COS(k3);
    // length along check, from check at f.p. to intercept on "A". (for square-on timbering).

    if (timbers_equalized = True) or (half_diamond = True) then
      cktsmid_offset := cktsmid_offset - ((atx - fpx) * TAN(k3 / 2) + g - fw) *
        (TAN(k3) - TAN(k3 / 2))
    // pull check rail back if equalized timbering.
    else begin
      if square_on_angled = True then
        cktsmid_offset := cktsmid_offset - ((atx - fpx) * TAN(k3 / 2) + g - fw) * TAN(k3);
      // or angled-on.
    end;

    cucklb := cktsmid_offset + check_ts_extlen * inscale - flen_te;
    // length along check, f.p. to flare-out, straight crossing.

    if xing_calc_i = 1         // curviform V-crossing, calc swing on cucklb.        and flen_te 0.96.a
    then begin
      if ABS(cuckrad) < minfp then begin
        k10 := Pi / 2;               // !!!
        k11 := pi / 2;               // 0.96.a
      end
      else begin
        k10 := cucklb / cuckrad;
        k11 := flen_te / cuckrad;  // 0.96.a
      end;
    end;

    cuckla := ckl_ts - cucklb - flen_te - flen_tw;
    // length along turnout-side check rail, flare-in to f.p.

    //k10:=cucklb/cuckrad;          // k10 not yet in for equalized timbers.


    if xing_calc_i <> 0            // for curviform or generic straight crossing:
    then begin
      k8 := cuckla / cuckrad;           // angle turned through cuckla.
      k9 := flen_tw / cuckrad;          // angle turned through check rail flare-in.

      if k8 < k3            // check-rail flared-in length starts on the turnout curve...
      then begin
        cuckfwx := torgx + cuckrad * SIN(k3 - k8);
        // x to check rail at flare-in.
        cuckfwox := cuckfwx + jbend_tw * SIN(k3 - k8 + k5_tw / 2);
        // x to ditto, outer-edge.
      end
      else begin
        // 0.71.a long check working length - ignore switch rad and planing (approximation)..

        cuckfwx := torgx - (cuckla - cuckrad * k3);           // x to check rail at flare-in.
        cuckfwox := cuckfwx + jbend_tw * SIN(k5_tw / 2);
        // x to ditto, outer-edge (assumes bent flares).
      end;

      if (k8 + k9) < k3     // check rail starts on turnout curve...
      then begin
        cuckx := torgx + cuckflrad_tw * SIN(k3 - k8 - k9);         // x to check rail start.
        {
                      case flared_ends of
                                    0: cuckox:=cuckx+j*SIN(k3-k8-k9+k5);       // x to ditto, outer-edge. bent flares.
                                  else cuckox:=cuckx+(j+fw-fwe)*SIN(k3-k8-k9); // machined flares.
                      end;//case
}

        case get_flare_type(ccd.end_diff_tw.type_diff) of
          1:
            cuckox := cuckx + j * SIN(k3 - k8 - k9 + k5_tw);
            // x to ditto, outer-edge. bent flares.
          else
            cuckox := cuckx + (j + fw - (fw_end + ccd.end_diff_tw.gap_diff)) * SIN(k3 - k8 - k9);
            // machined flares.
        end;//case

      end
      else begin
        // 0.71.a long check working length - ignore switch rad and planing (approximation)..

        cuckx := cuckfwx - flen_tw;         // x to check rail start.
        {
                      case flared_ends of
                                    0: cuckox:=cuckx+jbend*SIN(k5/2);         // x to ditto, outer-edge. bent flares.
                                  else cuckox:=cuckx;                         // machined flares.
                      end;//case
}
        cuckox := cuckx + jbend_tw * SIN(k5_tw / 2) * get_flare_type(ccd.end_diff_tw.type_diff);
      end;
    end
    else begin          // for regular crossing (also parallel crossing):


      if ABS(COS(k3)) < minfp then
        angled_sl := sl                 // !!!
      else
        angled_sl := sl / COS(k3);        // angled length along entry staight to f.p.

      if (cuckla < angled_sl) or (tradius_is_straight = True)
      //~~~ 0.79.a all on straight crossing part...
      then begin
        cuckfwx := cuckfpx - cuckla * COS(k3);
        cuckfwox := cuckfwx + jbend_tw * SIN(k3 + k5_tw / 2);
        cuckx := cuckfwx - (flen_tw / COS(k5_tw)) * COS(k3 + k5_tw);
        // (flen_tw/COS(k5_tw)) was fleg (calc flare as on straight part even if running rail is on curve).

        case get_flare_type(ccd.end_diff_tw.type_diff) of
          1:
            cuckox := cuckx + j * SIN(k3 + k5_tw);        // bent flares.
          else
            cuckox := cuckx + (j + fw - (fw_end + ccd.end_diff_tw.gap_diff)) * SIN(k3);
        end;//case
      end
      else begin

        k88 := (cuckla - angled_sl) / cuckrad;  // angle turned through flared-in length.
        k9 := flen_tw / cuckrad;
        // angle turned through check rail flare-in.

        if k88 < k3       // check-rail flared-in length starts on the turnout curve...
        then begin
          cuckfwx := torgx + cuckrad * SIN(k3 - k88);
          // x to check rail at flare-in.
          cuckfwox := cuckfwx + jbend_tw * SIN(k3 - k88 + k5_tw / 2);
          // x to ditto, outer-edge.
        end
        else begin
          // 0.71.a long check working length - ignore switch rad and planing (approximation)..

          cuckfwx := torgx - (cuckla - angled_sl - cuckrad * k3);
          // x to check rail at flare-in.
          cuckfwox := cuckfwx + jbend_tw * SIN(k5_tw / 2);
          // x to ditto, outer-edge (assumes bent flares).
        end;

        if (k88 + k9) < k3     // check rail starts on turnout curve...
        then begin
          cuckx := torgx + cuckflrad_tw * SIN(k3 - k88 - k9);
          // x to check rail start.

          case get_flare_type(ccd.end_diff_tw.type_diff) of
            1:
              cuckox := cuckx + j * SIN(k3 - k88 - k9 + k5_tw);
              // x to ditto, outer-edge. bent flares.
            else
              cuckox := cuckx + (j + fw - (fw_end + ccd.end_diff_tw.gap_diff)) *
                SIN(k3 - k88 - k9);
              // machined flares.
          end;//case

        end
        else begin
          // 0.71.a long check working length - ignore switch rad and planing (approximation)..

          cuckx := cuckfwx - flen_tw;         // x to check rail start.
          cuckox :=
            cuckx + jbend_tw * SIN(k5_tw / 2) * get_flare_type(ccd.end_diff_tw.type_diff);
        end;
      end;
    end;

    // TS check rail extension end

    if xing_calc_i = 1                                     // for curviform V-crossing only :
    then begin
      cuckflx := torgx + cuckrad * SIN(k3 + k10);                  // x to check rail flare-out.
      cuckflox := cuckflx + jbend_te * SIN(k3 + k10 - k5_te / 2);
      // x to ditto, outer-edge (assumes bent flares).
      //
      //cuckendx:=torgx+cuckflrad_te*SIN(k3+k10+k9);              // x to check rail end.
      cuckendx := torgx + cuckflrad_te * SIN(k3 + k10 + k11);  // 0.97.a    // x to check rail end.

      case get_flare_type(ccd.end_diff_te.type_diff) of
        //1: cuckendox:=cuckendx+j*SIN(k3+k10+k9-k5_te);                                  // x to ditto, outer-edge. bent flares.
        //else cuckendox:=cuckendx+(j+fw-(fw_end+ccd.end_diff_te.gap_diff))*SIN(k3+k10+k9); // machined flares.

        1:
          cuckendox := cuckendx + j * SIN(k3 + k10 + k11 - k5_te);
          // 0.97.a                                 // x to ditto, outer-edge. bent flares.
        else
          cuckendox := cuckendx + (j + fw - (fw_end + ccd.end_diff_te.gap_diff)) *
            SIN(k3 + k10 + k11);
          // 0.97.a  // machined flares.

      end;//case

    end
    else begin                      // straight crossing, normal or original :

      // !!!! these are not correct for a return curve (parallel crossing) - not yet done 29-5-01

      cuckflx := cuckfpx + cucklb * COS(k3);                    // x to check rail flare-out.
      cuckflox := cuckflx + jbend_te * SIN(k3 - k5_te / 2);
      // x to ditto, outer-edge (assumes bent flares).

      cuckendx := cuckflx + (flen_te / COS(k5_te)) * COS(k3 - k5_te);
      // x to check rail end. (flen_te/COS(k5_te)) was fleg

      case get_flare_type(ccd.end_diff_te.type_diff) of
        1:
          cuckendox := cuckendx + j * SIN(k3 - k5_te);
          // x to ditto, outer-edge. bent flares.
        else
          cuckendox := cuckendx + (j + fw - (fw_end + ccd.end_diff_te.gap_diff)) * SIN(k3);
          // machined flares.
      end;//case

    end;
    //__________________

    // K-crossing check rails...

    if (half_diamond = True) and (fixed_diamond = True) then begin

      // diagonal-side check rail (straight)...

      if (hd_timbers = 2) or (hd_timbers = 3)       // timbers on main or both sides for slip ...
      then begin
        if g < (56 * inscale)                                           // not P4 etc.
        then
          kckl_dk := (62 + ccd.end_diff_dk.len_diff) * inscale
        // 215a  124" length for slips arbitrary 9" shorter each end
        else
          kckl_dk := (71 + ccd.end_diff_dk.len_diff) * inscale;
        // 215a  142" prototype length for slips
      end
      else
      if hdkn > (6 + minfp) then
        kckl_dk := (kck2_long / 2 + ccd.end_diff_dk.len_diff) * inscale
      // 0.94.a add mouse diff    // overall length on half-diamond.
      else
        kckl_dk := (kck1_long / 2 + ccd.end_diff_dk.len_diff) * inscale;

      kckdsx := toex - (g - fw) * TAN(hdk / 2);       // x to start of DS check rail, gf. aq=28.
      kckdsox := toex - (g - fw - j) * TAN(hdk / 2);    // ditto oe.                        aq=29.

      kckdsflx := kckdsx + kckl_dk - flen_dk;            // x to DS flare bend, gf.
      kckdsflox := kckdsflx - jbend_dk * SIN(k5_dk / 2);   // ditto oe.

      kckdsflendx := kckdsflx + flen_dk * COS(k5_dk);     // x to end of DS check rail, gf.

      kckdsflendox := kckdsflendx - j * SIN(k5_dk) * get_flare_type(ccd.end_diff_dk.type_diff);

      // main-side check rail (angled at hdk)...

      if (hd_timbers = 1) or (hd_timbers = 3)
      // timbers on diagonal or both sides for slip ...
      then begin
        if g < (56 * inscale)                                           // not P4 etc.
        then
          kckl_mk := (62 + ccd.end_diff_mk.len_diff) * inscale
        // 215a  124" length for slips arbitrary 9" shorter each end
        else
          kckl_mk := (71 + ccd.end_diff_mk.len_diff) * inscale;
        // 215a  142" prototype length for slips
      end
      else
      if hdkn > (6 + minfp) then
        kckl_mk := (kck2_long / 2 + ccd.end_diff_mk.len_diff) * inscale
      // 0.94.a add mouse diff    // overall length on half-diamond.
      else
        kckl_mk := (kck1_long / 2 + ccd.end_diff_mk.len_diff) * inscale;

      kckmsx := toex - fw * TAN(hdk / 2);          // x to start of MS check rail, gf. aq=26.
      kckmsox := toex - (fw + j) * TAN(hdk / 2);     // ditto oe.                        aq=27.

      // for irregular half-diamonds these are approximations (hdk angle valid only at start)...

      kckmsflx := kckmsx + (kckl_mk - flen_mk) * COS(hdk);         // x to MS flare bend, gf.

      kckmsflox := kckmsflx - jbend_mk * SIN(k5_mk / 2 + hdk);       // ditto oe.

      kckmsflendx := kckmsflx + flen_mk * COS(k5_mk + hdk);
      // x to end of MS check rail, gf.

      if (tradius_is_straight = True) or (ABS(tradius) < minfp)   // 0.93.a
      then
        swing_on_k_check := 0
      else
        swing_on_k_check := kckl_mk / tradius; // radians

      case get_flare_type(ccd.end_diff_mk.type_diff) of
        1:
          kckmsflendox := kckmsflendx - j * SIN(k5_mk + hdk + swing_on_k_check);
          // bent flare.
        else
          kckmsflendox := kckmsflendx - (j + fw - (fw_end + ccd.end_diff_mk.gap_diff)) *
            SIN(hdk + swing_on_k_check);
          // machined flare.
      end;//case

    end;

    //  now fill terminal points on the turnout curved rails...

    // seg_termx[0,  = switch front...

    if (gaunt = True) and (half_diamond = False) then begin
      seg_termx[0, eRD_CurvedTurnoutWingGaugeFace] := 0;
      //  aq=2 turnout rail, gauge face, switch front, gauntletted approach track
      seg_termx[0, eRD_CurvedTurnoutWingOuterFace] := 0;     //  aq=10 ditto outer.
    end
    else begin
      seg_termx[0, eRD_CurvedTurnoutWingGaugeFace] := nodraw;
      //  aq=2 turnout rail, gauge face, switch front, do not draw.
      seg_termx[0, eRD_CurvedTurnoutWingOuterFace] := nodraw;
      //  aq=10 ditto outer, do not draw.
    end;

    if half_diamond = True then begin
      seg_termx[0, eRD_CurvedStockGaugeFace] := nodraw;
      //  aq=3 diagonal stock rail, gauge face, do not draw for h-d.
      seg_termx[0, eRD_CurvedStockOuterFace] := nodraw;    //  aq=11 ditto outer edge, do not draw.
    end
    else begin
      seg_termx[0, eRD_CurvedStockGaugeFace] := 0;
      //  turnout curved stock rail, gauge face, switch front start.
      seg_termx[0, eRD_CurvedStockOuterFace] := 0;         //  ditto outer edge.
    end;

    // seg_termx[1,  = planing, and set straight section...

    if half_diamond = True then begin
      seg_termx[1, eRD_CurvedTurnoutWingGaugeFace] := nodraw;
      // aq=2 trg   no planing section for h-d.
      seg_termx[1, eRD_CurvedTurnoutWingOuterFace] := nodraw;    // aq=10 tro  do not draw.

      seg_termx[1, eRD_CurvedStockGaugeFace] := nodraw;     // aq=3 srg   ditto diagonal stock rail
      seg_termx[1, eRD_CurvedStockOuterFace] := nodraw;    // aq=11 sro

    end
    else begin
      if gaunt = True then begin
        seg_termx[1, eRD_CurvedTurnoutWingGaugeFace] := toex;     // aq=2 trg
        seg_termx[1, eRD_CurvedTurnoutWingOuterFace] := toex;    // aq=10 tro

        seg_termx[1, eRD_CurvedStockGaugeFace] := toex;     // aq=3 srg
        seg_termx[1, eRD_CurvedStockOuterFace] := toex;    // aq=11 sro
      end
      else begin
        seg_termx[1, eRD_CurvedTurnoutWingGaugeFace] := toex;
        // aq=2 trg  planing start
        seg_termx[1, eRD_CurvedTurnoutWingOuterFace] := nodraw;    // aq=10 tro  do not draw.

        seg_termx[1, eRD_CurvedStockGaugeFace] := setx;       // aq=3 srg  "set" start.
        seg_termx[1, eRD_CurvedStockOuterFace] := setox;     // aq=11 sro
      end;
    end;

    // seg_termx[2,  = switch radius ...

    if half_diamond = True then begin
      seg_termx[2, eRD_CurvedTurnoutWingGaugeFace] := nodraw;
      // aq=2 trg   no switch radius section for h-d.
      seg_termx[2, eRD_CurvedTurnoutWingOuterFace] := nodraw;    // aq=10 tro  do not draw.

      seg_termx[2, eRD_CurvedStockGaugeFace] := nodraw;
      // aq=3 srg  ditto for diagonal stock rail.
      seg_termx[2, eRD_CurvedStockOuterFace] := nodraw;    // aq=11 sro
    end
    else begin
      if gaunt = True then begin
        seg_termx[2, eRD_CurvedTurnoutWingGaugeFace] := toex;     // aq=2 trg
        seg_termx[2, eRD_CurvedTurnoutWingOuterFace] := toex;    // aq=10 tro

        seg_termx[2, eRD_CurvedStockGaugeFace] := toex;     // aq=3 srg
        seg_termx[2, eRD_CurvedStockOuterFace] := toex;    // aq=11 sro
      end
      else begin
        seg_termx[2, eRD_CurvedTurnoutWingGaugeFace] := plx;
        // aq=2 trg  switch curve start.
        if plox < heelox then
          seg_termx[2, eRD_CurvedTurnoutWingOuterFace] :=
            plox     // aq=10 tro  outer-edge, normal intercept on stock rail,
        else
          seg_termx[2, eRD_CurvedTurnoutWingOuterFace] := nodraw;
        // aq=10 or no switch curve draw if extra-wide custom rail.

        seg_termx[2, eRD_CurvedStockGaugeFace] := plx3;
        // aq=3 srg  ditto for curved stock rail. (!!! coincident with the "set" for straight switch or curved planing).
        seg_termx[2, eRD_CurvedStockOuterFace] := plox11;   // aq=11 sro
      end;
    end;

    // seg_termx[3,  = turnout radius ...

    if half_diamond = True then begin
      if fixed_diamond = True then begin

        // blunt nose of diamond point rails is typically 1/8" less than V-nose (=1/2" for FB, =5/8" for BH).
        // first do blunt nose..

        bnw := (bn_wide - 0.125) * inscale;    // width of blunt nose.
        if bnw < 0 then
          bnw := 0;

        // x to diamond point blunt nose (gauge-face intersection)...

        tempy := fw + bnw * COS(hdk / 2);  // offset to tip.

        if tradius_is_straight = True then begin
          seg_termx[3, eRD_CurvedTurnoutWingGaugeFace] := toex + tempy * hdkn;
          // 20-09-04 gauge-face.
          seg_termx[3, eRD_CurvedTurnoutWingOuterFace] := plox + fw * hdkn;     // outer-edge.
        end
        else begin
          seg_termx[3, eRD_CurvedTurnoutWingGaugeFace] :=
            torgx + SGZ(tradius) * SQRT(SQR(tradius) - SQR(torgy - tempy));  // gauge-face.
          seg_termx[3, eRD_CurvedTurnoutWingOuterFace] :=
            torgx + SGZ(tradius) * SQRT(SQR(tradius + j) - SQR(torgy - fw));  // outer-edge.
        end;
      end
      else begin   // switch diamond..

        seg_termx[3, eRD_CurvedTurnoutWingGaugeFace] := toex;    // gauge-face.

        if tradius_is_straight = True       // outer-edge..
        then
          seg_termx[3, eRD_CurvedTurnoutWingOuterFace] := plox
        else
          seg_termx[3, eRD_CurvedTurnoutWingOuterFace] :=
            torgx + SGZ(tradius) * SQRT(SQR(tradius + j) - SQR(torgy));
      end;

      seg_termx[3, eRD_CurvedStockGaugeFace] := toex - g * TAN(hdk / 2);
      //0-(g/2)*SIN(hdk/2);           // aq=3 srg
      seg_termx[3, eRD_CurvedStockOuterFace] := toex - (g + j) * TAN(hdk / 2);
      //seg_termx[3,3]-j*TAN(hdk/2); // aq=11 sro

    end
    else begin     // turnout...

      if gaunt = True then begin
        seg_termx[3, eRD_CurvedTurnoutWingGaugeFace] := toex;     // aq=2 trg
        seg_termx[3, eRD_CurvedTurnoutWingOuterFace] := toex;    // aq=10 tro

        seg_termx[3, eRD_CurvedStockGaugeFace] := toex;     // aq=3 srg
        seg_termx[3, eRD_CurvedStockOuterFace] := toex;    // aq=11 sro
      end
      else begin
        seg_termx[3, eRD_CurvedTurnoutWingGaugeFace] := heelx;
        // aq=2 trg  turnout curve start.
        if plox > heelox then
          seg_termx[3, eRD_CurvedTurnoutWingOuterFace] :=
            plox     // aq=10 tro  outer-edge, intercept on (custom extra-wide) stock rail,
        else
          seg_termx[3, eRD_CurvedTurnoutWingOuterFace] := heelox;
        // aq=10 or normal draw from heel.

        seg_termx[3, eRD_CurvedStockGaugeFace] := heelx - g * SIN(k2);              // aq=3 srg
        seg_termx[3, eRD_CurvedStockOuterFace] := heelx - (g + j) * SIN(k2);         // aq=11 sro
      end;
    end;

    // seg_termx[4,  = V-crossing...

    case xing_calc_i of
      0: begin                                // for regular crossing:
        seg_termx[4, eRD_CurvedTurnoutWingGaugeFace] := tx;
        // aq=2 trg  curve ends at entry straight.
        seg_termx[4, eRD_CurvedTurnoutWingOuterFace] := tx + j * SIN(k3);
        // aq=10 tro ditto.

        seg_termx[4, eRD_CurvedStockGaugeFace] := tx - g * SIN(k3);
        // aq=3 srg  ditto for stock rail.
        seg_termx[4, eRD_CurvedStockOuterFace] := tx - (g + j) * SIN(k3);      // aq=11 sro ditto.
      end;

      1: begin                                // for curviform crossing:
        //seg_termx[4,2]:=wingx;                  // trg  end of turnout curve.
        //seg_termx[4,10]:=wingox;                // tro  ditto.

        seg_termx[4, eRD_CurvedTurnoutWingGaugeFace] := wingx_minus;
        //  214a trg  end of turnout curve at start of knuckle bend.
        seg_termx[4, eRD_CurvedTurnoutWingOuterFace] := wingox_minus;      //  214a tro  ditto.

        seg_termx[4, eRD_CurvedStockGaugeFace] := csrendx;
        // srg  end of turnout curve.
        seg_termx[4, eRD_CurvedStockOuterFace] := csrendox;              // sro  ditto.
      end;
      -1: begin                                // for generic crossing:
        //seg_termx[4,2]:=wingx;                  // trg  end of turnout curve.
        //seg_termx[4,10]:=wingox;                // tro  ditto.

        seg_termx[4, eRD_CurvedTurnoutWingGaugeFace] := wingx_minus;
        //  214a trg  end of turnout curve at start of knuckle bend.
        seg_termx[4, eRD_CurvedTurnoutWingOuterFace] := wingox_minus;      //  214a tro  ditto.

        seg_termx[4, eRD_CurvedStockGaugeFace] := csrfpx;
        // srg  end of turnout curve.
        seg_termx[4, eRD_CurvedStockOuterFace] := csrfpox;               // sro  ditto.
      end;
    end;//case

    if plain_track = True            //  stop the curved stock rail at the rail-joint
    then begin                  //  if plain track (approach track) only wanted.
      seg_termx[1, eRD_CurvedStockGaugeFace] := xorg;
      seg_termx[1, eRD_CurvedStockOuterFace] := xorg;
      for i := 2 to 4 do begin
        seg_termx[i, eRD_CurvedStockGaugeFace] := nodraw;      // aq=3   gauge-face.
        seg_termx[i, eRD_CurvedStockOuterFace] := nodraw;     // aq=11  outer-edge.
      end;
    end;
    //end;//with cpi

    if isolated_crossing = True then
      startx := Min(ckx_ms, cuckx) - 3 * scale;
    // 217a  blanking      allow 3ft in front of check rails

    Result := True;  // all done ok. added 0.81

  except
    abandon_calcs := True;    // added 0.81
  end;//try
end;
//_______________________________________________________________________________________________________________________________

function ram_clm_str(ram_kn: double): string;

var
  clm_kn: double;

begin        //  calc CLM unit angle...
  try
    if ram_kn > minfp then
      clm_kn := 1 / 2 / TAN(ARCTAN(1 / ram_kn) / 2)
    else
      clm_kn := 0;                       // ??? kn zero or neg ???

    Result := '1 in ' + FormatFloat('#.00', ram_kn) + ' RAM  ( 1 in ' +
      FormatFloat('#.00', clm_kn) + ' CLM )';
  except
    Result := '';
  end;//try
end;
//______________________________________________________________________________

// 0.93.a ex 081 ...

procedure compile_template_data;   // compile results of calcs.

var
  trans_0rad, trans_orgrad, trans_toerad, trans_heelrad, trans_dprad, trans_txrad,
  trans_fprad, trans_vjrad, trans_9rad: double;
  rcurv_0, rcurv_toe, rcurv_heel, rcurv_dp, rcurv_tx, rcurv_fp, rcurv_vj: double;
  rmin_inch: double;

  rcurv_return, trans_retstartrad, rcurv_retstart, trans_retendrad, rcurv_retend: double;
  // 0.79.a

  slew_rad, slew_minrad, trans_slewrad: double;
  no_zone_str: string;
  num_dec: integer;

  hand_str: string;
  temp1, temp2, temp3: double;
  indent_str, temp_str: string;
  temp_flag: boolean;

  tbstyle_str: string;
  hd_str, reg_hd_str, section_str, vertical_str: string;

  num_rails, num_sl_over, num_sl_full: integer;
  percent_over, tb_roll_mm, dummy1: double;
  dummy_i: integer;
  tb_rolling: boolean;
  tb_roll_str: string;

  pin, pout: Tpex;

  no_info_update_needed: integer;

  dummy_notch1, dummy_notch2, dummy_notch3: Tnotch;

begin
  //081  with cpi do begin
  no_info_update_needed := spot_mod + zoom_mod + zoffset_mod + bunch_mod
    //+notch_mod  out 23-04-05 (needed for peg position from notch)
    + ring_mod + ringdia_mod + ruler1_mod + ruler2_mod + porg_mod + out_factor_mod +
    shift_keeps_mod + twist_keeps_mod + oneshape_shift_mod + corner1_mod +
    corner2_mod + oneshape_scale_mod + allshapes_shift_mod + allshapes_scale_mod +
    allshapes_rotate_mod + move_labels_mod        // 0.82.d

    + rect_left_mod          // 0.93.a ...
    + rect_right_mod + rect_top_mod + rect_bottom_mod + rect_move_mod;

  if no_info_update_needed <> 0 then
    EXIT;     // mouse action in progress is not for control template.

  if check_diffs_form.Showing = True then
    update_check_diff_panels;  // 0.94.a

  rmin_mm := max_rad;            // init for min radius calcs.

  radius_for_obtain := max_rad;  // 205e  init

  info_text_list.Clear;

  temp_flag := False;      // first any top panel warnings...

  if (k3n < (4 - minfp)) and (half_diamond = False) and (plain_track = False) and (g > (4 * scale))
  // 0.93.a not for n.g. 4ft and below
  then begin
    program_help_str := 'The current V-crossing angle is 1 : ' + FormatFloat('#.##', k3n) +
      '||Turnouts shorter than 1 : 4 crossing angle are unusual in standard gauge track, unless there is significant negative curving (Y-turnout).' + ' The radius is likely to be too sharp for normal rolling-stock.' + '||Templot0 allows turnouts with crossing angles down to 1 : 1.5 for narrow-gauge, contractor''s lines, etc.' + ' You will probably need a custom switch for these, and adjustments to the timbering - select the' + ' `0REAL > TIMBERING > TIMBERING DATA...`1 and `0REAL > SHOVE TIMBERS`1 menu items.' + '||If you are seeing this message while using partial templates to create tandem turnouts, slips, etc., you can probably ignore it.';

    pad_form.program_warning_panel.Caption :=
      '1 : ' + FormatFloat('#.##', k3n) + '  V-crossing angle is shorter than 1 : 4';
    temp_flag := True;
  end;

  if (k3n > k2n) and (half_diamond = False) and (plain_track = False)  // 0.93.a  irregular warning
  then begin
    program_help_str := 'The current V-crossing angle is 1 : ' + FormatFloat('#.##', k3n) +
      '||This is flatter than the heel angle of the currently selected switch size.' +
      '||The equivalent turnout-road radius is therefore negative and this very long turnout is unlikely to be of any practical use.' +
      '||You should probably use a longer switch size, or shorten the V-crossing angle to match the current switch size.'
      +
      '||Click the `0TEMPLATE > SWITCH SETTINGS...`1 menu item, or the `0template > V-crossing settings...`z menu item.';
    pad_form.program_warning_panel.Caption :=
      '1 : ' + FormatFloat('#.##', k3n) + '  V-crossing angle is flatter than the switch heel.';
    temp_flag := True;
  end;

  if (temp_flag = True) and (creating_tandem = False) and (gaunt = False)  // 218a
  then begin
    pad_form.program_button.Show;
    pad_form.program_warning_panel.Show;
  end
  else begin
    pad_form.program_warning_panel.Hide;
    pad_form.program_button.Hide;
  end;

  reg_hd_str := '';      // keep compiler happy.

  info_form.gauge_bang_label.Caption := ' ' + Trim(gauge_str) + ' ';        // 216a

  try
    with info_form do begin

      if rail_section = 2        // 0.95.a
      then
        temp_str := ' FB • '
      else
        temp_str := ' BH • ';

      temp_str := temp_str + Trim(gauge_str) + ' ';    // 0.95.a

      { OT-FIRST fv_gauge_str:=temp_str;  // label for file viewer 208d}

      temp_str := temp_str + ' ';  // 208d

      if gauge_i = gauge_form.gauge_listbox.Items.Count - 1 then
        temp_str := temp_str + round_str(scale, 2) + ' mm / ft    ';     // exact scale.

      if plain_track = False then begin
        if half_diamond = True then begin
          temp_str := temp_str + current_switch_name;
          if tradius_is_straight = True then
            reg_hd_str := ' (regular half-diamond)'
          else
            reg_hd_str := ' (irregular half-diamond)';
        end
        else begin
          case csi.group_code of
            1:
              temp_str := temp_str + Copy(current_switch_name, 0, 7);  // straight switches.
            2:
              temp_str := temp_str + Copy(current_switch_name, 0, 18); // REA switches.
            3:
              temp_str := temp_str + Copy(current_switch_name, 0, 14);
            // GWR flexible switches + 30ft straight switch.
            4:
              temp_str := temp_str + Copy(current_switch_name, 0, 16); // GWR heel switches.
            5:
              temp_str := temp_str + Copy(current_switch_name, 0, 21); // FB-109 switches.
            6:
              temp_str := temp_str + Copy(current_switch_name, 0, 20); // FB BS-110A switches.
            else
              temp_str := temp_str + current_switch_name;            // custom switches
          end;//case
        end;

        temp_str := temp_str + '  +  V- ' + FormatFloat('#.##', k3n) + '   ';
      end
      else
        temp_str := temp_str + 'plain track   ';

      case hand_i of
        0:
          temp_str := temp_str + 'Y ';
        1:
          temp_str := temp_str + 'LH ';
        -1:
          temp_str := temp_str + 'RH ';
        else
          run_error(82);
      end;//case

      gauge_label.Caption := temp_str;
      Caption := '   information         ' + temp_str;    // copy to the form caption.
    end;//with info_form

    case hand_i of
      0:
        hand_str := 'unhanded';
      1:
        hand_str := 'left-hand';
      -1:
        hand_str := 'right-hand';
      else
        run_error(82);
    end;//case

    with info_text_list do begin

      // show the main details:

      Add('template generated at ' + TimeToStr(Time) + ' on ' + DateToStr(Date) +
        ' using Templot0 v:' + GetVersionString(voFull));
      Add('scale = ' + round_str(scale, 2) + ' mm/ft     scale ratio = 1:' +
        round_str(304.8 / scale, 2));
      Add('track gauge = ' + round_str(g, 2) + '    flangeway gap = ' + round_str(fw, 2));

      if (ABS(nomrad) > max_rad_test) and (spiral = False) then
        Add('template: straight')
      else
      if spiral = False then
        Add('template: curved (constant radius)')
      else
        Add('template: curved (transition)');

      if (plain_track = True) and (no_timbering = True) then
        Add('no timbering');

      if vertical_rails = True then
        vertical_str := 'rails vertical'
      else
        vertical_str := 'rails inclined at ' + round_str(rail_inclination * 180 / Pi, 2) +
          ' degrees';

      case rail_section of
        0:
          section_str := 'no rails';
        1:
          section_str := 'rail head only (bullhead): ' + vertical_str;
        2:
          section_str := 'rail head and foot (flatbottom): ' + vertical_str;
        else
          section_str := '';
      end;//case

      Add(section_str);

      Add('------------');

      case hand_i of
        0:
          temp_str := 'Y ';
        1:
          temp_str := 'LH ';
        -1:
          temp_str := 'RH ';
        else
          run_error(36);
      end;//case

      if (plain_track = False) and (half_diamond = False) then begin
        if gaunt = True then
          Add(temp_str + 'gaunt turnout:')
        else
          Add(temp_str + 'turnout:');
      end
      else
      if half_diamond = True then begin
        if tradius_is_straight = True then
          hd_str := 'regular'
        else
          hd_str := 'irregular';

        if fixed_diamond = True then
          Add(temp_str + hd_str + ' half-diamond, fixed K-crossings (fixed diamond):')
        else
          Add(temp_str + hd_str + ' half-diamond, movable K-crossings (switch-diamond):');
      end
      else
        Add(temp_str + 'plain track in' +
          plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i] +
          ' ( rail length = ' + round_str(railen[pt_i] * inscale, 2) + ' ):');

      if plain_track = False then begin
        if half_diamond = False then begin
          if joggled = True then
            temp_str := '(joggled)'
          else
            temp_str := '(unjoggled)';

          if gaunt = True then
            temp_str := temp_str + ', gaunt offset = ' + round_str(gaunt_offset_in * inscale, 2);

          case hand_i of
            0:
              Add(current_switch_name + ' split-symmetrical switch ' + temp_str);
            1:
              Add(current_switch_name + ' left-hand switch ' + temp_str);
            -1:
              Add(current_switch_name + ' right-hand switch ' + temp_str);
            else
              run_error(36);
          end;//case
        end;

        temp_str := ram_clm_str(k3n);

        case xing_type_i of
          0: begin
            temp_str := temp_str + ' regular V-crossing';
            if retpar_i = 1 then
              temp_str := temp_str + ' (returning parallel)';
          end;
          -1: begin
            temp_str := temp_str + ' generic V-crossing';
            if retpar_i = 1 then
              temp_str := temp_str + ' (returning parallel)';
          end;

          1:
            temp_str := temp_str + ' curviform V-crossing';

          else
            run_error(48);

        end;//case

        if (xing_type_i <> 0) and (tradius_is_straight = True) then begin
          if half_diamond = True then
            temp_str := temp_str + ' (converted to regular crossing for regular half-diamond)'
          else
            temp_str := temp_str +
              ' (converted to regular crossing because turnout-curve is straight)';
        end;

        Add(temp_str);

        if half_diamond = True then
          Add(ram_clm_str(k1n) + ' K-crossing');

        //Add('entry straight (curve-end to fine point) = '+round_str(sl,2));
        //Add('wing rail length = '+round_str(wgl,2)+'    check rail length = '+round_str(ckl,2) );

        if no_timbering = True then
          tbstyle_str := 'no'
        else begin
          if half_diamond = True then
            tbstyle_str := 'equalized-constant'
          else begin
            if timbers_equalized = False then begin
              if square_on_angled = True then
                tbstyle_str := 'angled-on'
              else
                tbstyle_str := 'square-on';
            end
            else begin
              if equalizing_fixed = True then
                tbstyle_str := 'equalized-constant'
              else
                tbstyle_str := 'equalized-incremental';
            end;
          end;
        end;
        Add(tbstyle_str + ' timbering');
      end;

      if slewing = True then begin
        Add('------------');
        Add('N.B. this template includes SLEWING for all or part of its length');
        Add('the radius figures quoted below do not apply');
        Add('within the slewing zone except where stated');

        if (plain_track = False) and (half_diamond = False) then begin
          Add('');
          Add('the figures quoted below for the switch and turnout radii,');
          Add('and for the smallest radius on this template, do not apply');
          Add('if any part of the turnout lead overlaps the slewing zone');
        end;

        if (plain_track = False) and (half_diamond = True) then begin
          Add('');
          Add('the figures quoted below for the diagonal-road radius,');
          Add('and for the smallest radius on this template, do not apply');
          Add(
            'if any part of the half-diamond lead overlaps the slewing zone');
        end;
      end;

      if ((ABS(nomrad) < max_rad_test) or (spiral = True)) and (plain_track = False)
      // do calcs for approx radius in turnout road and limit checks...
      then begin
        // curved template
        Add('------------');
        if spiral = False    // fixed curve.
        then begin
          //Add('base line radius = '+rad_str(nomrad,2));
          //Add('offset from the base line to the track centre-line = '+round_str(ycurv,2));
          //Add('');
          Add('main-road centre-line radius = ' + rad_str(clrad1, 2) + ' (constant radius)');

          if half_diamond = False then begin
            rcurv_toe := curved_onto_calc(equiv_rad - g / 2, clrad1);

            rcurv_heel :=
              calculate_turnout_radius(clrad1, dummy_notch1, dummy_notch2, dummy_notch3);
            // 218a    rcurv_heel:=curved_onto_calc(tradius-g/2,clrad1);    //^^^

            Add('resultant switch radius (centre-line) = ' + rad_str(rcurv_toe, 0) + ' approx.');

            if gaunt = True then
              Add('resultant gaunt turnout radius (centre-line) = ' + rad_str(
                curved_onto_calc(tradius - g / 2, clrad1), 0) + ' approx.')
            // so info matches obtain-for-gaunt info
            else
              Add('resultant turnout radius (centre-line) = ' + rad_str(rcurv_heel, 2));

            if rmin_mm > ABS(rcurv_toe) then
              rmin_mm := ABS(rcurv_toe);
            if rmin_mm > ABS(rcurv_heel) then
              rmin_mm := ABS(rcurv_heel);

            radius_for_obtain := rcurv_heel;  // 205e

          end
          else begin
            if tradius_is_straight = True then begin
              Add(
                'diagonal-road centre-line radius = ' + rad_str(clrad1, 2) + reg_hd_str);

              radius_for_obtain := clrad1;  // 205e
            end
            else begin
              rcurv_heel :=
                calculate_turnout_radius(clrad1, dummy_notch1, dummy_notch2, dummy_notch3);
              // 218a    rcurv_heel:=curved_onto_calc(tradius-g/2,clrad1);
              Add('resultant diagonal-road centre-line radius = ' +
                rad_str(rcurv_heel, 2) + reg_hd_str);
              if rmin_mm > ABS(rcurv_heel) then
                rmin_mm := ABS(rcurv_heel);

              radius_for_obtain := rcurv_heel;  // 205e
            end;
          end;

          if retpar_i = 1      // parallel V-crossing  0.79.a
          then begin
            rcurv_return := curved_onto_calc(retr, 0 - clrad1);
            //  (opposite sense, so 0-)
            if rmin_mm > ABS(rcurv_return) then
              rmin_mm := ABS(rcurv_return);
            Add('resultant return curve radius (centre-line) = ' +
              rad_str(rcurv_return, 0) + ' approx.');
            Add('');
            Add('loop radius beyond return curve (centre-line) = ' + rad_str(
              (clrad1 - trtscent), 2));
            if rmin_mm > ABS(clrad1 - trtscent) then
              rmin_mm := ABS(clrad1 - trtscent);      // 0.79.a
          end;

          if rmin_mm > ABS(clrad1) then
            rmin_mm := ABS(clrad1);

        end
        else begin      // transition curve.
          if half_diamond = False then begin
            docurving(False, True, 0, g / 2, temp1, temp2, temp3, trans_0rad);
            // get curving radius at Ctrl-0 datum.
            docurving(False, True, xorg, g / 2, temp1,
              temp2, temp3, trans_orgrad);
            // get curving radius at toe joint.
            docurving(False, True, toex, g / 2, temp1,
              temp2, temp3, trans_toerad);
            // get curving radius at toe.
            docurving(False, True, heelx, g / 2, temp1,
              temp2, temp3, trans_heelrad); // get curving radius at switch heel.
            docurving(False, True, dpx, g / 2, temp1,
              temp2, temp3, trans_dprad);
            // get curving radius at deflection point.
            docurving(False, True, fpx, g / 2, temp1,
              temp2, temp3, trans_fprad);
            // get curving radius at fine point.
            docurving(False, True, mvjpx, g / 2, temp1,
              temp2, temp3, trans_vjrad);
            // get curving radius at vee joint.
            docurving(False, True, turnoutx, g / 2,
              temp1, temp2, temp3, trans_9rad); // get curving radius at Ctrl-9 rail end.

            rcurv_toe := curved_onto_calc(equiv_rad - g / 2, trans_toerad);
            // calc approx curved radii...
            rcurv_heel := curved_onto_calc(tradius - g / 2, trans_heelrad);
            //^^^
            if dpx > heelx then
              rcurv_dp := curved_onto_calc(tradius - g / 2, trans_dprad)  //^^^
            else
              rcurv_dp := curved_onto_calc(equiv_rad - g / 2, trans_dprad);

            if xing_calc_i <> 0
            // turnout - curved or generic crossing..
            then begin
              trans_txrad := nomrad1;    // keep compiler happy.
              rcurv_tx := nomrad1;       // keep compiler happy.

              rcurv_fp :=
                curved_onto_calc(tradius - g / 2, trans_fprad);   //^^^
              rcurv_vj :=
                curved_onto_calc(tradius - g / 2, trans_vjrad);   //^^^
            end
            else begin     // regular crossing...
              docurving(
                False, True, tx, g / 2, temp1, temp2, temp3, trans_txrad);
              // get curving radius at curve end point.
              rcurv_tx :=
                curved_onto_calc(tradius - g / 2, trans_txrad);   //^^^
              rcurv_fp := trans_fprad;
              rcurv_vj := trans_vjrad;
            end;

            Add(hand_str + ' transition curve :');
            Add('main-road centre-line radius at datum (CTRL-0) = ' + rad_str(trans_0rad, 2));
            Add('main-road centre-line radius at switch front (CTRL-1) = ' +
              rad_str(trans_orgrad, 2));
            Add('');
            Add('main-road centre-line radius at toe (CTRL-2) = ' + rad_str(trans_toerad, 2));
            Add('resultant turnout-road radius at toe (CTRL-2) = ' +
              rad_str(rcurv_toe, 0) + ' approx.');
            Add('');
            Add('main-road centre-line radius at switch heel = ' + rad_str(trans_heelrad, 2));
            Add('resultant turnout-road radius at switch heel = ' +
              rad_str(rcurv_heel, 0) + ' approx.');
            Add('');
            Add(
              'main-road centre-line radius at deflection point (CTRL-3) = ' +
              rad_str(trans_dprad, 2));
            Add(
              'resultant turnout-road radius at deflection point (CTRL-3) = ' +
              rad_str(rcurv_dp, 0) + ' approx.');
            Add('');

            if xing_calc_i = 0  // regular crossing..
            then begin
              Add(
                'main-road centre-line radius at end of turnout curve (CESP) = ' +
                rad_str(trans_txrad, 2));
              Add(
                'resultant turnout-road radius at end of turnout curve (CESP) = ' +
                rad_str(rcurv_tx, 0) + ' approx.');
              Add('');
            end;

            Add('main-road centre-line radius at fine point (CTRL-4) = ' +
              rad_str(trans_fprad, 2));
            Add('resultant turnout-road radius at fine point (CTRL-4) = ' +
              rad_str(rcurv_fp, 0) + ' approx.');
            Add('');
            Add(
              'main-road centre-line radius at vee joint (CTRL-8) = ' + rad_str(trans_vjrad, 2));
            Add('resultant turnout-road radius at vee joint (CTRL-6) = ' +
              rad_str(rcurv_vj, 0) + ' approx.');
            Add('');
            Add('main-road centre-line radius at full length (CTRL-9) = ' +
              rad_str(trans_9rad, 2));

            if spiral = False
            // bug fix mods 214a ...  // don't include radius at TOE or HEEL if a short transition is near (confusing result, radius shown may apply to only a few mm)
            then begin
              if rmin_mm > ABS(rcurv_toe) then
                rmin_mm := ABS(rcurv_toe);
              if rmin_mm > ABS(rcurv_heel) then
                rmin_mm := ABS(rcurv_heel);
            end
            else begin
              if (os < (toex - scale * 3)) or
                (os > (toex + scale * 3))                // 3ft arbitrary closeness of a zone end
                or ((os + tst) < (toex - scale * 3)) or ((os + tst) > (toex + scale * 3)) then
                if rmin_mm > ABS(rcurv_toe) then
                  rmin_mm := ABS(rcurv_toe);

              if (os < (heelx - scale * 3)) or
                (os > (heelx + scale * 3))              // 3ft arbitrary closeness of a zone end
                or ((os + tst) < (heelx - scale * 3)) or ((os + tst) > (heelx + scale * 3)) then
                if rmin_mm > ABS(rcurv_heel) then
                  rmin_mm := ABS(rcurv_heel);
            end;

            if rmin_mm > ABS(rcurv_dp) then
              rmin_mm := ABS(rcurv_dp);

            if (spiral = False) or (xing_calc_i = 1)
            // bug fix mods 214a ...  // don't include radius at CESP or FP if not curviform and a short transition is near (confusing result, radius shown may apply to only a few mm)
            then begin
              if (xing_calc_i = 0) and (rmin_mm > ABS(rcurv_tx)) then
                rmin_mm := ABS(rcurv_tx);   // CESP regular crossing
              if rmin_mm > ABS(rcurv_fp) then
                rmin_mm := ABS(rcurv_fp);
            end
            else begin
              if (os < (tx - scale * 3)) or
                (os > (fpx + scale * 3))              // 3ft arbitrary closeness of a zone end
                or ((os + tst) < (tx - scale * 3)) or ((os + tst) > (fpx + scale * 3)) then begin
                if (xing_calc_i = 0) and (rmin_mm > ABS(rcurv_tx)) then
                  rmin_mm := ABS(rcurv_tx);   // CESP regular crossing
                if rmin_mm > ABS(rcurv_fp) then
                  rmin_mm := ABS(rcurv_fp);
              end;
            end;

            if rmin_mm > ABS(rcurv_vj) then
              rmin_mm := ABS(rcurv_vj);

            if rmin_mm > ABS(trans_0rad) then
              rmin_mm := ABS(trans_0rad);
            if rmin_mm > ABS(trans_orgrad) then
              rmin_mm := ABS(trans_orgrad);
            if rmin_mm > ABS(trans_toerad) then
              rmin_mm := ABS(trans_toerad);
            if rmin_mm > ABS(trans_heelrad) then
              rmin_mm := ABS(trans_heelrad);
            if rmin_mm > ABS(trans_dprad) then
              rmin_mm := ABS(trans_dprad);
            if (xing_calc_i = 0) and (rmin_mm > ABS(trans_txrad)) then
              rmin_mm := ABS(trans_txrad);
            if rmin_mm > ABS(trans_fprad) then
              rmin_mm := ABS(trans_fprad);
            if rmin_mm > ABS(trans_vjrad) then
              rmin_mm := ABS(trans_vjrad);
            if rmin_mm > ABS(trans_9rad) then
              rmin_mm := ABS(trans_9rad);

          end
          else begin  // half-diamond...
            docurving(False, True, 0, g / 2, temp1, temp2, temp3, trans_0rad);
            // get curving radius at datum.
            docurving(False, True, fpx, g / 2, temp1,
              temp2, temp3, trans_fprad);
            // get curving radius at fine point.
            docurving(False, True, mvjpx, g / 2, temp1,
              temp2, temp3, trans_vjrad);
            // get curving radius at vee joint.
            docurving(False, True, turnoutx, g / 2,
              temp1, temp2, temp3, trans_9rad); // get curving radius at Ctrl-9 rail end.

            rcurv_0 := curved_onto_calc(tradius - g / 2, trans_0rad);

            if xing_calc_i <> 0
            // half-diamond - curved or generic crossing (irregular)...
            then begin
              trans_txrad := nomrad1;    // keep compiler happy.
              rcurv_tx := nomrad1;       // keep compiler happy.

              rcurv_fp :=
                curved_onto_calc(tradius - g / 2, trans_fprad);   //^^^
              rcurv_vj :=
                curved_onto_calc(tradius - g / 2, trans_vjrad);   //^^^
            end
            else begin     // regular crossing    (irregular hd) ...
              docurving(
                False, True, tx, g / 2, temp1, temp2, temp3, trans_txrad);
              // get curving radius at curve end point.
              rcurv_tx :=
                curved_onto_calc(tradius - g / 2, trans_txrad);   //^^^
              rcurv_fp := trans_fprad;
              rcurv_vj := trans_vjrad;
            end;

            Add(hand_str + ' transition curve' + reg_hd_str + ' :');
            Add('main-road centre-line radius at K-crossing (CTRL-0) = ' + rad_str(trans_0rad, 2));
            Add('resultant diagonal-road radius at K-crossing (CTRL-0) = ' +
              rad_str(rcurv_0, 0) + ' approx.');
            Add('');

            if xing_calc_i = 0  // regular crossing..
            then begin
              Add(
                'main-road centre-line radius at end of diamond curve (CESP) = ' +
                rad_str(trans_txrad, 2));
              Add(
                'resultant diagonal-road radius at end of diamond curve (CESP) = ' +
                rad_str(rcurv_tx, 0) + ' approx.');
              Add('');
            end;

            Add('main-road centre-line radius at fine point (CTRL-4) = ' +
              rad_str(trans_fprad, 2));
            Add('resultant diagonal-road radius at fine point (CTRL-4) = ' +
              rad_str(rcurv_fp, 0) + ' approx.');
            Add('');
            Add(
              'main-road centre-line radius at vee joint (CTRL-8) = ' + rad_str(trans_vjrad, 2));
            Add('resultant diagonal-road radius at vee joint (CTRL-6) = ' +
              rad_str(rcurv_vj, 0) + ' approx.');
            Add('');
            Add('main-road centre-line radius at full length (CTRL-9) = ' +
              rad_str(trans_9rad, 2));

            if rmin_mm > ABS(rcurv_0) then
              rmin_mm := ABS(rcurv_0);

            if (spiral = False) or (xing_calc_i = 1)
            // bug fix mods 214a ...  // don't include radius at CESP or FP if not curviform and a short transition is near (confusing result, radius shown may apply to only a few mm)
            then begin
              if (xing_calc_i = 0) and (rmin_mm > ABS(rcurv_tx)) then
                rmin_mm := ABS(rcurv_tx);   // CESP regular crossing
              if rmin_mm > ABS(rcurv_fp) then
                rmin_mm := ABS(rcurv_fp);
            end
            else begin
              if (os < (tx - scale * 3)) or
                (os > (fpx + scale * 3))                // 3ft arbitrary closeness of a zone end
                or ((os + tst) < (tx - scale * 3)) or ((os + tst) > (fpx + scale * 3)) then begin
                if (xing_calc_i = 0) and (rmin_mm > ABS(rcurv_tx)) then
                  rmin_mm := ABS(rcurv_tx);   // CESP regular crossing
                if rmin_mm > ABS(rcurv_fp) then
                  rmin_mm := ABS(rcurv_fp);
              end;
            end;

            if rmin_mm > ABS(rcurv_vj) then
              rmin_mm := ABS(rcurv_vj);
            if rmin_mm > ABS(trans_0rad) then
              rmin_mm := ABS(trans_0rad);
            if (xing_calc_i = 0) and (rmin_mm > ABS(trans_txrad)) then
              rmin_mm := ABS(trans_txrad);
            if rmin_mm > ABS(trans_fprad) then
              rmin_mm := ABS(trans_fprad);
            if rmin_mm > ABS(trans_vjrad) then
              rmin_mm := ABS(trans_vjrad);
            if rmin_mm > ABS(trans_9rad) then
              rmin_mm := ABS(trans_9rad);
          end;


          if retpar_i = 1   // parallel crossing. 0.79.a  ...
          then begin
            Add('');

            docurving(False, True, retx, g / 2, temp1,
              temp2, temp3, trans_retstartrad);   // get curving radius at start of return curve.
            docurving(False, True, mrpx, g / 2, temp1,
              temp2, temp3, trans_retendrad);     // end of ditto.

            rcurv_retstart := curved_onto_calc(retr, 0 - trans_retstartrad);
            // calc approx return curve radii (opposite sense, so 0-)...
            rcurv_retend := curved_onto_calc(retr, 0 - trans_retendrad);

            Add(
              'main-road track centre-line radius at start of return curve = ' +
              rad_str(trans_retstartrad, 2));
            Add('resultant return curve radius at start of return curve = ' +
              rad_str(rcurv_retstart, 0) + ' approx.');
            Add('');

            Add(
              'main-road track centre-line radius at end of return curve = ' +
              rad_str(trans_retendrad, 2));
            Add('resultant return curve radius at end of return curve = ' +
              rad_str(rcurv_retend, 0) + ' approx.');
            Add('loop radius at end of return curve = ' + rad_str(trans_retendrad - trtscent, 2));
            Add('loop radius at full length = ' + rad_str(trans_9rad - trtscent, 2));
            Add('');

            if rmin_mm > ABS(rcurv_retstart) then
              rmin_mm := ABS(rcurv_retstart);
            if rmin_mm > ABS(rcurv_retend) then
              rmin_mm := ABS(rcurv_retend);

            if rmin_mm > ABS(trans_retstartrad) then
              rmin_mm := ABS(trans_retstartrad);
            if rmin_mm > ABS(trans_retendrad) then
              rmin_mm := ABS(trans_retendrad);

            if rmin_mm > ABS(trans_retendrad - trtscent) then
              rmin_mm := ABS(trans_retendrad - trtscent);  // loop radius at TRP.
            if rmin_mm > ABS(trans_9rad - trtscent) then
              rmin_mm := ABS(trans_9rad - trtscent);  // ditto at far end.

          end;

        end;
      end
      else begin                       // not a curved template...
        if plain_track = False then begin
          // straight turnout..
          if (half_diamond = False) and (rmin_mm > ABS(equiv_rad - g / 2)) then
            rmin_mm := ABS(equiv_rad - g / 2);

          if rmin_mm > ABS(tradius - g / 2) then
            rmin_mm := ABS(tradius - g / 2);             //^^^


          radius_for_obtain := tradius - g / 2;  // 205e

        end
        else begin                 // plain track...
          //Add('------------');

          Add('overall length = ' + round_str(turnoutx, 2));

          //Add('in'+plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i]);

          if tb_roll_percent > minfp then begin
            tb_roll_mm := tb_roll_percent * railen[pt_i] * inscale / 100;
            // timber rolling.
            tb_rolling := True;
            tb_roll_str := 'rolled-out length from rail joint';
          end
          else begin
            tb_roll_mm := 0;
            tb_rolling := False;
            tb_roll_str := 'overall length';
          end;

          if (rails_sleepers(railen[pt_i] * inscale - 0.01, dummy_i, num_sl_full, dummy1) =
            True)  // get full length sleeper count (0.01mm arbitrary).
            and (rails_sleepers(turnoutx - tb_roll_mm, num_rails, num_sl_over, percent_over) =
            True) then begin
            Add(tb_roll_str + ' = ' + IntToStr(num_rails) + ' full rail lengths + ' +
              IntToStr(num_sl_over) + ' sleepers in ' + round_str(percent_over, 2) +
              ' % of a rail length');
            if percent_over > minfp then
              Add('(to the next rail joint from CTRL-0 requires ' +
                IntToStr(num_sl_full - num_sl_over) + ' sleepers in ' +
                round_str(100 - percent_over, 2) + ' % of a rail length)');

            if tb_rolling = True then begin
              if rails_sleepers(tb_roll_mm - 0.0001, dummy_i, num_sl_over, percent_over) = True
              //-0.0001 mm arbitrary to ensure shows 100% of a rail.
              then begin
                Add('');
                Add(
                  'rolled-in length to rail joint' + ' = ' + IntToStr(num_sl_over) +
                  ' sleepers in ' + round_str(percent_over, 2) + ' % of a rail length');
                if percent_over > minfp then
                  Add('(to the next rail joint from CTRL-1 requires ' +
                    IntToStr(num_sl_full - num_sl_over) + ' sleepers in ' +
                    round_str(100 - percent_over, 2) + ' % of a rail length)');
              end;
            end;

          end;
          Add('');

          if (ABS(nomrad) < max_rad_test) or (spiral = True) then begin
            if spiral = True              // transition plain track.
            then begin
              docurving(
                False, True, 0, g / 2, temp1, temp2, temp3, trans_0rad);
              // get curving radius at datum end.
              docurving(
                False, True, xorg, g / 2, temp1, temp2, temp3, trans_orgrad);
              // get curving radius at joint end.
              Add(hand_str + ' transition curve :');
              Add('track centre-line radius at datum end (CTRL-0) = ' + rad_str(trans_0rad, 2));
              Add('track centre-line radius at joint end (CTRL-1) = ' + rad_str(trans_orgrad, 2));

              if rmin_mm > ABS(trans_0rad) then
                rmin_mm := ABS(trans_0rad);
              if rmin_mm > ABS(trans_orgrad) then
                rmin_mm := ABS(trans_orgrad);
            end
            else begin
              Add(
                hand_str + ' constant curve : track centre-line radius = ' + rad_str(clrad1, 2));
              rmin_mm := ABS(clrad1);
              // fixed radius plain track.
            end;
          end
          else begin
            Add('straight plain track');
            rmin_mm := max_rad;            // straight plain track.
          end;
        end;//plain track
      end;//not a curved template

      if slewing = True then begin

        Add('------------');
        Add('slewing data ( slew mode ' + IntToStr(slew_mode) + ' ) :');
        Add('');
        Add('slewing zone start = ' + round_str(slew_s, 2));
        Add('slewing zone length = ' + round_str(slew_l, 2));
        Add('amount of slew = ' + round_str(slew, 2));
        Add('');

        if slew_mode = 1 then begin
          if ABS(slew) > minfp then
            slew_rad := 2 * SQR(slew_l) / slew / SQR(Pi)
          // (sign of rad is for start end of slew, slew amount is +ve towards the hand).
          else
            slew_rad := max_rad;                     // shouldn't get here !!!

          Add('nominal slewing radius (on straight track) = ' + rad_str(ABS(slew_rad), 2));

          if (ABS(nomrad) < max_rad_test) or (spiral = True) then begin
            if spiral = False     // fixed radius...
            then begin
              slew_minrad := curved_onto_calc(slew_rad, clrad1);
              Add(
                'resultant slewing radius after curving (at start of slewing zone) = ' +
                rad_str(slew_minrad, 2) + ' approx.');
              if rmin_mm > ABS(slew_minrad) then
                rmin_mm := ABS(slew_minrad);

              slew_minrad :=
                curved_onto_calc((0 - slew_rad), clrad1);
              Add(
                'resultant slewing radius after curving (at end of slewing zone) = ' +
                rad_str(slew_minrad, 2) + ' approx.');
              if rmin_mm > ABS(slew_minrad) then
                rmin_mm := ABS(slew_minrad);

            end
            else begin       // transition...

              docurving(
                False, True, slew_s, g / 2, temp1, temp2, temp3, trans_slewrad);
              // get curving radius slew start.
              slew_minrad :=
                curved_onto_calc(slew_rad, trans_slewrad);
              Add(
                'resultant slewing radius after curving (at start of slewing zone) = ' +
                rad_str(slew_minrad, 2) + ' approx.');
              if rmin_mm > ABS(slew_minrad) then
                rmin_mm := ABS(slew_minrad);

              docurving(False, True,
                (slew_s + slew_l), g / 2, temp1, temp2, temp3, trans_slewrad);
              // get curving radius at slew end.
              slew_minrad :=
                curved_onto_calc((0 - slew_rad), trans_slewrad);
              Add(
                'resultant slewing radius after curving (at end of slewing zone) = ' +
                rad_str(slew_minrad, 2) + ' approx.');
              if rmin_mm > ABS(slew_minrad) then
                rmin_mm := ABS(slew_minrad);
            end;
          end;
        end
        else begin
          Add('slewing radii not available ( slew mode 2 )');
          Add('mode 2 slewing factor = ' + round_str(slew2_kmax * 50, 2));
        end;
      end;

      if (trtscent <> 0) or (trmscent <> 0) then begin
        Add('------------');
        Add('adjacent track centres main side = ' + round_str(trmscent, 2));
        Add('adjacent track centres turnout side = ' + round_str(trtscent, 2));
        if {(xing_type=1) and (straight_tradius=False) and}
        plain_track = False then begin
          //Add('curviform crossing:');
          Add('angle at TXP crossover mid-point (CTRL-5) = ' +
            round_str(txpk * 180 / Pi, 2) + ' degrees' + k_ram_str(txpk));
          Add('angle at TVJP turnout road vee joint (CTRL-6) = ' +
            round_str(tvjpk * 180 / Pi, 2) + ' degrees' + k_ram_str(tvjpk));
        end;
      end;

      if (retpar_i = 1) and (plain_track = False) then
        Add('turnout road centres for parallel crossing = ' + round_str(trtscent, 2));

      if plain_track = False then
        Add('------------');

      if ((ABS(nomrad) < max_rad_test) or (spiral = True)) and (plain_track = False) then begin
        Add('equivalent straight template dimensions BEFORE curving :');
        Add('');
        indent_str := '        ';
      end
      else
        indent_str := '';

      if plain_track = False then begin
        Add(indent_str + 'overall length = ' + round_str(turnoutx, 2));

        if half_diamond = False then begin
          Add(indent_str + 'approach/exit track in' +
            plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i] +
            ' ( rail length = ' + round_str(railen[pt_i] * inscale, 2) + ' ):');
          if xorg > 0 then begin
            if rails_sleepers(xorg, num_rails, num_sl_over, percent_over) = True then
              Add(indent_str + 'approach track length = ' + round_str(xorg, 2) +
                '  ( ' + IntToStr(num_rails) + ' full rail lengths + ' +
                IntToStr(num_sl_over) + ' sleepers in ' + round_str(percent_over, 2) +
                ' % of a rail length )');
          end
          else
            Add(indent_str + 'approach track length = 0');
        end
        else
          Add(indent_str + 'exit track in' +
            plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i] +
            ' ( rail length = ' + round_str(railen[pt_i] * inscale, 2) + ' ):');

        if turnoutx > (mvjpx + minfp)   // exit length
        then begin
          if rails_sleepers(turnoutx - mvjpx, num_rails, num_sl_over, percent_over) = True then
            Add(indent_str + 'exit track length = ' + round_str(turnoutx - mvjpx, 2) +
              '  ( ' + IntToStr(num_rails) + ' full rail lengths + ' +
              IntToStr(num_sl_over) + ' sleepers in ' + round_str(percent_over, 2) +
              ' % of a rail length )');
        end
        else
          Add(indent_str + 'exit track length = 0');

        if half_diamond = False then begin
          Add('');
          Add(indent_str + 'turnout-road centre-line radius (at turnout-curve) = ' +
            rad_str(tradius - g / 2, 2));

          Add('');
          if swrad >= max_rad_test then
            Add(indent_str + 'nominal switch-curve radius (rail gauge-face) = ' +
              rad_str(equiv_rad, 2) + '  (straight switch)')
          else
            Add(indent_str + 'switch-curve radius (rail gauge-face) = ' + rad_str(swrad, 2));
          Add(indent_str + 'turnout-curve radius (rail gauge-face) = ' + rad_str(tradius, 2));

          Add(indent_str + 'switch-curve radial centre: X = ' + round_str(sworgx, 2) +
            '  Y = ' + round_str(sworgy - g / 2, 2) + '  (from CTRL-0)');
          Add(indent_str + 'turnout-curve radial centre: X = ' + round_str(torgx, 2) +
            '  Y = ' + round_str(torgy - g / 2, 2) + '  (from CTRL-0)');
        end
        else begin
          Add('');
          if tradius_is_straight = True then
            Add(indent_str + 'diagonal-road centre-line radius = straight' + reg_hd_str)
          else begin
            Add(indent_str + 'diagonal-road centre-line radius = ' +
              rad_str(tradius - g / 2, 2) + reg_hd_str);

            Add('');
            Add(
              indent_str + 'diagonal-curve radius (rail gauge-face) = ' + rad_str(tradius, 2));
            Add(indent_str + 'diagonal-curve radial centre: X = ' +
              round_str(torgx, 2) + '  Y = ' + round_str(torgy - g / 2, 2) + '  (from CTRL-0)');
          end;
        end;

        if xing_calc_i <> 1   // straight or generic crossing..
        then begin
          Add(indent_str + 'V-crossing entry-straight (curve-end to fine-point) = ' +
            round_str(sl, 2));
          if retpar_i = 1 then
            Add(indent_str + 'return-curve radius (track centre) = ' + rad_str(retr, 2));
        end;
        Add('');
        if half_diamond = False then begin
          Add(indent_str + 'switch front (rail-joint to switch-toe) = ' +
            round_str(toex - xorg, 2));
          Add(indent_str + 'virtual lead (switch-toe to fine-point) = ' +
            round_str(fpx - toex, 2));
          Add(indent_str + 'actual lead (switch-toe to blunt nose) = ' + round_str(bnx - toex, 2));
        end
        else begin
          Add(indent_str + 'half-diamond main-road inter-length (CTRL-0 to MCP) = ' +
            round_str(fpx, 2));
          Add(indent_str + 'half-diamond virtual lead (K-crossing to fine-point) = ' +
            round_str(fpx - setx, 2));
          Add(indent_str + 'half-diamond actual lead (K-crossing to blunt nose) = ' +
            round_str(bnx - setx, 2));
        end;

        Add('');
        case knuckle_code of
          -1:
            Add(indent_str + 'knuckle bend = sharp');
          0:
            Add(indent_str + 'knuckle bend radius (normal) = ' + round_str(knuck_rad, 2));
          1:
            Add(indent_str + 'knuckle bend radius (custom) = ' + round_str(knuck_rad, 2));
        end;//case

        Add(indent_str + 'blunt nose to timber A = ' + round_str(bn_to_a * inscale, 2));
        Add(indent_str + 'width of blunt nose = ' + round_str(bn_wide * inscale, 2));
        Add('');
        Add(indent_str + 'wing rail reach length (main-side) = ' + round_str(wgl_ms, 2));
        Add(indent_str + 'wing rail reach length (turnout-side) = ' + round_str(wgl_ts, 2));
        Add(indent_str + 'check rail overall length (main-side) = ' + round_str(ckl_ms, 2));
        Add(indent_str + 'check rail overall length (turnout-side) = ' + round_str(ckl_ts, 2));
      end;

      if spiral = True then begin
        Add('------------');
        Add('transition curve data :');
        Add('');
        Add('initial radius at the track centre-line = ' + rad_str(clrad1, 2));
        Add('final radius at the track centre-line = ' + rad_str(clrad2, 2));
        Add('length along the initial radius = ' + round_str(os, 2) +
          ' (at the track centre-line)');
        Add('length along transition section = ' + round_str(tst, 2) +
          ' (at the track centre-line)');
        Add('spiral constant = ' + round_str(trans_k / 1.0E6, 4) + ' (at the track centre-line)');
      end;
    end;//with info_text_list

    smallest_radius := ABS(rmin_mm); // 208a  goes into file for displaying box data

    with info_form do begin
      limit_rad_label.Caption := round_str(min_radius, 0) + ' mm';  // in case it is default.
      num_dec := 1;
      rmin_inch := ABS(rmin_mm / 25.4);
      if rmin_inch > 100 then
        num_dec := 0;       //  don't show fractional inches over 100".
      if ABS(rmin_mm) >= max_rad_test then
        min_rad_now_label.Caption := 'straight'
      else
        min_rad_now_label.Caption :=
          round_str(rmin_mm, 0) + ' mm ( ' + round_str(rmin_inch, num_dec) + ' " )';

      if ABS(rmin_mm) < (ABS(min_radius) - 0.5)
      //  set the minimum radius warning lamp.  // 0.98.b  -0.5 to prevent display anomolies
      then begin
        min_rad_warn := 1;
        min_rad_now_label.Font.Color := clRed;
        min_rad_lamp_panel.Color := clRed;
      end
      else begin
        min_rad_warn := 0;
        min_rad_now_label.Font.Color := clBlue;
        min_rad_lamp_panel.Color := clLime;
      end;
    end;//with info_form

    with info_text_list do begin
      Add('------------');

      if (slewing = True) and (plain_track = False) then
        no_zone_str := ' (except within the slewing zone)'
      else
        no_zone_str := '';

      Add('smallest radius on this template' + no_zone_str + ' = ' +
        info_form.min_rad_now_label.Caption);

      docurving(True, True, 0, g / 2, temp1, temp2, swing_0, temp3);
      // calc the total swing...
      docurving(True, True, turnoutx, g / 2, temp1, temp2, swing_9, temp3);
      total_swing := swing_9 - swing_0;

      if plain_track = True then
        temp_str := ''
      else
        temp_str := ' (in main road)';

      Add('total angular swing on this template = ' + round_str(total_swing * 180 / Pi, 2) +
        ' degrees' + k_ram_str(total_swing) + temp_str);
      Add('------------');
      Add('nominal gauge :  ' + gauge_form.gauge_listbox.Items.Strings[gauge_i]);

      Add('------------');
      Add('template location on trackpad :');
      Add('');
      Add('rotation :  X = ' + round_str(xform, 2) + '   Y = ' + round_str(
        yform * hand_i + y_datum, 2) + '   K = ' + round_str(kform * hand_i * 180 / Pi, 2) +
        ' degrees' + k_ram_str(kform * hand_i));
      Add('   shift :  X = ' + round_str(xshift, 2) + '   Y = ' + round_str(yshift * hand_i, 2));
      Add('rail-end :  X = ' + round_str(datumx_on_pad, 2) + '   Y = ' +
        round_str(datumy_on_pad * hand_i + y_datum, 2));

      Add('');
      Add('peg from origin :  X = ' + round_str(pegx_on_pad, 2) + '   Y = ' +
        round_str(pegy_on_pad * hand_i + y_datum, 2) + '   K = ' +
        round_str(arm_angle * hand_i * 180 / Pi, 2) + ' degrees' + k_ram_str(arm_angle * hand_i));
      Add('peg from notch :  X = ' + round_str(pegx_on_pad - notchx, 2) +
        '   Y = ' + round_str((pegy_on_pad * hand_i + y_datum) - notchy, 2) +
        '   K = ' + round_str(((arm_angle * hand_i) - notch_angle) * 180 / Pi, 2) +
        ' degrees' + k_ram_str((arm_angle * hand_i) - notch_angle));

      Add('');

      pin.x := xt1;
      pin.y := yt1;
      dotransform(kform, xform, yform, pin, pout);

      rad1_orgx := pout.x + xshift;
      rad1_orgy := (pout.y + yshift) * hand_i + y_datum;

      if spiral = True then begin
        pin.x := xt2;
        pin.y := yt2;
        dotransform(kform, xform, yform, pin, pout);

        rad2_orgx := pout.x + xshift;
        rad2_orgy := (pout.y + yshift) * hand_i + y_datum;
      end;

      // add radial centres to info...

      if spiral = False   // fixed rad.
      then begin
        if ABS(nomrad) < max_rad_test then
          Add('radial centre :  X = ' + round_str(rad1_orgx, 2) + '   Y = ' +
            round_str(rad1_orgy, 2));
      end
      else begin

        if ABS(nomrad1) < max_rad_test  // transition.
        then
          Add('radial centre (1st rad) :  X = ' + round_str(rad1_orgx, 2) +
            '   Y = ' + round_str(rad1_orgy, 2))
        else
          Add('radial centre (1st rad) = straight');

        if ABS(nomrad2) < max_rad_test then
          Add('radial centre (2nd rad) :  X = ' + round_str(rad2_orgx, 2) +
            '   Y = ' + round_str(rad2_orgy, 2))
        else
          Add('radial centre (2nd rad) = straight');
      end;

      Add('');
      if ABS(pegy - g / 2) < minfp  // (pegy==g/2) peg on main road?
      then begin
        temp1 := clrad_at_x(pegx);
        if ABS(temp1) > max_rad_test then
          Add('track centre-line radius at peg = straight')          // added 212a
        else
          Add('track centre-line radius at peg = ' + rad_str(temp1, 2) + '  ( ' +
            rad_str(temp1 / 25.4, 2) + ' " )');
      end
      else
        Add('track centre-line radius at peg = n/a (peg off MS centre-line)');

      if (half_diamond = False) and (spiral = False) and (slewing = False) and
        (plain_track = False)
      // add geometrical radius info.
      then begin
        Add('internal geometrical radius = ' + rad_str(igeo_rad, 2) + '  ( ' +
          rad_str(igeo_rad / 25.4, 2) + ' " )');
        Add('external geometrical radius (substitution radius) = ' +
          rad_str(egeo_rad, 2) + '  ( ' + rad_str(egeo_rad / 25.4, 2) + ' " )');
      end;


      Add('------------');
      // 0.97.a  total timbering length not yet available -- added later for storage box info (and on shove timber form for control template)
      Add('');

    end;//with info_text_list

  finally
    // show the text..

    if pad_form.Active = True then begin
      with info_form do begin
        info_memo.Text := info_text_list.Text;  // update visible control template data.
        ref_name_label.Visible := True;
        rename_button.Visible := True;
        ref_label.Visible := True;
      end;//with

      if rail_options_form.Showing = True then
        update_rail_settings;  // 206b

    end
    else begin
      if keep_form.Active = True then begin
        with info_form do begin
          info_memo.Clear; // data may not match captions and labels.
          ref_name_label.Visible := False;
          rename_button.Visible := False;
          ref_label.Visible := False;
        end;//with
      end;
    end;
  end;//try
end;
//_________________________________________________________________________________________


function curved_onto_calc(org_rad, onto_rad: double): double;

var                // return approx radius of org_rad when curved onto onto_rad.
  temp: double;

begin
  temp := org_rad + onto_rad;
  if ABS(temp) > minfp                     // inside curve, or rads differ.
  then
    Result := org_rad * onto_rad / temp  // no zero division.
  else
    Result := max_rad;               // return effective infinity turnout road radius (straight).
end;
//______________________________________________________________________________

function equiv_rad_calc(curved_rad, onto_rad: double): double;    // 217a

  // return approx orginal rad before being curved onto onto_rad to become curved_rad

var
  temp: double;

begin
  temp := onto_rad - curved_rad;
  if ABS(temp) > minfp then
    Result := curved_rad * onto_rad / temp     // no zero division.
  else
    Result := max_rad;
  // return effective infinity original (straight) - curved_rad and onto_rad equal
end;
//______________________________________________________________________________

procedure init_resize;          // set up for any re-sizing - before calling calcturnout.

var
  sz: integer;

begin
  switch_modify_mode := False;
  // init flag to default - so can't change the switch to match the crossing.
  // either he has locked it,
  // or switch adjusts are not in force,
  // or the switch is being set by the mouse moves directly,

  if (((mouse_modify = 1) or (mouse_modify = 2)) and (switch_free = True)) or
    (generate_nearest = True) then begin
    if (xing_free = True) or (generate_nearest = True) then begin
      // adjust turnout in force - and can change both switch and crossing angle as required.
      // So set a starting switch for the calcs. Mouse moves will change the crossing angle,
      // and a matching switch can then be set.

      if csi.group_code = 1  // 6 sizes, straight switch...
      then begin
        sz := 1;
        // start with 9ft (shortest) straight switch.
        if k3n > 5.875 then
          sz := 2;    // or start with 12ft switch for 1:6 or more.
        if k3n > 7.875 then
          sz := 3;    // or start with 15ft switch for 1:8 or more.
        if k3n > 9.875 then
          sz := 4;    // or start with 18ft straight switch for 1:10 or more.
        if k3n > 11.875 then
          sz := 5;   // or start with 24ft straight switch for 1:12 or more.
        if k3n > 13.875 then
          sz := 6;   // or start with 30ft straight switch for 1:14 or more.

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(81);

        switch_modify_mode := True;
        // and flag that it can be changed if nec to suit crossing.
      end;

      if csi.group_code = 7   // 3 sizes, model switch...
      then begin
        sz := 1;
        // start with 1:24 (shortest) straight switch.
        if k3n > 5.875 then
          sz := 2;    // or start with 1:32 switch for 1:6 or more.
        if k3n > 7.875 then
          sz := 3;    // or start with 1:40 switch for 1:8 or more.

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(81);

        switch_modify_mode := True;
        // and flag that it can be changed if nec to suit crossing.
      end;

      if (csi.group_code = 2) or (csi.group_code = 5) or (csi.group_code = 6)
      // 6 sizes, REA semi-curved switch or FB switch...
      then begin
        sz := 1;
        // start with A semi-curved switch if 1:5.75 or less. (A-7 is natural)
        if k3n > 5.875 then
          sz := 2;   // or start with B switch for 1:6 or more (B-8 is natural)
        if k3n > 8.125 then
          sz := 3;   // or start with C switch for 1:8.25 or more (C-10 is natural)
        if k3n > 10.125 then
          sz := 4;  // or start with D switch for 1:10.25 or more (D-12 is natural)
        if k3n > 12.125 then
          sz := 5;  // or start with E switch for 1:12.25 or more (E-16 is natural)
        if k3n > 16.125 then
          sz := 6;  // or start with F switch for 1:16.25 or more (F-20 is natural).

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(81);

        switch_modify_mode := True;
        // and flag that it can be changed if nec to suit crossing.
      end;

      if csi.group_code = 3    // 4 sizes, GWR curved switch + 30ft straight...
      then begin
        sz := 1;                     // start with B curved switch up to 1:8
        if k3n > 8.125 then
          sz := 2;   // or start with C switch for 1:8.25 to 1:10
        if k3n > 10.125 then
          sz := 3;  // or start with D switch for 1:10.25 and above.
        if k3n > 13.875 then
          sz := 4;  // or start with 30ft switch for 1:14 and above.

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(81);

        switch_modify_mode := True;
        // and flag that it can be changed if nec to suit crossing.
      end;

      if csi.group_code = 4    // 8 sizes, GWR old-type heel switch...
      then begin
        sz := 1;                      // start with 9ft if less than 1:5.
        if k3n > 4.875 then
          sz := 2;    // or start with 10ft switch for 1:5 or more.
        if k3n > 5.875 then
          sz := 3;    // or start with 12ft switch for 1:6 or more.
        if k3n > 7.875 then
          sz := 4;    // or start with 14ft switch for 1:8 or more.
        if k3n > 8.875 then
          sz := 5;    // or start with 15ft switch for 1:9 or more.
        if k3n > 9.875 then
          sz := 6;    // or start with 16ft switch for 1:10 or more.
        if k3n > 10.875 then
          sz := 7;   // or start with 18ft straight switch for 1:11 or more.
        if k3n > 11.875 then
          sz := 8;   // or start with 20ft straight switch for 1:12 or more.

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(81);

        switch_modify_mode := True;
        // and flag that it can be changed if nec to suit crossing.
      end;

    end
    else begin     // adjust turnout in force - but the crossing is locked.
      // So mouse moves change the switch directly...
      // (switch_only set by mouse move in range 9-21).

      if (csi.group_code = 1) or (csi.group_code = 2) or (csi.group_code = 5) or
        (csi.group_code = 6)
      // 6 sizes, straight switch or REA semi-curved or FB switch.
      then begin
        sz := 1;                 // keep compiler happy.
        case switch_only of
          0..10:
            sz := 1;
          12:
            sz := 2;
          14:
            sz := 3;
          16:
            sz := 4;
          18:
            sz := 5;
          20..25:
            sz := 6;
        end;//case

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(80);
      end;

      if csi.group_code = 7  // 3 sizes, model switch...
      then begin
        sz := 1;                 // keep compiler happy.
        case switch_only of
          0..10:
            sz := 1;
          12:
            sz := 2;
          14..25:
            sz := 3;
        end;//case

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(80);
      end;

      if csi.group_code = 3    // 4 sizes, GWR curved switch + 30ft straight...
      then begin
        sz := 1;                 // keep compiler happy.
        case switch_only of
          0..10:
            sz := 1;
          13:
            sz := 2;
          16:
            sz := 3;
          19..25:
            sz := 4;
        end;//case

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(78);
      end;

      if csi.group_code = 4       // 8 sizes, GWR heel switch...
      then begin
        sz := 1;                 // keep compiler happy.
        case switch_only of
          0..11:
            sz := 1;
          12:
            sz := 2;
          13:
            sz := 3;
          14:
            sz := 4;
          15:
            sz := 5;
          16:
            sz := 6;
          17:
            sz := 7;
          18..25:
            sz := 8;
        end;//case

        if set_csi_data(csi.group_code, sz) = False
        // get switch data from listbox entries to switch[] array for control template.
        then
          run_error(79);
      end;
    end;
  end;                                     // ready to calc turnout.
end;
//_________________________________________________________________________________________

function new_marks_list(var marks: Tmark_array): boolean;     //###

  // return pointer to array of pointers to Tmark records.
var
  p: ^Tmark;                 // p is a pointer to a Tmark record.
  n, mark_count: integer;
  array_max: integer;

  num_rail_lengths: double;
  num_sleepers, num_timbers: integer;
  min_count: integer;

begin
  Result := True;                                 // assume good result.

  if marks <> nil then begin                                 // first free any previous memory.
    SetLength(marks, 0);
  end;

  // estimate number of marks needed...

  mark_count := 0;

  if (cl_only = True) or (no_timbering = True)          // no timbering.
  then begin
    if cl_only = True then
      mark_count :=
        50     // so only 50 slots (for platforms, was 40), for label, peg, rad centres, end marks, etc
    else
      mark_count := 100;
    // rails but no timbering, also need the joints and guidemarks (100=arbitrary.)
  end
  else begin
    // first assume its all plain track...

    num_rail_lengths := turnoutx / (railen[pt_i] * inscale);
    // number of rail lengths (extended - inluding fraction of rail).

    if num_rail_lengths < 1.0 then
      num_rail_lengths := 1.0;
    // minimum (in case of a custom long rail with only a few timbers at one end). 0.76.a 4-11-01

    if (retpar_i = 1) and (plain_track = False) and (turnoutx > tvjpx) then
      num_rail_lengths := num_rail_lengths + (turnoutx - tvjpx) / (railen[pt_i] * inscale);
    // for return curve.

    num_sleepers := Round(num_rail_lengths * sleeper_count[pt_i]) + bontimb + 1;
    // number of sleepers (+1 for rounding down).

    mark_count := Round(num_rail_lengths * 2 + 60);
    // 2 joints per rail-length + 60 (arbitrary) for start joints, peg, centres, transition marks, etc.

    if pad_form.timber_outlines_menu_entry.Checked = True then begin
      if timbering_infill = False then
        mark_count := mark_count + num_sleepers * 6    // 6 marks = 4 sides + 2 reduced ends.
      else
        mark_count := mark_count + num_sleepers * 8;
      // 2 extra mark entries per sleeper for timber infill (4 corners inside the outline extensions).
    end;

    if pad_form.timber_centres_menu_entry.Checked = True then
      mark_count := mark_count + num_sleepers;      // 1 mark for timber centre-line.

    if pad_form.timber_chairs_menu_entry.Checked = True then
      mark_count := mark_count + num_sleepers * 6;
    // 214a chair outline corners + dxf marker = 3 marks per chair = 6 for plain track.

    if pad_form.timber_numbers_menu_entry.Checked = True then
      mark_count := mark_count + num_sleepers;      // 1 mark for timber number.

    if plain_track = False    // then for turnouts...
    then begin
      min_count := Round((mxpx - xorg) / scale * 8);
      // (8 arbitrary) minimum for turnout, 8 marks per ft.
      if mark_count < min_count then
        mark_count := min_count;

      mark_count := mark_count + 100;
      // (100 arbitrary) extra marks for a turnout.

      mark_count := mark_count + 8;     // 0.94.a check-rail labels.

      mark_count := mark_count + 24;
      // 211b long switch marks and switch and xing labels.

      if pad_form.timber_chairs_menu_entry.Checked = True      // 213b
      then begin
        num_timbers := Round((mvjpx - toex) / (scale * 2));  // assume 2ft spacing
        mark_count := mark_count + num_timbers * 6;
        // 2 additional chairs per timber for turnout
      end;

    end;
  end;

  mark_count := mark_count + 24;     // 24 more for luck.

  try
    SetLength(marks, mark_count);
  except
    Result := False;
  end;
end;
//___________________________________________________________________________________________

function new_aqarray(aq: ERailData): boolean;   // finished with old rail data, so free the memory.
  // then create a new array.
var
  n: integer;
  p: Pointer;
  list_size: double;
  max_list: integer;

begin
  Result := False;             // init default return.

  // first clear the old...
  SetLength(xy_p[aq], 0);

  nldim_array[aq] := -1;                  //  clear max array index.

  nlmax_array[aq] := -1;             //  clear nlmax maximum index used.
  nlnow_array[aq] := 0;             //  clear nlnow current data array index.

  // and then get a new list, if needed...

  if aqyn[aq] = False              // not wanted.
  then begin
    Result := True;        // ok result.
    EXIT;
  end;

  list_size := 0;     // keep compiler happy.

  if (plain_track = True) or (cl_only = True) or (rail_section = 0) then begin
    case aq of
      eRD_StraightStockGaugeFace,
      eRD_CurvedStockGaugeFace,
      eRD_StraightStockOuterFace,
      eRD_CurvedStockOuterFace,
      eRD_StraightStockFootInnerEdge,
      eRD_CurvedStockFootInnerEdge,
      eRD_StraightStockFootOuterEdge,
      eRD_CurvedStockFootOuterEdge: begin
        if (cl_only = False) and (rail_section <> 0) then
          list_size := turnoutx / incx     // plain track main rails.
        else
          list_size := 0;                // no rails, centre-lines only
      end;

      eRD_AdjTrackTurnoutSideNearGaugeFace..eRD_AdjTrackMainSideFarOuterFace:
        list_size := turnoutx / incx; // platforms, trackbed edges

      eRD_MainRoadCentreLine:
        list_size := turnoutx / incx;         // main-side centre-line.
      //25 : list_size:=(turnoutx-dpx)/incx;   // turnout-side centre-line.
      eRD_TurnoutRoadCentreLine:
        list_size := turnoutx / incx;
        // 0.93.a for irregular half_diamond // turnout-side centre-line.

      else
        list_size := 0;                     // no turnout rails.
    end;//case
  end
  else begin             // normal turnout or half-diamond or gaunt...
    case aq of
      eRD_StraightStockGaugeFace,
      eRD_StraightStockOuterFace,
      eRD_StraightStockFootInnerEdge,
      eRD_StraightStockFootOuterEdge:
        if main_road_i <> 0 then
          list_size := (xorg + main_road_endx) / incx       // straight stock rail   217a
        else
          list_size := turnoutx / incx;

      eRD_AdjTrackTurnoutSideNearGaugeFace..eRD_AdjTrackMainSideFarOuterFace:
        list_size := turnoutx / incx;       // platforms, trackbed edges

      //1,2,9,10 : list_size:=(ckendx-toex)/incx;    // closure rails.  mods v:0.71.a  16-5-01..


      //1,2,9,10 : list_size:=(ckendx-toex)/incx;    // closure rails.  mods v:0.71.a  16-5-01..

      // 091c 1,9,31,39 : list_size:=(flcendx-toex)/incx;     // closure rail - turnout-side wing rail.

      // 093a ex 081 ...

      eRD_StraightTurnoutWingGaugeFace,
      eRD_StraightTurnoutWingOuterFace,
      eRD_StraightTurnoutWingFootInnerEdge,
      eRD_StraightTurnoutWindFootOuterEdge: begin
        if gaunt = True                            // 0.93.a
        then
          list_size := flcendx / incx          // includes approach track gauntletted rail.
        else
          list_size := (flcendx - toex) / incx;  // closure rail - turnout-side wing rail.

        list_size := list_size + (12 * knuck_rad / k3n / scale);
        // 214a   1" steps along knuckle radius. At normal setting that means 12 steps.
      end;

      eRD_CurvedTurnoutWingGaugeFace,
      eRD_CurvedTurnoutWingOuterFace,
      eRD_CurvedTurnoutWingFootInnerEdge,
      eRD_CurvedTurnoutWindFootOuterEdge: begin
        if gaunt = True                               // 0.93.a
        then
          list_size := wingendx_ms / incx         // includes approach track gauntletted rail.
        else
          list_size := (wingendx_ms - toex) / incx; // closure rail - main-side wing rail.

        list_size := list_size + (12 * knuck_rad / k3n / scale);
        // 214a   1" steps along knuckle radius. At normal setting that means 12 steps.
      end;

      eRD_CurvedStockGaugeFace,
      eRD_CurvedStockOuterFace,
      eRD_CurvedStockFootInnerEdge,
      eRD_CurvedStockFootOuterEdge:
        if turnout_road_i > 1 then
          list_size := (xorg + turnout_road_endx) /
            incx       // 209a  curved stock rail.     was =2 217a
        else
          list_size := turnoutx / incx;

      eRD_VeeSpliceGaugeFace,
      eRD_VeeSpliceOuterFace,
      eRD_VeeSpliceFootInnerEdge,
      eRD_VeeSpliceFootOuterEdge:
        if turnout_road_i > 1 then
          list_size := (xorg + turnout_road_endx - fpx) /
            incx   // 209a  vee splice rail.       was =2 217a
        else
          list_size := (turnoutx - fpx) / incx;

      eRD_VeePointGaugeFace,
      eRD_VeePointOuterFace,
      eRD_VeePointFootInnerEdge,
      eRD_VeePointFootOuterEdge:
        if main_road_i <> 0 then
          list_size := (xorg + main_road_endx - fpx) / incx   // vee point rail. 217a
        else
          list_size := (turnoutx - fpx) / incx;


      //4,12,34,42 : list_size:=(turnoutx-fpx)/incx;     // vee point rail.   217a

      //6,7,14,15 : list_size:=(ckendx-ckx)/incx;     // check rails.

      eRD_MainSideCheckGaugeFace,
      eRD_MainSideCheckOuterFace,
      eRD_MainSideCheckFootInnerEdge,
      eRD_MainSideCheckFootOuterEdge:
        list_size := (ckl_ms) / incx;     // main-side check rails.

      eRD_TurnoutSideCheckGaugeFace,
      eRD_TurnoutSideCheckOuterFace,
      eRD_TurnoutSideCheckFootInnerEdge,
      eRD_TurnoutSideCheckFootOuterEdge:
        list_size := (ckl_ts) / incx;     // turnout-side check rails.

      //25 : list_size:=(turnoutx-dpx)/incx;   // turnout-side centre-line.

      eRD_MainRoadCentreLine:
        if main_road_i <> 0 then
          list_size := (xorg + main_road_endx) / incx   // 217a  main-road centre-line
        else
          list_size := turnoutx / incx;

      eRD_TurnoutRoadCentreLine:
        if turnout_road_i > 1 then
          list_size := (xorg + turnout_road_endx) /
            incx   // 209a  turnout-road centre-line   was =2 217a
        else
          list_size := turnoutx / incx;

      eRD_KCrossingCheckMainSideGaugeFace,
      eRD_KCrossingCheckMainSideOuterEdge:
        list_size := (kckmsflendx - kckmsx) / incx;  // k-crossing check rails.
      eRD_KCrossingCheckTurnoutSideGaugeFace,
      eRD_KCrossingCheckTurnoutSideOuterEdge:
        list_size := (kckdsflendx - kckdsx) / incx;

      else
        run_error(10);

    end;//case
  end;

  max_list := Round(ABS(list_size + 24));
  // add an extra 24 slots to allow for terminal points, etc.

  SetLength(xy_p[aq], max_list + 1);          // pointer to x-values array.
  nldim_array[aq] := max_list;            //  set nldim with max index.
  Result := True;                         // ok, got new lists.
end;
//_______________________________________________________________________________________

function new_calc_draw(on_canvas: TCanvas; calcs_code, mode: integer): boolean;
  // calc and draw all rail lines and marks.
  // on the specified canvas.
var
  i, n: integer;
  aq: ERailData;
  p1, p2: TPoint;
  move_to, line_to: TPoint;
  clear_by, infringed_by, ring_rad: double;

  pen_width: integer; // 212a

begin
  Result := False;              // init error return.

  yd := y_datum * 100;            // first get y datum in 1/100th mm.

  // calc new marks and timbers (not rail ends), also peg angles...

  //mark_i[0].code:=0;          //  otherwise draws the old first mark.

  mark_index := 0;               //  init index for list of new marks.
  timb_numbers_str := '';        //  and accumulator string for the timber numbers.

  if new_marks_list(marks_list_ptr) =
    False    // ### clear the old marks list and create a new one.
  then begin
    memory_alert;     //  warn him.
    EXIT;
  end;

  total_template_timber_length := 0;  // 0.95.a init

  if (cl_only = False) and (no_timbering = False)
  // no timber marks if drawing track centre-line only.
  then
    calctimbers;                         // calc timbering marks.   0.95.a and total timber length

  shove_timber_form.timbering_length_label.Caption :=
    'total template timbering length :  ' + round_str(total_template_timber_length, 2) + ' mm';

  guidemarks;            //  calc guide marks and rad end marks (need the timbering calculated first for rail joints).

  if plain_track = False then
    add_check_labels;    // 0.94.a

  if (hide_current_flag = False) and (calcs_code = 2) and (keep_form.Active = False) then begin
    current_is_showing := current_is_showing or pad_marks_current(on_canvas, True);
    // then draw them in.
  end;

  xy_max[0] := Integer($80000000);       // init max x with min 32-bit value.
  xy_min[0] := Integer($7FFFFFFF);       // init min x with max 32-bit value.
  xy_max[1] := Integer($80000000);       // ditto y...
  xy_min[1] := Integer($7FFFFFFF);

  list_planing_mark_aq1 := 0;        // init markers for infilled switch blades...
  list_planing_mark_aq2 := 0;

  min_ring_distance := maxfp;        // init for infringements. v:0.76.a 1-5-02.
  ring_infringed := False;
  ring_copies_infringed := False;
  incx125 := incx * 125;

  for n := 0 to ring_count_c do begin
    rings_checkpoints[n].aq := eRD_Unused;        // no aq yet being checked.
    rings_checkpoints[n].infringed := False;       // not closer than incx to ring.
  end;//for

  pen_width := 1;  // init

  if dummy_template = True      // 212a
  then begin
    if bgnd_form.pad_shapes_linewidth_2_radiobutton.Checked = True then
      pen_width := 2;
    if bgnd_form.pad_shapes_linewidth_3_radiobutton.Checked = True then
      pen_width := 3;
  end;

  for aq := eRD_Unused downto eRD_StraightStockGaugeFace do begin      // Main loop for rails :
    // (in reverse order so that FB foot, adjacent rails and centre-lines are overdrawn.)


    //!!! some routines not converted to local aq. 14-6-98.


    if (aqyn[aq] = True) and (draw_mode <> 0) and ((mode = 1) or (mode = 2)) and
      (hide_current_flag = False) and (calcs_code = 2) and (keep_form.Active = False) then
    begin                                                  // re-daw in progress on-screen
      ink_colour := paper_colour;
      show_a_line(pad_form.Canvas, aq, pen_width, True);
      // so erase any existing line, one line at a time (ignore return).
    end;
    // n.b. directly on the pad canvas, in case of canvas change since draw.

    if new_aqarray(aq) = False then
      EXIT;   // finished with old data, so free any memory, and then get a new list.

    if (cl_only = True) or (rail_section = 0)
    // no rails wanted, but don't ignore platforms and trackbed edges
    then begin
      if aq in [eRD_StraightStockGaugeFace..eRD_TurnoutSideCheckOuterFace] then
        CONTINUE;  // no template rails

      if adjacent_edges = False   // adjacent rails
      then begin
        if (aq <> eRD_MainRoadCentreLine) and (aq <> eRD_TurnoutRoadCentreLine) then
          CONTINUE;   // only centre lines, ignore adjacent rails
      end
      else begin                        // platforms and trackbed edges
        if aq in [eRD_KCrossingCheckMainSideGaugeFace..eRD_Unused] then
          CONTINUE;    // ignore only half-diamond rails
      end;
    end;

    if (plain_track = False) or (aq in eRD_StockRails) or (aq in eRD_AdjacentTracks) or
      (aq = eRD_MainRoadCentreLine)
    // stock rails and adjacent tracks only if plain track.
    then begin
      if aqyn[aq] = True then begin
        if oneline(aq) = False    //  Calc all x,y for rail-edges and put in lists.
        then begin
          abandon_calcs := True;
          //^^^  0.93.a ex 081 for irregular diamond calcs.
          EXIT;
        end;

        if (nlnow_array[aq] >= (nldim_array[aq] - 1)) and (draw_mode = 0)
        //  just ignore if we are re-drawing.
        then
          repeat
            i :=
              alert(1, '   calculation  diagnostics ...', aq_str[aq] +
              '||rail-data overflow !||Increase the step size or reduce the overall length.',
              '', '', '? help', '', 'abandon this', 'continue  with  truncated  data', 3);
            if i = 3 then
              alert_help(0, '||Sorry, detailed overflow help is not yet written.' +
                '||(Your template is too long for the memory allocated to contain it.)', '');
            if i = 5 then begin
              abandon_calcs := True;
              //091c draw_mode:=2;        // prevent message recurring.
              EXIT;
            end;
          until i <> 3

        else begin
          if (hide_current_flag = False) and (calcs_code = 2) and (keep_form.Active = False) then
          begin
            ink_colour := rail_colour;  // init

            if (aq = eRD_MainRoadCentreLine) or (aq = eRD_TurnoutRoadCentreLine)
            // track centre-lines
            then begin
              if dummy_template = True then
                ink_colour := shapes_colour
              else
                ink_colour := guide_colour;
            end;

            if ((aq = eRD_AdjTrackTurnoutSideNearGaugeFace) or
              (aq = eRD_AdjTrackTurnoutSideNearOuterFace) or
              (aq = eRD_AdjTrackMainSideNearGaugeFace) or
              (aq = eRD_AdjTrackMainSideNearOuterFace)) and (adjacent_edges = True)
            // 0.93.a platforms
            then
              ink_colour := guide_colour;

            current_is_showing :=
              current_is_showing or show_a_line(on_canvas, aq, pen_width, False);
            //  draw in new line.
          end;
        end;

      end;
    end;
  end;//NEXT aq

  if xy_max[0] = Integer($80000000)       // nothing put in the lists (all rails turned off ?)
  then begin
    xy_max[0] := Round(turnoutx * 100);       // approx 1/100th mm
    xy_min[0] := 0;
    xy_max[1] := Round(turnoutx * 50);        // arbitrary half of x.
    xy_min[1] := 0;
  end;

  //if (cl_only=False) and (rail_section<>0) then do_railends;      //  calc rail end marks
  if ((cl_only = False) and (rail_section <> 0)) or
    (((draw_ts_platform = True) or (draw_ms_platform = True)) and (adjacent_edges = True)) then
    do_railends;  //  calc rail end marks and platform ends

  if (hide_current_flag = True) or (calcs_code <> 2) or (keep_form.Active = True)
  //  no more drawing.
  then begin
    Result := True;     //  flag rails calculated ok.
    EXIT;
  end;

  //if (cl_only=False) and (rail_section<>0) then draw_rail_endmarks(on_canvas,True);   //  and draw them in.
  if ((cl_only = False) and (rail_section <> 0)) or
    (((draw_ts_platform = True) or (draw_ms_platform = True)) and (adjacent_edges = True)) then
    draw_rail_endmarks(on_canvas, True);   // and draw rail end marks and platform ends.

  // the final job is to draw the arms on the peg.
  // done last so overwrites rails, etc.
  // these marks have been kindly saved for us by pad_marks_current.

  with on_canvas do begin

    Pen.Style := psSolid;
    Pen.Width := 1;
    Pen.Color := clRed;

    p1 := peg_arm1.p1;      // first arm
    p2 := peg_arm1.p2;

    move_to.X := Round(p1.X * sx + ex - gx);
    move_to.Y := Round((p1.Y + yd) * sy + by - gy);
    line_to.X := Round(p2.X * sx + ex - gx);
    line_to.Y := Round((p2.Y + yd) * sy + by - gy);
    if check_limits(move_to, line_to) = True then begin
      MoveTo(move_to.X, move_to.Y);
      LineTo(line_to.X, line_to.Y);
    end;

    p1 := peg_arm2.p1;      // second arm
    p2 := peg_arm2.p2;

    move_to.X := Round(p1.X * sx + ex - gx);
    move_to.Y := Round((p1.Y + yd) * sy + by - gy);
    line_to.X := Round(p2.X * sx + ex - gx);
    line_to.Y := Round((p2.Y + yd) * sy + by - gy);
    if check_limits(move_to, line_to) = True then begin
      MoveTo(move_to.X, move_to.Y);
      LineTo(line_to.X, line_to.Y);
    end;

  end;//with

  Result := True;             //  flag rails calculated ok.

  // infringement results... v:0.76.a 1-5-02

  with info_form do begin
    if ((ring_warn = True) and (ring_infringed = True)) or
      ((ring_copies_warn = True) and (ring_copies_infringed = True)) then
      ring_lamp_panel.Tag := 1             // flashing.
    else
    if (ring_warn = True) or (ring_copies_warn = True) then
      ring_lamp_panel.Tag := 0     // steady.
    else
      ring_lamp_panel.Tag := 2;    // lamp off.

    if ring_warn = True   // labels are showing...
    then begin
      if (cl_only = True) or (warn_centrelines = True) then
        ring_rad := rings[0, 2] / 2  // centre-lines infringe inner diameter.
      else
        ring_rad := rings[0, 3] / 2; // rails (gauge-faces) infringe outer diameter.

      if ring_infringed = False then begin
        ring_infringed_warning_label.Font.Color := clBlue;
        ring_infringed_warning_label.Caption := ' clear  by';
        ring_infringed_by_label.Font.Color := clBlue;
        clear_by := ABS(min_ring_distance / 100 - ring_rad);
        if clear_by < 1.0E6 then
          ring_infringed_by_label.Caption := round_str(clear_by, 2) + ' mm'
        else
          ring_infringed_by_label.Caption := '  a  mile';   // no rails?
      end
      else begin
        ring_infringed_warning_label.Font.Color := clRed;
        ring_infringed_warning_label.Caption := 'infringed by';
        ring_infringed_by_label.Font.Color := clRed;
        infringed_by := ABS(ring_rad - min_ring_distance / 100);
        if infringed_by < 1.0E6 then
          ring_infringed_by_label.Caption := round_str(infringed_by, 2) + ' mm'
        else
          ring_infringed_by_label.Caption := '  a  mile';
      end;
    end;
  end;//with

  if grid_form.show_dummy_vehicles_radio_button.Checked = True then
    draw_dummy_vehicle_on_control_template(on_canvas);
  //  0.98.a  draw dummy vehicle over template

end;
//_______________________________________________________________________________________________________________________________

function get_cl_offset: double;

begin
  case cl_options_code of     // 213a

    -3:
      Result := g / 2 - tb / 2;
    -2:
      Result := g / 2 - trmscent;
    -1:
      Result := g / 2 - trmscent / 2;
    0:
      Result := g / 2;               // main road (normal)
    1:
      Result := g / 2 + trtscent / 2;
    2:
      Result := g / 2 + trtscent;
    3:
      Result := g / 2 + tb / 2;

    99:
      Result := g / 2 + cl_options_custom_offset;

    else
      Result := g / 2;
  end;//case
end;
//______________________________________________________________________________


function Tcentre_line_path.get_curve_length: double;
begin
  Result := turnoutx;
end;

function Tcentre_line_path.get_minimum_radius: double;
begin
  if grid_form.turnout_road_dummy_vehicle_radio_button.Checked = True then   // turnout road ...
  begin
    Result := ABS(rmin_mm);
  end
  else begin
    if spiral = False then begin
      Result := nomrad;
    end
    else begin
      Result := min(ABS(nomrad1), ABS(nomrad2));
    end;
  end;
end;

function Tcentre_line_path.get_xy(dist: double): Tpex;
var
  tr_y: double;
  tr_k: double;
  xtr: double;
  ytr: double;
  dvx1: double;
  dvy1: double;
  dummy1: double;
  dummy2: double;
  cl_offset: double;
begin
  if grid_form.turnout_road_dummy_vehicle_radio_button.Checked = True then   // turnout road ...
  begin
    tr_y := aq3offset(dist, tr_k);  // get start position on stock rail

    xtr := dist + g / 2 * SIN(tr_k);     // start position on centre line
    ytr := tr_y - g / 2 * COS(tr_k);

    docurving(True, True, xtr, ytr, dvx1, dvy1, dummy1, dummy2);   // 1st bogie-pin on pad
  end
  else begin
    if ABS(cl_options_code) = 2          // 213a   adjacent centre-lines
    then
      cl_offset := get_cl_offset
    else
      cl_offset := g / 2;

    docurving(True, True, dist, cl_offset, dvx1, dvy1, dummy1, dummy2);
  end;

  Result.set_xy(dvx1, dvy1 * hand_i + y_datum);
end;

procedure draw_dummy_vehicle_on_control_template(on_canvas: TCanvas);    // 0.98.a

// 215c  for_env = for outlines envelope, come here to generate next step, not for drawing vehicle

var

  pin_dim: integer;

  move_to, line_to, pin1, pin2: TPoint;


  /////////////////////////////////////////////////////////

  function mm_to_pixels(p: Tpex): TPoint;

  begin
    Result.X := Round(p.x * fx + ex - gx);
    Result.Y := Round(p.y * fy + by - gy);
  end;
  /////////////////////////////////////////////////////////

  procedure draw_dv_line(p1, p2: Tpex);

  begin
    move_to := mm_to_pixels(p1);
    line_to := mm_to_pixels(p2);

    // draw line between them ...

    if check_limits(move_to, line_to) = True then begin
      on_canvas.MoveTo(move_to.X, move_to.Y);
      on_canvas.LineTo(line_to.X, line_to.Y);
    end;

  end;
  /////////////////////////////////////////////////////////

begin

  cdvi.calculate_dummy_vehicle_corners(cdvi.dv_start, inscale, centre_line_path, dv_corners_calc);

  with dv_corners_calc do begin
    with on_canvas do begin     // so draw dummy vehicle

      Pen.Style := psSolid;
      Pen.Width := 1;
      Pen.Color := pad_form.Font.Color;  //clRed;


      Brush.Color := timber_colour;
      Brush.Style := bsDiagCross;

      // (check_limits omitted ...)

      Polygon([mm_to_pixels(b1), mm_to_pixels(b2), mm_to_pixels(b3), mm_to_pixels(b4)]);


      Brush.Color := paper_colour;  // restore Brush for gaps in dotted lines.
      Brush.Style := bsSolid;
    end;//with canvas
  end;//with dv_corners_calc


  with on_canvas do begin     // draw dummy vehicle
    with dv_corners_calc do begin
      Pen.Style := psDash;        // clearance sides ...

      draw_dv_line(c2, c3);
      draw_dv_line(c4, c1);

      Pen.Style := psSolid;       // clearance corners ...

      draw_dv_line(b2, c2);
      draw_dv_line(c3, b3);
      draw_dv_line(b4, c4);
      draw_dv_line(c1, b1);

      draw_dv_line(m1, m2);      // mid-line


      // draw line between bogie pins ...

      Pen.Style := psSolid;

      draw_dv_line(pt1, pt2);

      // draw bogie pins ...

      pin1 := mm_to_pixels(pt1);
      pin2 := mm_to_pixels(pt2);

      if grid_form.attach_ring_checkbox.Checked = True  // 206b
      then begin
        rings[0, 0] := pt1.x;
        rings[0, 1] := pt1.y;
      end;

    end;//with dv_corners_calc

    pin_dim := 7;
    // pin blob radius arbitrary.
    if pin_dim > Round(scale * fx / 2) then
      pin_dim := Round(scale * fx / 2); // but not more than 6" scale radius.
    if pin_dim < 1 then
      pin_dim := 1;                                 // and not less than this.

    // 1st pin ...

    Brush.Color := Pen.Color; // clRed;
    Brush.Style := bsSolid;   // for pins

    move_to.X := pin1.X - pin_dim;
    move_to.Y := pin1.Y - pin_dim;
    line_to.X := pin1.X + pin_dim;
    line_to.Y := pin1.Y + pin_dim;

    if check_limits(move_to, line_to) = True then
      Ellipse(move_to.X, move_to.Y, line_to.X, line_to.Y);

    // 2nd pin ...

    move_to.X := pin2.X - pin_dim;
    move_to.Y := pin2.Y - pin_dim;
    line_to.X := pin2.X + pin_dim;
    line_to.Y := pin2.Y + pin_dim;

    if check_limits(move_to, line_to) = True then
      Ellipse(move_to.X, move_to.Y, line_to.X, line_to.Y);

    Brush.Color := paper_colour;  // restore Brush for gaps in dotted lines.

    draw_rings(on_canvas, False, True);
    //  re-draw attached spacing-ring  (not copies).

  end;//with canvas

end;
//______________________________________________________________________________

function oneline(aq: ERailData): boolean; //  Calc a rail-line.
  //  Enter with required line in aq.
  //  X,Y data is put in rail-data array for this aq.
begin
  Result := True;                       // default ok.

  case aq of                          // which rail-line ?

    eRD_StraightStockGaugeFace,
    eRD_StraightStockOuterFace,
    eRD_AdjTrackTurnoutSideNearGaugeFace..eRD_MainRoadCentreLine:
      Result := strails(aq);
    // straight stock rail, adjacent tracks/trackbed/platforms, main-road track centre-line.

    eRD_StraightTurnoutWingGaugeFace,
    eRD_StraightTurnoutWingOuterFace: begin
      Result := strails(aq);                   // straight turnout rail to knuckle.
      if knuckle_code <> -1 then
        knuckle(aq);  // knuckle radius  214a   -1=sharp knuckle
      cuwing(aq{,flen_tr});                  // then turnout-side wing rail.
    end;

    eRD_CurvedTurnoutWingGaugeFace,
    eRD_CurvedTurnoutWingOuterFace: begin
      curails(aq{,flen_mr});
      // curved turnout rail to end of curve.
      if xing_calc_i = 0 then
        stxrail(aq{,flen_mr});  // then straight crossing part, if normal crossing.
      if knuckle_code <> -1 then
        knuckle(aq);         // knuckle radius  214a   -1=sharp knuckle
      stwing(aq{,flen_mr});                         // then main-side wing rail.
    end;

    eRD_CurvedStockGaugeFace,
    eRD_CurvedStockOuterFace: begin
      curails(aq{,flen_tw});      // curved stock rail to end of turnout curve.
      if xing_calc_i <> 1 then begin
        stcurail(aq{,flen_tw});
        // then add straight section if straight crossing, normal or original.
        if retpar_i = 1 then
          retrails(aq);     // and finally add the return curve if any.
      end;
    end;

    eRD_VeePointGaugeFace,
    eRD_VeePointOuterFace:
      stvee(aq);                  // straight vee rail.

    eRD_VeeSpliceGaugeFace,
    eRD_VeeSpliceOuterFace: begin
      cuvee(aq{,flen_tr});                                       // curved vee rail,
      if (xing_calc_i <> 1) and (retpar_i = 1) then
        retrails(aq);  // then if straight crossing,
    end;
    // add return curve if any.

    eRD_MainSideCheckGaugeFace,
    eRD_MainSideCheckOuterFace:
      stckrail(aq{,xing_fl});       // main-side check rail.

    eRD_TurnoutSideCheckGaugeFace,
    eRD_TurnoutSideCheckOuterFace:
      cuckrail(aq{,xing_fl});       // turnout-side check rail.

    eRD_TurnoutRoadCentreLine:
      turnroad_cl;                // turnout road centre-line.

    //091c 26,27: k_checkrail_ms(aq);        // K-crossing check rail, MS.

    // 0.93.a ex 081 ..

    eRD_KCrossingCheckMainSideGaugeFace:
      cuwing(aq{,flen_mk});        // K-crossing check rail, MS, gauge-face
    eRD_KCrossingCheckMainSideOuterEdge:
      cuwing(aq{,flen_mk_oe});     // K-crossing check rail, MS, outer edge

    eRD_KCrossingCheckTurnoutSideGaugeFace,
    eRD_KCrossingCheckTurnoutSideOuterEdge:
      k_checkrail_ds(aq);        // K-crossing check rail, DS.

    else
      run_error(26);
  end;//case
end;
//_______________________________________________________________________________________________________________________________

procedure toe(aq: ERailData);      // do toe length.  ys constant.

begin
  if (gaunt = True) and (plain_track = False)     // plain track bug fix 211c
  then begin
    case aq of                     // which rail ?
      eRD_CurvedTurnoutWingGaugeFace:
        ys := h;               // trg, // not actually used, xb = nodraw.
      eRD_CurvedStockGaugeFace:
        ys := h + g;             // srg.
      eRD_CurvedTurnoutWingOuterFace:
        ys := h - j;             // tro, // not actually used, xb = nodraw.
      eRD_CurvedStockOuterFace:
        ys := h + g + j;           // sro.
      else
        run_error(64);
    end;//case
  end
  else begin
    case aq of                     // which rail ?
      eRD_CurvedTurnoutWingGaugeFace:
        ys := 0;               // trg, // not actually used, xb = nodraw.
      eRD_CurvedStockGaugeFace:
        ys := g;               // srg.
      eRD_CurvedTurnoutWingOuterFace:
        ys := 0 - j;             // tro, // not actually used, xb = nodraw.
      eRD_CurvedStockOuterFace:
        ys := g + j;             // sro.
      else
        run_error(64);
    end;//case
  end;
  ks := 0;                          // gradient angle.
end;
//___________________________________________________________________________________________

procedure straight_planing(aq: ERailData; do_joggle: boolean);
// semi-curved switch : return ys, ks along planing length at this xs.

var
  xpl, y, len, jog: double;

begin
  if switch_type <> -1 then
    run_error(154); // only come here for semi-curved switches.

  len := stox - setx;   // length of planing for joggle.

  xpl := xs - setx;     // current length along planing.

  if (do_joggle = True) and ((aq = eRD_CurvedStockGaugeFace) or
    (aq = eRD_CurvedStockOuterFace)) and (len > minfp) then begin
    if xpl >= len then
      jog := 0                           // beyond end of planing.
    else
      jog := (len - xpl) / len * joggle_deep;  // run out the joggle. 0.71.a 13-4-01.
  end
  else
    jog := 0;                    // no joggle offset.

  y := jog + xpl * TAN(k1);                // total offset.

  case aq of                     // which rail ?
    eRD_CurvedTurnoutWingGaugeFace:
      ys := y;                        // trg.
    eRD_CurvedStockGaugeFace:
      ys := g + y;                      // srg.
    eRD_CurvedTurnoutWingOuterFace:
      ys := 0;                        // tro.
    eRD_CurvedStockOuterFace:
      ys := g + y + j / COS(k1);            // sro.
    else
      run_error(155);
  end;//case

  ks := k1;                   // return ks gradient angle also.
end;
//_______________________________________________________________________________________________________________________________

procedure swcurve(aq: ERailData; do_joggle: boolean);    // do switch curve / straight switch.
// return ys,ks at this xs.
var
  x, temp: double;
  xjog, len, jog: double;

begin
  if gaunt = True then begin
    ks := 0;
    case aq of
      eRD_CurvedTurnoutWingGaugeFace:
        ys := h;          // trg
      eRD_CurvedStockGaugeFace:
        ys := h + g;        // srg
      eRD_CurvedTurnoutWingOuterFace:
        ys := h - j;        // tro
      eRD_CurvedStockOuterFace:
        ys := h + g + j;      // sro
      else
        run_error(66);
    end;//case
    EXIT;
  end;

  if (do_joggle = True) and (switch_type <> 0) then
    run_error(155); // planing should only come here for curved switches.

  len := stox - setx;   // length of planing for joggle.

  if (do_joggle = True) and ((aq = eRD_CurvedStockGaugeFace) or
    (aq = eRD_CurvedStockOuterFace)) and (len > minfp) then begin
    xjog := xs - setx;              // length along planing.
    if xjog >= len then
      jog := 0                            // beyond end of planing.
    else
      jog := (len - xjog) / len * joggle_deep;  // run out the joggle. 0.71.a 13-4-01.
  end
  else
    jog := 0;    // no joggle offset.

  x := xs - sworgx;                 // x from rad centre.

  case aq of                  // which rail ?
    eRD_CurvedTurnoutWingGaugeFace:
      rsw := swrad;             // trg radius.
    eRD_CurvedStockGaugeFace:
      rsw := swrad - g;           // srg radius.
    eRD_CurvedTurnoutWingOuterFace:
      rsw := swrad + j;           // tro radius.
    eRD_CurvedStockOuterFace:
      rsw := swrad - g - j;         // sro radius.
    else
      run_error(67);
  end;//case

  temp := SQR(rsw) - SQR(x);

  if temp < minfp                      // prevent sqrt of negative or zero.
  then begin
    abandon_calcs := True;      // we have a fly in the ointment.
    EXIT;
  end
  else
    ys := jog + sworgy - SQRT(temp);  // calc switch curve.

  if (ABS(rsw) < minfp) or (Abs(x) > (Abs(rsw) - minfp))
  // prevent division by zero or ARCSIN error.
  then begin
    abandon_calcs := True;      // we have a different fly in the ointment.
    EXIT;
  end
  else
    ks := ARCSIN(x / rsw);          // calc gradient angle (ignore joggle).
end;
//_______________________________________________________________________________________________________________________________

procedure double_curved_planing(aq: ERailData);

begin
  //
end;
//__________________________________________________________________________________________

function strails(aq: ERailData): boolean;     //   all straight rails.

var
  stxmax: double;
  bnw, xbn: double;

begin
  Result := False;   // default init.
  //  with cpi do begin
  try

    if plain_track = False then begin
      if main_road_i <> 0 then
        stxmax := xorg + main_road_endx      // stop at end of main-road exit  217a
      else
        stxmax := turnoutx;                // stop at end of template.
    end
    else
      stxmax := xorg;        // or stop at rail joint for plain track (approach track) only.

    case aq of                       // which side of which rail ?

      eRD_StraightStockGaugeFace, eRD_StraightStockOuterFace: begin                 // stock rail.

        //if (joggled=True) and (turnout_road_crossing_rail_flag=True)
        if (plain_track = False) and (half_diamond = False) and (joggled = True) and
          ({cri.}turnout_road_crossing_rail_flag = True)   // mod 0.76.a 27-4-02.
        then begin
          if aq = eRD_StraightStockGaugeFace then
            ys := 0      // gauge-face aq=0.
          else
            ys := 0 - j;   // outer edge aq=8.

          xb := 0;                  // start at datum.
          xe := toex - joggle_long;   // end of toe front.
          dostr(aq, xb, xe, ys);     // fill the list for this part.

          xb := toex - inscale;
          // now do the joggle (extends 1" arbitrary beyond toe).
          xe := plox;                  // end of planing.
          dostr_joggle(aq, xb, xe, ys); // fill the list for this part.

          xb := plox;               // end of joggle.
          xe := stxmax;             // continue to end of turnout.
        end
        else begin      //   no joggle, ys constant for this rail.

          if aq = eRD_StraightStockGaugeFace then
            ys := 0      // gauge-face aq=0.
          else
            ys := 0 - j;   // outer edge aq=8.

          if half_diamond = True then begin
            if aq = eRD_StraightStockGaugeFace then
              xb := toex      // half diamond switch starts at toe.
            else
              xb := toeoxhd;  // aq=8.
          end
          else
            xb := 0;           // start at datum.
          xe := stxmax;              // end of turnout.
        end;
      end;

      eRD_StraightTurnoutWingGaugeFace: begin   //  main road crossing rail.

        ys := g;              //  gauge face. ys constant.

        if isolated_crossing = True   // 217a
        then begin
          xb := wingcx_minus - scale / 6;     // 2" arbitrary
          xe := wingcx_minus;             // end at start of knuckle_rad.
        end
        else begin

          if (half_diamond = True) and (fixed_diamond = True)   //  fixed-diamond
          then begin

            // blunt nose of diamond point rails is typically 1/8" less than V-nose (=1/2" for FB, =5/8" for BH).

            bnw := (bn_wide - 0.125) * inscale;
            // width of diamond point rails blunt nose.
            if bnw < 0 then
              bnw := 0;

            // leave K-crossing flangeway...

            if tradius_is_straight = True
            // calc blunt nose...
            // 211b mod then xbn:=setx+fw/SIN(hdk)+bnw/2/SIN(hdk/2)
            then
              xbn := setx + fw / SIN(hdk) + bnw / TAN(hdk)
            // x to blunt nose (gauge-face intersection).
            // 211b mod else xbn:=torgx+SQRT(SQR(tradius-g+fw)-SQR(torgy-g-bnw*COS(hdk/2)))*SGZ(tradius)+bnw*SIN(hdk/2); // x to blunt nose (hdk/2 is an approximation).
            else
              xbn := torgx + SQRT(SQR(tradius - g + fw) - SQR(torgy - g - bnw)) * SGZ(tradius);
            // x to blunt nose.

            if (xbn > startx) and (xbn < turnoutx) then begin
              // 211b if f28000(aq,(xbn-bnw*SIN(hdk/2)),(g+bnw*COS(hdk/2)))=1 then EXIT;  // first put actual blunt nose mark at start of aq=1 list.
              if f28000(aq, xbn, g + bnw) = 1 then
                EXIT;  // first put actual blunt nose mark at start of aq=1 list.
            end;

            xb := xbn;        // then gauge-face of rail.
            //xe:=wingcx;
            xe := wingcx_minus;   // 214a end at start of knuckle_rad.
          end
          else begin                 //  normal switch or switch-diamond.

            if gaunt = True then
              xb := 0       //  gaunt starts at rail joint.
            else
              xb := setx;   //  start gauge face at "set" in stock rail.

            xe := stox;
            //  end first section at end of planing.    !! mod 18-8-01. 0.73.a - for better blade infill printing.
            dostr(aq, xb, xe, ys); //  fill the list for this part.

            xb := stox;           //  main part of main road turnout rail.

            //xe:=wingcx;       //  end straight portion at knuckle.
            xe := wingcx_minus;   // 214a end at start of knuckle_rad.

          end;
        end;
      end;

      eRD_StraightTurnoutWingOuterFace: begin                  //  main-road crossing rail
        ys := g + j;             //  outer edge.  ys constant.

        if isolated_crossing = True   // 217a
        then begin
          xb := wingcox_minus - scale / 6;     // 2" arbitrary
          xe := wingcox_minus;             // end at start of knuckle_rad.
        end
        else begin
          if (half_diamond = True) and (fixed_diamond = True)
          //  fixed-diamond
          then begin
            if tradius_is_straight = True then
              xb := stox + fw / SIN(hdk)  //  leave K-crossing flangeway.
            else
              xb := torgx + SQRT(SQR(tradius - g + fw) - SQR(torgy - g - j)) * SGZ(tradius);
            //^^^
          end
          else begin
            if gaunt = True then
              xb := 0       //  gaunt starts at rail joint.
            else
              xb := stox;   //  start normal outer edge.
          end;

          //xe:=wingcox;       //  end at knuckle, outer edge.
          xe := wingcox_minus;   // 214a end at start of knuckle_rad.
        end;
      end;


      eRD_AdjTrackTurnoutSideNearGaugeFace..eRD_AdjTrackMainSideFarOuterFace: begin
        // 0.93.a mods ...

        xb := 0;         //  start at datum. init, changed later for platforms, trackbed
        xe := stxmax;    //  end of turnout. init, changed later for platforms, trackbed

        if adjacent_edges = True    // platforms and trackbed edges ...

        then begin
          case aq of

            eRD_AdjTrackTurnoutSideNearGaugeFace: begin  // TS platform rear edge

              xb := platform_ts_start_mm;
              if xb = def_req then
                xb := 0;

              if platform_ts_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + platform_ts_length_mm;

              xb := xb - platform_ts_start_skew_mm;      // 207a
              xe := xe + platform_ts_end_skew_mm;        // 207a
              if xe < xb then
                xe := xb;                  // 207a
              if xb > xe then
                xb := xe;                  // 207a

              ys := 0; // calculated in dostr
            end;

            eRD_AdjTrackTurnoutSideNearOuterFace: begin  // TS platform near edge.

              xb := platform_ts_start_mm;
              if xb = def_req then
                xb := 0;

              if platform_ts_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + platform_ts_length_mm;

              ys := g / 2 + platform_ts_front_edge_ins * inscale;
            end;

            eRD_AdjTrackTurnoutSideFarGaugeFace: begin
              // TS trackbed
              xb := trackbed_ts_start_mm;        // 215a ...
              if xb = def_req then
                xb := 0;

              if trackbed_ts_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + trackbed_ts_length_mm;

              ys := g / 2 + trackbed_ts_width_ins * inscale;
              // TS trackbed width      215a
            end;

            eRD_AdjTrackTurnoutSideFarOuterFace: begin
              xb := trackbed_ts_start_mm;        // 215a ...
              if xb = def_req then
                xb := 0;

              if trackbed_ts_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + trackbed_ts_length_mm;

              if draw_ts_trackbed_cess_edge = True then
                ys := g / 2 + (trackbed_ts_width_ins + cess_ts_width_ins) *
                  inscale    // show TS cess width  215a
              else
                ys := g / 2 + trackbed_ts_width_ins * inscale + j / 2;
              // cutting edge mark is half rail-width wide
            end;

            eRD_AdjTrackMainSideNearGaugeFace: begin  // MS platform rear edge

              xb := platform_ms_start_mm;
              if xb = def_req then
                xb := 0;

              if platform_ms_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + platform_ms_length_mm;

              xb := xb - platform_ms_start_skew_mm;      // 207a
              xe := xe + platform_ms_end_skew_mm;        // 207a
              if xe < xb then
                xe := xb;                  // 207a
              if xb > xe then
                xb := xe;                  // 207a

              ys := 0; // calculated in dostr
            end;

            eRD_AdjTrackMainSideNearOuterFace: begin  // MS platform near edge.

              xb := platform_ms_start_mm;
              if xb = def_req then
                xb := 0;

              if platform_ms_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + platform_ms_length_mm;

              ys := g / 2 - platform_ms_front_edge_ins * inscale;
            end;


            eRD_AdjTrackMainSideFarGaugeFace: begin
              // MS trackbed
              xb := trackbed_ms_start_mm;       // 215a ...
              if xb = def_req then
                xb := 0;

              if trackbed_ms_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + trackbed_ms_length_mm;

              ys := g / 2 - trackbed_ms_width_ins * inscale;
              // MS trackbed width      215a
            end;

            eRD_AdjTrackMainSideFarOuterFace: begin
              xb := trackbed_ms_start_mm;       // 215a ...
              if xb = def_req then
                xb := 0;

              if trackbed_ms_length_mm = def_req then
                xe := stxmax
              else
                xe := xb + trackbed_ms_length_mm;

              if draw_ms_trackbed_cess_edge = True then
                ys := g / 2 - (trackbed_ms_width_ins + cess_ms_width_ins) *
                  inscale    // show MS cess width     215a
              else
                ys := g / 2 - trackbed_ms_width_ins * inscale - j / 2;
              // cutting edge mark is half rail-width wide
            end;

          end;//case
        end
        else begin             // adjacent tracks ...
          case aq of

            eRD_AdjTrackTurnoutSideNearGaugeFace:
              ys := trtscent;      //  gauge-face, turnout side adjacent track near rail.
            eRD_AdjTrackTurnoutSideNearOuterFace:
              ys := trtscent - j;    //  ditto outer-edge.

            eRD_AdjTrackTurnoutSideFarGaugeFace:
              ys := trtscent + g;    //  gauge-face, ditto far rail.
            eRD_AdjTrackTurnoutSideFarOuterFace:
              ys := trtscent + g + j;  //  ditto outer-edge.

            eRD_AdjTrackMainSideNearGaugeFace:
              ys := g - trmscent;    //  gauge-face, main side adjacent track near rail.
            eRD_AdjTrackMainSideNearOuterFace:
              ys := g - trmscent + j;  //  ditto outer-edge.

            eRD_AdjTrackMainSideFarGaugeFace:
              ys := 0 - trmscent;    //  gauge-face, ditto far rail.
            eRD_AdjTrackMainSideFarOuterFace:
              ys := 0 - trmscent - j;  //  ditto outer-edge.

          end;//case
        end;

      end;//16..23

      eRD_MainRoadCentreLine: begin     // track centre-line...

        ys := get_cl_offset;   // added 206a

        xb := 0;
        xe := stxmax;
      end;

      else
        run_error(29);

    end;//case

    dostr(aq, xb, xe, ys);
    //  now fill the list, (or remaining part e.g. if joggled stock rails).
    Result := True;
  except
    EXIT;          // f.p. errors, do nothing in list.
  end;//try
  //end;//with cpi
end;
//_______________________________________________________________________________________________________________________________

function aq25offset(xs: double; var k: double): double;
  // return offset at xs on turnout road centre-line.
  // also return the angle in k.
var
  temp: double;
  x, xlim, rto: double;

  curve_endx: double;

  ////////////////////////////////////////////////////////////

  procedure do_gaunt;

  begin
    Result := g / 2 + h;
    k := 0;
  end;
  ////////////////////////////////////////////////////////////

  procedure do_parallel_xing;

  begin
    if xs < retx then begin
      Result := g / 2 + (xs - dpx) / k3n;
      // straight section beyond crossing point.
      k := k3;
      EXIT;
    end;

    if xs > retrorgx then begin
      Result := trtscent + g / 2;
      // parallel section beyond return curve.
      k := 0;
      EXIT;
    end;

    if retr < minfp then
      retr := minfp;
    temp := (retrorgx - xs) / retr;
    if ABS(temp) < 1.0 then
      k := ARCSIN(temp)
    else
      k := Pi / 2;

    Result := retrorgy + retr * COS(k);        // return curve section.
  end;
  ////////////////////////////////////////////////////////////

  procedure do_turnout_curve;

  begin
    rto := tradius - g / 2;

    if ABS(rto) < minfp      // abandon ship ???
    then begin
      abandon_calcs := True;
      Result := 0;
      k := 0;
      EXIT;
    end;

    xlim := ABS(rto) * 0.98;
    // 0.98*radius, arbitrary x limits to turnout curve.  0.79.a

    repeat
      if xs > (torgx + xlim) then begin
        x := xlim;   // forward limit x from rad centre.
        BREAK;
      end;

      if xs < (torgx - xlim) then begin
        x := 0 - xlim; // backward limit x from rad centre.
        BREAK;
      end;

      x := xs - torgx;         // ok, x from rad centre.
      BREAK;
    until 0 <> 0;

    try
      temp := SQR(rto) - SQR(x);
      Result := torgy - SQRT(temp) * SGZ(rto);   // calc turnout curve.
      k := ARCSIN(x / rto);                    // and gradient angle.

    except
      abandon_calcs := True;
      // abandon ship. Cannot be if x is under 90 degrees ?
      Result := 0;
      k := 0;
    end;//try
  end;
  ////////////////////////////////////////////////////////////

  procedure do_regular_beyond_curve_end;

  begin

    if xs < tcpx        // in front of crossing, for regular, parallel
    then begin
      Result := g / 2 + (xs - dpx) / k3n;
      // straight centre-line from CESP to crossing.
      k := k3;
      EXIT;
    end;

    if (xing_calc_i = 0) and (retpar_i = 1)       // parallel crossing...
    then begin
      do_parallel_xing;
      EXIT;
    end;

    // regular or generic crossing beyond TCP...

    Result := g / 2 + (xs - dpx) / k3n;   // straight section beyond crossing.
    k := k3;
  end;
  ////////////////////////////////////////////////////////////

begin
  Result := g / 2;    // init defaults
  k := 0;

  if (gaunt = True) and (xs < torgx) then begin
    do_gaunt;
    EXIT;
  end;

  if xing_calc_i = 1     // curviform crossing, all templates.
  then begin
    do_turnout_curve;  // turnout curve runs through
    EXIT;
  end;

  if tradius_is_straight = True // regular diamonds, straight line from DP to TCP ...
  then begin
    do_regular_beyond_curve_end;
    EXIT;
  end;

  curve_endx := torgx + (tradius - g / 2) * SIN(k3);  // turnout curve end. CESP or TCP.

  if xs < curve_endx then begin
    do_turnout_curve;
    EXIT;
  end;

  do_regular_beyond_curve_end;

end;
//___________________________________________________________________________________________

procedure turnroad_cl;            // turnout road track centre-line.

var
  xs, ys, ks, xe: double;
  curve_startx: double;  // 213a

begin
  if plain_track = True then
    EXIT;

  if (half_diamond = True) or (gaunt = True)            // mods 213a
  then
    xs := blank_start(0)                        // start at origin
  else begin
    curve_startx := torgx + (tradius - g / 2) * SIN(k2);  // switch curve end / turnout curve start
    xs := blank_start(curve_startx);              // turnout start
  end;

  case turnout_road_i of       // 209a

    -1:
      xe := txpx;     // stop at crossover mid-point.

    0, 1: begin
      if retpar_i = 1 then begin                                     // parallel crossing...
        if turnout_road_i = 1 then
          xe := turnoutx   // long turnout road - stop at end of turnout.
        else
          xe := trpx;
      end
      else
        xe := vendx;     // stop at end of vee rail.
    end;

    2, 3:
      if turnoutx > (xorg + min_turnout_road_endx) then
        xe := xorg + turnout_road_endx      // 2=adjustable turnout road      3 added  217a
      else
        xe := turnoutx;

    else
      xe := turnoutx;  // ???

  end;//case

  //if xe>turnoutx then xe:=turnoutx;     // stop at end of turnout. v:0.76.a  28-4-02

  if (turnout_road_i < 2) and (xe > turnoutx) then
    xe := turnoutx;   // 209a           was <>2 217a

  if xs > (xe - minfp) then
    EXIT;  // !!! 0.76.a  18-1-02.

  repeat
    if xs > xe then
      xs := xe;      // ensure we hit the end.

    ys := aq25offset(xs, ks);     // get offset to centre-line and angle.

    if (f28000(eRD_TurnoutRoadCentreLine, xs, ys) = 1) or (xs >= xe) then
      BREAK;  // do curving on xs,ys and put in array (aq=25).
    xs := xs + incx;                                     // increment xs.
  until 0 <> 0;
end;
//_________________________________________________________________________________________

procedure knuckle(aq: ERailData);     // knuckle radius  214a

var
  dummy: integer;


  ////////////////////////////////////////////////////////////

  procedure do_kuckle_curve(aq: ERailData; kr, xb, xe: double);
  // do a turnout curve.

  var
    xs, ys, temp: double;

  begin
    if xb > turnoutx then
      EXIT;             // !!! mod 26-3-99
    if xe > turnoutx then
      xe := turnoutx;     // !!! mod 26-3-99

    xs := blank_start(xb);
    if xs > (xe - minfp) then
      EXIT;  // !!! 0.76.a  18-1-02.

    ys := 0;    // keep compiler happy..
    temp := 0;

    repeat
      if xs > xe then
        xs := xe;  // ensure we hit the end.

      case aq of

        eRD_StraightTurnoutWingGaugeFace,
        eRD_StraightTurnoutWingFootInnerEdge,
        eRD_StraightTurnoutWingOuterFace,
        eRD_StraightTurnoutWindFootOuterEdge: begin                        // main road
          temp := SQR(kr) - SQR(xs - xb);  // SQRT protection
          if temp < minfp then
            EXIT;
        end;

        eRD_CurvedTurnoutWingGaugeFace,
        eRD_CurvedTurnoutWingFootInnerEdge,
        eRD_CurvedTurnoutWingOuterFace,
        eRD_CurvedTurnoutWindFootOuterEdge: begin                        // turnout road
          temp := SQR(kr) - SQR(xe - xs);  // SQRT protection
          if temp < minfp then
            EXIT;
        end;
      end;//case

      case aq of

        eRD_StraightTurnoutWingGaugeFace,
        eRD_StraightTurnoutWingFootInnerEdge:
          ys := g + kr - SQRT(temp);      // main road rail, gauge-face
        eRD_StraightTurnoutWingOuterFace,
        eRD_StraightTurnoutWindFootOuterEdge:
          ys := g + j + kr - SQRT(temp);    // main road rail, outer edge

        eRD_CurvedTurnoutWingGaugeFace,
        eRD_CurvedTurnoutWingFootInnerEdge:
          ys := g - fw - kr + SQRT(temp);      // turnout road rail, gauge-face
        eRD_CurvedTurnoutWingOuterFace,
        eRD_CurvedTurnoutWindFootOuterEdge:
          ys := g - fw - j - kr + SQRT(temp);    // turnout road rail, outer edge

      end;//case

      if (f28000(aq, xs, ys) = 1) or (xs >= xe) then
        BREAK;      // fill list.

      xs := xs + inscale;    // 1 inch steps on x
    until 0 <> 0;
  end;
  ////////////////////////////////////////////////////////////

begin

  case aq of

    eRD_StraightTurnoutWingGaugeFace,
    eRD_StraightTurnoutWingFootInnerEdge:
      do_kuckle_curve(aq, knuck_rad, wingcx_minus, wingcx_plus);      // main road rail, gauge-face
    eRD_StraightTurnoutWingOuterFace,
    eRD_StraightTurnoutWindFootOuterEdge:
      do_kuckle_curve(aq, knuck_rad - j, wingcox_minus, wingcox_plus);
    // main road rail, outer edge

    eRD_CurvedTurnoutWingGaugeFace,
    eRD_CurvedTurnoutWingFootInnerEdge:
      do_kuckle_curve(aq, knuck_rad, wingx_minus, wingx_plus);
    // turnout road rail, gauge-face
    eRD_CurvedTurnoutWingOuterFace,
    eRD_CurvedTurnoutWindFootOuterEdge:
      do_kuckle_curve(aq, knuck_rad - j, wingox_minus, wingox_plus);
    // turnout road rail, outer edge

  end;//case
end;
//______________________________________________________________________________

procedure cuwing(aq: ERailData{; fl:extended});      // turnout-side wing rail.

// 0.93.a also main-side K check rail

begin
  // 0.93.a  // mods 0.79.b 23-09-04...

  if aq = eRD_KCrossingCheckMainSideGaugeFace       // K-crossing MS check rail gauge-face...
  then begin
    xb := kckmsx;       // start at centre knuckle.
    xe := kckmsflx;     // do up to flare start.
    //docrossing(aq,kckms_flg_mm,kckms_fl_k5,xb,xe,1);
    docrossing(aq,{fl,}xb, xe, 1);

    xb := xe;
    xe := kckmsflendx;  // stop at end of flare.
    //docrossing(aq,kckms_flg_mm,kckms_fl_k5,xb,xe,1);
    docrossing(aq,{fl,}xb, xe, 1);

    EXIT;
  end;

  if aq = eRD_KCrossingCheckMainSideOuterEdge       // K-crossing MS check rail outer-edge...
  then begin
    xb := kckmsox;       // start at centre knuckle.
    xe := kckmsflox;     // do up to flare start.
    //docrossing(aq,kckms_flo_mm,kckms_fl_k5,xb,xe,1);
    docrossing(aq,{fl,}xb, xe, 1);

    xb := xe;
    xe := kckmsflendox;  // stop at end of flare.
    //docrossing(aq,kckms_flo_mm,kckms_fl_k5,xb,xe,1);
    docrossing(aq,{fl,}xb, xe, 1);

    EXIT;
  end;

  // mods end

  if xing_calc_i = -1        // generic crossing.
  then begin            // first do short curve to f.p. :
    case aq of     // which rail-line ?

      eRD_StraightTurnoutWingGaugeFace: begin
        // straight turnout rail, gauge-face.
        //xb:=wingcx;           // start at knuckle.
        xb := wingcx_plus;      // 214a start at end of knuckle_rad.

        xe := wingcfpx;         // stop curve opposite f.p.
        doradcurve(aq,{fl,}xb, xe);

        xb := wingcfpx;
        xe := flarecx;              // !!! 30-5-00  do up to flare start.
        docrossing(aq,{fl,}xb, xe, 1);

        xb := flarecx;
        xe := flcendx;              // stop at end of wing rail.
        docrossing(aq,{fl,}xb, xe, 1);

      end;

      eRD_StraightTurnoutWingOuterFace: begin                         // ditto, outer-edges.
        //xb:=wingcox;
        xb := wingcox_plus;      // 214a start at end of knuckle_rad.

        xe := wingcfpox;
        doradcurve(aq,{fl,}xb, xe);

        xb := wingcfpox;
        xe := flarecox;
        docrossing(aq,{fl,}xb, xe, 1);

        xb := flarecox;
        xe := flcendox;
        docrossing(aq,{fl,}xb, xe, 1);

      end;

      else
        run_error(31);
    end;//case
  end//then

  else begin                            // normal straight or curviform V-crossing :
    case aq of                     // which rail-line ?

      eRD_StraightTurnoutWingGaugeFace: begin
        // straight turnout rail, gauge-face.
        //xb:=wingcx;                 // start at knuckle.
        xb := wingcx_plus;      // 214a start at end of knuckle_rad.

        xe := flarecx;                // !!! 30-5-00  do up to flare start.
        docrossing(aq,{fl,}xb, xe, 1);

        xb := xe;
        xe := flcendx;               // stop at end of wing rail.
        docrossing(aq,{fl,}xb, xe, 1);
      end;

      eRD_StraightTurnoutWingOuterFace: begin                        // ditto, outer-edges.
        //xb:=wingcox;
        xb := wingcox_plus;      // 214a start at end of knuckle_rad.

        xe := flarecox;
        docrossing(aq,{fl,}xb, xe, 1);

        xb := xe;
        xe := flcendox;
        docrossing(aq,{fl,}xb, xe, 1);
      end;
      else
        run_error(32);
    end;//case
  end;//else
end;
//_______________________________________________________________________________________________________________________________

procedure retrails(aq: ERailData);       // return curve rails.

var
  xb, retrmod: double;

begin
  if xing_calc_i = 1 then
    run_error(33); // should not be here for curviform V-crossing.

  xb := 0;                   // to keep the compiler happy.
  retrmod := 0;              // ditto.

  if turnout_road_i = 1 then
    xe := turnoutx       // long turnout road - rails full length.
  else
    xe := trpx;          // end turnout road at return point.

  case aq of               // which rail ?

    eRD_VeeSpliceGaugeFace: begin            // vee rail:
      xb := vendx;
      retrmod := 0 - g / 2;       // gf
    end;

    eRD_VeeSpliceOuterFace: begin
      xb := vendox;
      retrmod := 0 - g / 2 - j;     // oe
    end;

    eRD_CurvedStockGaugeFace: begin            // curved stock rail:
      xb := csrendx;
      retrmod := g / 2;       // gf
    end;

    eRD_CurvedStockOuterFace: begin
      xb := csrendox;
      retrmod := g / 2 + j;     // oe
    end;

    else
      run_error(33);
  end;//case

  if xb < xe then
    doreturn(aq, xb, xe, retrmod);   // go do return curve. (unless turnout too short).

end;
//___________________________________________________________________________________________

procedure curails(aq: ERailData{; fl:extended});    //  central curved part of turnout road.

var
  do_joggle: boolean;
  plox_done: boolean;
  bnw, xbn: double;
  segment_index: integer;

  // fill the curved rail lists.

begin
  //081 with cpi do begin
  for segment_index := 0 to 3 do begin      // !!! not to 4, uses index+1...

    xb := seg_termx[segment_index, aq];      // start x.
    xe := seg_termx[segment_index + 1, aq];    // end x.

    if xb = nodraw then
      CONTINUE;   // xb = nodraw, nothing to do yet, next segment.

    if xe = nodraw then
      EXIT;  // nothing more on this rail.

    if (aq = eRD_CurvedTurnoutWingGaugeFace) and (xe > wingx_minus) then
      xe := wingx_minus;       // 214a mods for knuckle bend
    if (aq = eRD_CurvedTurnoutWingOuterFace) and (xe > wingox_minus) then
      xe := wingox_minus;    // 214a mods for knuckle bend

    if xb > turnoutx then
      EXIT;  // nothing more on this rail.

    if xb > xe then
      CONTINUE;    // 217a

    if (plain_track = False) and (joggled = True) and
      ({cri.} main_road_crossing_rail_flag = True) and
      ((aq = eRD_CurvedStockGaugeFace) or (aq = eRD_CurvedStockOuterFace))
    // joggled turnout-side stock rail  v:0.71.a . mod v:0.76.a 27-4-02.
    then begin
      do_joggle := True;
      if segment_index = 0 then
        xe := xe - joggle_long;  // v:0.71.a  13-4-01. stop stock front at joggle.
      if segment_index = 1 then
        xb := xb - inscale;
      // v:0.71.a  13-4-01. start full joggled depth 1" in front of blade tips (arbitrary).
    end
    else
      do_joggle := False;

    if (aq = eRD_CurvedTurnoutWingGaugeFace) and (segment_index = 3) and
      (half_diamond = True) and (fixed_diamond = True) then begin
      // diagonal road crossing rail
      // leave K-crossing flangeway...
      // blunt nose of diamond point rails is typically 1/8" less than V-nose (=1/2" for FB, =5/8" for BH).
      // first do blunt nose..

      bnw := (bn_wide - 0.125) * inscale;       // width of blunt nose.
      if bnw < 0 then
        bnw := 0;
      xbn := xb + bnw * SIN(hdk / 2);

      if (xbn > startx) and (xbn < turnoutx) then begin
        if f28000(aq, xbn, fw) = 1 then
          EXIT;  // first put blunt nose at start of aq=2 list.
      end;

    end;

    if isolated_crossing = True    // 217a
    then begin
      if aq = eRD_CurvedTurnoutWingGaugeFace then
        xs := blank_start(wingx_minus - scale / 6)                  // 2" arbitrary
      else
      if aq = eRD_CurvedTurnoutWingOuterFace then
        xs := blank_start(wingox_minus - scale / 6)
      else
        xs := blank_start(xb);
    end
    else
      xs := blank_start(xb);      // start xs from xb.

    if xs > xe then
      CONTINUE;   // next segment.

    if (half_diamond = True) and (fixed_diamond = True) then
      plox_done := True             // need full blade infill for fixed diamond. 25-8-02 0.77.a.
    else
      plox_done := False;           // init 18-8-01.

    if (joggled = True) and (aq = eRD_CurvedTurnoutWingGaugeFace) and (xs = toex)
    // start aq=2 curved switch blade with the blade tip mark if joggled.
    then begin
      if f28000(aq, xs, 0 - joggle_deep) = 1 then
        EXIT;  // do curving on xs,ys and put in array.
    end;

    // 209a mods..   if xe>turnoutx then xe:=turnoutx; // !!! mod 26-3-99. smooth F4 length adjust.

    if xe > turnoutx then begin
      if (turnout_road_i > 1) and (xing_calc_i = 1)
      // 209a mods   curviform crossing           was turnout_road_i=2 217a
      then begin
        // adjustable..
        if ((aq <> eRD_CurvedStockGaugeFace) and (aq <> eRD_CurvedStockOuterFace)) or
          (turnoutx < (xorg + min_turnout_road_endx)) then
          xe := turnoutx;
        // all other rails stop at end of template
      end
      else
        xe := turnoutx;      // stop at end of template
    end;

    repeat
      // !!! mods 18-8-01 0.73.a to ensure plox occurs in the list (for neater blade infill on printing)...

      if (aq = eRD_CurvedTurnoutWingGaugeFace) and (segment_index = 2) and
        (switch_type = 0) and (xb < plox) and (xs > plox) and (plox_done = False)
      // planing and switch curve all in one for straight and curved switches...
      then begin
        xs := blank_start(plox);
        plox_done := True;
      end;

      // calc ys at this xs and put in list...

      if xs > xe then
        xs := xe;     // ensure final point is hit.

      case segment_index of     // get ys (global)..

        0:
          toe(aq);
        1:
          case switch_type of
            -1:
              straight_planing(aq, do_joggle); // semi-curved switch.

            0:
              swcurve(aq, do_joggle);
            // for straight switch or curved switch, the planing is part of the switch curve.
            // so this section draws only the joggle length in front of the toe (if joggled, and nothing otherwise, xb=xe).

            1:
              double_curved_planing(aq);  // double-curved switch planing.
            else
              run_error(68);
          end;//case

        2:
          swcurve(aq, (do_joggle = True) and (switch_type = 0));
        // this section includes planing for curved and straight switches.

        3:
          ys := radcurve(aq, xs);

        else
          run_error(69);
      end;//case

      if f28000(aq, xs, ys) = 1 then
        EXIT;     // go curve and put in list. EXIT if list full for this aq.
      //  !!! ys global?

      if ((half_diamond = False) or (fixed_diamond = False)) and
        (aq = eRD_CurvedTurnoutWingGaugeFace) and (xs < (plox + minfp{plox+incx mod 18-8-01})) then
        list_planing_mark_aq2 := nlmax_array[aq];
      // mod 25-8-98: keep note of where end of planing is in the list.
      // (curved turnout rail - turnout road blade), but not for a fixed-diamond.

      if xs >= xe then
        BREAK;    // segment done.
      xs := xs + incx;
    until 0 <> 0;           // loop.

  end;// next segment_index.
  //081 end;//with cpi
end;
//_______________________________________________________________________________________

procedure stxrail(aq: ERailData{; fl:extended});
// straight crossing part of curved turnout rail.

begin

  case aq of

    eRD_CurvedTurnoutWingGaugeFace: begin                       // turnout rail, gauge-face:
      xb := seg_termx[4, aq];      // start at end of curved part.

      //xe:=wingx;             // end at knuckle.
      xe := wingx_minus;         // 214a end at start of knuckle bend
    end;

    eRD_CurvedTurnoutWingOuterFace: begin                       // ditto, outer-edge:
      xb := seg_termx[4, aq];

      //xe:=wingox;
      xe := wingox_minus;         // 214a end at start of knuckle bend
    end;

    else
      run_error(34);
  end;//case

  if xe > xb then
    docrossing(aq, xb, xe, 1);

end;
//_______________________________________________________________________________________________________________________________

procedure stwing(aq: ERailData{; fl:extended});   // do main-side wing rail.

begin
  case aq of                     // which edge ?

    eRD_CurvedTurnoutWingGaugeFace: begin
      ys := g - fw;       // wing rail gauge face.

      //xb:=wingx;           // start at knuckle.
      xb := wingx_plus;        // 214a start at end of knuckle bend

      xe := wflarex;         // start of flare-out.
      dostr(aq, xb, xe, ys);  // fill list for parallel part.
      xb := xe;
      xe := wingendx_ms;
      // end of wing rail.
      stflare(aq, flen_mr, k5_mr, xb, xe, ys, 1, -1,
        (get_flare_type(ccd.end_diff_mr.type_diff) = 0));
      // fill list for flare-out.
    end;

    eRD_CurvedTurnoutWingOuterFace: begin
      ys := g - fw - j;     // ditto, outer edge.

      //xb:=wingox;
      xb := wingox_plus;        // 214a start at end of knuckle bend

      xe := wflarox;
      dostr(aq, xb, xe, ys);  // fill list for parallel part.
      xb := xe;
      xe := wingendox;
      stflare(aq, flen_mr, k5_mr, xb, xe, ys, 1, -1,
        (get_flare_type(ccd.end_diff_mr.type_diff) = 0));
    end;
    else
      run_error(35);
  end;//case
end;
//_______________________________________________________________________________________________________________________________

procedure doreturn(aq: ERailData; xb, xe, radmod: double);              // do return curve

var
  xs, ys: double;

begin
  xs := blank_start(xb);

  if xe > turnoutx then
    xe := turnoutx;     // stop at end of turnout. v:0.76.a  28-4-02

  if xs > (xe - minfp) then
    EXIT;  // !!! 0.76.a  18-1-02.

  repeat
    if xs > xe then
      xs := xe;                             // ensure we hit the end.
    ys := returncurve(xs, radmod);
    if abandon_calcs = True then
      EXIT;                  // snag in the calc of ys.

    if (f28000(aq, xs, ys) = 1) or (xs >= xe) then
      BREAK;    // fill list.
    xs := xs + incx;
  until 0 <> 0;
end;
//_______________________________________________________________________________________________________________________________

procedure docrossing(aq: ERailData; xb, xe: double; flway: integer);

// stcurails and cuckrail come here also.
// K-crossing MS check rails also.

var
  xs, ys, xend: double;

begin
  //if xb>xe then EXIT;     // 20-6-99.

  if isolated_crossing = True    // 217a
  then begin
    if aq = eRD_CurvedTurnoutWingGaugeFace then
      xs := blank_start(wingx_minus - scale / 6)                  // 2" arbitrary
    else
    if aq = eRD_CurvedTurnoutWingOuterFace then
      xs := blank_start(wingox_minus - scale / 6)
    else
      xs := blank_start(xb);
  end
  else
    xs := blank_start(xb);      // start xs from xb.

  xend := xe;                             // for wing angle calcs.

  // 209a mods...  if xe>turnoutx then xe:=turnoutx;     // stop at end of turnout. v:0.76.a  28-4-02

  if xe > turnoutx then begin
    if turnout_road_i < 2
    // 209a mods  not adjustable            was turnout_road_i<>2 216c
    then
      xe := turnoutx      // stop at end of template
    else begin                       // adjustable..
      if (aq <> eRD_VeeSpliceGaugeFace) and (aq <> eRD_VeeSpliceOuterFace) and
        (aq <> eRD_CurvedStockGaugeFace) and (aq <> eRD_CurvedStockOuterFace)
      // 209a not turnout exit rails
      then
        xe := turnoutx;                              // all other rails stop at end of template
    end;
  end;

  if xs > (xe - minfp) then
    EXIT;  // !!! 0.76.a  18-1-02.

  ys := 0;               //  to keep the compiler happy.

  repeat
    if xs > xe then
      xs := xe;              // ensure we hit the end.

    case aq of
      eRD_StraightTurnoutWingGaugeFace,
      eRD_StraightTurnoutWingOuterFace,
      eRD_KCrossingCheckMainSideGaugeFace,
      eRD_KCrossingCheckMainSideOuterEdge:
        ys := turnoutst_wing(aq,{fl,}xb, xend, xs);   // go calc TS wing rail (mod 27-5-01 0.71.a).

      eRD_TurnoutSideCheckGaugeFace,
      eRD_TurnoutSideCheckOuterFace:
        ys := turnoutst_check(aq,{fl,}xb, xend, xs);
        // go calc TS check rail (mod 27-5-01 0.71.a).

      else begin

        if xing_calc_i <> 1 then
          ys := turnoutst_main(aq, xb, xend, xs)      // go calc straight crossing.
        else
          ys := radcurve(aq, xs);                   // go calc curved crossing part.
      end;
    end;//case

    if abandon_calcs = True then
      EXIT;                   // snag in the calc of ys.

    if (f28000(aq, xs, ys) = 1) or (xs >= xe) then
      BREAK;    // fill list.
    xs := xs + incx;
  until 0 <> 0;
end;
//_______________________________________________________________________________________________________________________________

procedure dostr(aq: ERailData; xb, xe, ys: double);       // fill all straight rails.

var
  xs: double;        //  enter with constant ys for straight rails (except K-crossing checks, platform rear edges).
  stxmax: double;
  xxs, yys: double;
  sp, w1, w2: double;

  y_at_aq3, k_at_aq3, aq3_endx: double;  // 207b
  aq3_done: boolean;                     // 207b

  //bed_endx:double;  // 215a

begin
  yys := ys;  // for all except K-crossing check rails, platform rear edges, trackbed edges.

  if plain_track = False then
    stxmax := turnoutx     // stop at end of turnout.
  else
    stxmax := xorg;        // or stop at rail joint for plain track (approach track) only.

  if xb > stxmax then
    EXIT;        // !!! mod 26-3-99
  if xe > stxmax then
    xe := stxmax;  // !!! mod 26-3-99

  xs := blank_start(xb);
  if xs > (xe - minfp) then
    EXIT;  // !!! 0.76.a  18-1-02.

  if (plain_track = False) and (joggled = True) and (aq = eRD_StraightTurnoutWingGaugeFace) and
    (xs = setx)
  // start the aq=1 straight switch blade with the blade tip mark if joggled.
  then begin
    if f28000(aq, xs, yys + joggle_deep) = 1 then
      EXIT;
  end;

  aq3_done := False;  // init for trackbed edges

  if ((aq = eRD_AdjTrackTurnoutSideNearGaugeFace) or
    (aq = eRD_AdjTrackTurnoutSideNearOuterFace)) and (plain_track = False) and
    (adjacent_edges = True)
  // TS platform rear/front
  then begin
    if (xe > tvjpx) and (xe <= (mvjpx + scale * 3)) then
      xe := tvjpx;   // end at TVJP if not enough exit track (3ft arbitrary).
  end;

  repeat
    if xs > xe then
      xs := xe;                           // ensure we hit the end.
    if abandon_calcs = True then
      EXIT;                // snag in the calc of ys.

    // temp assume regular diamond ..

    if (aq = eRD_KCrossingCheckMainSideGaugeFace) or
      (aq = eRD_KCrossingCheckMainSideOuterEdge) then
      yys := ys + (xs - xb) / hdkn;   // K-crossing check rails (working part).

    if adjacent_edges = True      // mod straight edges
    then begin

      if aq = eRD_AdjTrackTurnoutSideNearGaugeFace           // rear edge of TS platform
      then begin

        w1 := platform_ts_start_width_ins * inscale;
        w2 := platform_ts_end_width_ins * inscale;
        sp := platform_ts_front_edge_ins * inscale - g / 2;        // 215a  sp from rail

        if ABS(xe - xb) < minfp     // no div by zero
        then
          yys := g + sp + w1
        else
          yys := g + sp + w1 + (xs - xb) * (w2 - w1) / (xe - xb);

        if yys < (g + sp) then
          yys := g + sp;  // 207a rear edge can't go in front of front edge
      end;

      if aq = eRD_AdjTrackMainSideNearGaugeFace          // rear edge of MS platform
      then begin
        w1 := platform_ms_start_width_ins * inscale;
        w2 := platform_ms_end_width_ins * inscale;
        sp := platform_ms_front_edge_ins * inscale - g / 2;        // 215a  sp from rail

        if ABS(xe - xb) < minfp     // no div by zero
        then
          yys := 0 - sp - w1
        else
          yys := 0 - sp - w1 - (xs - xb) * (w2 - w1) / (xe - xb);

        if yys > (0 - sp) then
          yys := 0 - sp;  // 207a rear edge can't go in front of front edge
      end;


      if (aq = eRD_AdjTrackTurnoutSideNearOuterFace) and (plain_track = False)
      // 207b TS platform front edge, modify ys to follow turnout curve...
      then begin

        aq3_endx := mvjpx;

        if (xs >= (aq3_endx - incx / 2)) and (xs <= (aq3_endx + incx / 2)) then
          xs := aq3_endx;        // lock list step

        if xs <= aq3_endx    // platform edge on turnout curve
        then begin
          y_at_aq3 := aq3offset(xs, k_at_aq3);

          yys :=
            y_at_aq3 + (platform_ts_front_edge_ins * inscale - g / 2) * COS(k_at_aq3);
          xxs := xs - (platform_ts_front_edge_ins * inscale - g / 2) * SIN(k_at_aq3);

          if (f28000(aq, xxs, yys) = 1) or (xxs >= xe) then
            BREAK;  // do curving on xxs,yys and put in array.

          xs := xs + incx;        // increment xs.

          CONTINUE;
        end
        else
          yys := ys;    // yys platform edge on exit track

      end;


      if (aq = eRD_AdjTrackTurnoutSideFarGaugeFace) and (aq3_done = False) and
        (plain_track = False)
      // 215a TS trackbed edge inner, modify ys to follow turnout curve...
      then begin

        aq3_endx := mvjpx + scale * 6;  // 215a to arbitrary 6ft beyond rail joints.

        if (xs >= (aq3_endx - incx / 2)) and (xs <= (aq3_endx + incx / 2)) then begin
          xs := aq3_endx;
          aq3_done := True;
        end;

        if (xs > toex) and (xs <= aq3_endx)    // trackbed edge on turnout curve
        then begin
          y_at_aq3 := aq3offset(xs, k_at_aq3);

          yys := y_at_aq3 + (trackbed_ts_width_ins * inscale - g / 2) * COS(k_at_aq3);
          xxs := xs - (trackbed_ts_width_ins * inscale - g / 2) * SIN(k_at_aq3);

          if (f28000(aq, xxs, yys) = 1) or (xxs >= xe) then
            BREAK;  // do curving on xxs,yys and put in array.

          if aq3_done = True then begin
            xs := xxs;
            yys := ys;   // reset yys on exit track
          end
          else
            xs := xs + incx;        // increment xs.

          CONTINUE;
        end;
      end;

      if (aq = eRD_AdjTrackTurnoutSideFarOuterFace) and (aq3_done = False) and
        (plain_track = False)
      // 215a TS trackbed edge outer, modify ys to follow turnout curve...
      // go further along curve to ensure an overlap with inner at short angles
      then begin
        if draw_ts_trackbed_cess_edge = True then
          aq3_endx := mvjpx + scale * 6 + cess_ts_width_ins * inscale * 3 / 2  // cess arbitrary
        else
          aq3_endx := mvjpx + scale * 6 + j * 3 / 4;                         // cut line arbitrary

        if (xs >= (aq3_endx - incx / 2)) and (xs <= (aq3_endx + incx / 2)) then begin
          xs := aq3_endx;
          aq3_done := True;
        end;

        if (xs > toex) and (xs <= aq3_endx) then begin
          y_at_aq3 := aq3offset(xs, k_at_aq3);

          if draw_ts_trackbed_cess_edge = True then begin
            yys :=
              y_at_aq3 + ((trackbed_ts_width_ins + cess_ts_width_ins) * inscale - g / 2) *
              COS(k_at_aq3);
            xxs :=
              xs - ((trackbed_ts_width_ins + cess_ts_width_ins) * inscale - g / 2) * SIN(k_at_aq3);
          end
          else begin
            yys :=
              y_at_aq3 + (trackbed_ts_width_ins * inscale + j / 2 - g / 2) * COS(k_at_aq3);
            xxs :=
              xs - (trackbed_ts_width_ins * inscale + j / 2 - g / 2) * SIN(k_at_aq3);
          end;

          if (f28000(aq, xxs, yys) = 1) or (xxs >= xe) then
            BREAK;  // do curving on xxs,yys and put in array.

          if aq3_done = True then begin
            xs := xxs;
            yys := ys;   // reset yys on exit track
          end
          else
            xs := xs + incx;        // increment xs.

          CONTINUE;
        end;
      end;

    end;

    if (f28000(aq, xs, yys) = 1) or (xs >= xe) then
      BREAK;  // do curving on xs,ys and put in array.

    if ((half_diamond = False) or (fixed_diamond = False)) and
      (aq = eRD_StraightTurnoutWingGaugeFace) and (xs < (stox + minfp{stox+incx mod 18-8-01})) then
      list_planing_mark_aq1 := nlmax_array[aq];
    // mod 25-8-98: keep note of where end of planing is in the list
    // (straight turnout rail - main road blade) but not for a fixed-diamond.

    xs := xs + incx;                                    // increment xs.
  until 0 <> 0;
end;
//________________________________________________________________________________________

procedure dostr_joggle(aq: ERailData; xb, xe, ys: double);
// fill joggled part of straight stock rail.

var
  xs, x, len, jog: double;
  stxmax: double;

begin
  if abandon_calcs = True then
    EXIT;                // snag in the calc of ys.

  if plain_track = True then
    EXIT;

  stxmax := turnoutx;

  if xb > stxmax then
    EXIT;        // !!! mod 26-3-99
  if xe > stxmax then
    xe := stxmax;  // !!! mod 26-3-99

  xs := blank_start(xb);
  if xs > (xe - minfp) then
    EXIT;  // !!! 0.76.a  18-1-02.

  repeat
    if xs > xe then
      xs := xe;                           // ensure we hit the end.

    len := plox - toex;   // length of joggle.

    if len > minfp then begin
      x := xs - xb - inscale;
      // length along planing (xb is 1" arbitrary in front of toe).
      jog := (len - x) / len * joggle_deep;  // run out the joggle. 0.71.a 13-4-01.
    end
    else
      jog := 0;    // !!! (shouldn't be here) no joggle offset.

    if (f28000(aq, xs, ys - jog) = 1) or (xs >= xe) then
      BREAK;  // do curving on xs,ys and put in array.

    xs := xs + incx;                                    // increment xs.
  until 0 <> 0;
end;
//________________________________________________________________________________________

procedure stcurail(aq: ERailData{; fl:extended});   // straight crossing part of curved stock rail.

begin
  if plain_track = False                         // not needed if plain track only in force.
  then begin
    case aq of

      eRD_CurvedStockGaugeFace: begin                     // curved stock rail, gauge-face:
        xb := seg_termx[4, aq];    // start at end of curved part.

        // 209a mods... xe:=csrendx;            // end of turnout.

        if (turnout_road_i > 1)
        // adjustable turnout road         was turnout_road_i=2 217a
        then begin
          if turnoutx > (xorg + min_turnout_road_endx)
          // template long enough?
          then
            xe := csrendx
          else
            xe := turnoutx;
        end
        else
          xe := csrendx;
      end;

      eRD_CurvedStockOuterFace: begin                     // ditto for outer-edge:
        xb := seg_termx[4, aq];

        // 209a mods...   xe:=csrendox;

        if (turnout_road_i > 1)
        // adjustable turnout road       was turnout_road_i=2 217a
        then begin
          if turnoutx > (xorg + min_turnout_road_endx)
          // template long enough?
          then
            xe := csrendox
          else
            xe := turnoutx;
        end
        else
          xe := csrendox;
      end;

      else
        run_error(36);
    end;//case

    docrossing(aq,{fl,}xb, xe, 1);              // go calc and fill list.

  end;//then
end;
//_______________________________________________________________________________________________________________________________

procedure stvee(aq: ERailData);          // straight vee rail.

var
  xb, xe, ys: double;

  endx: double;  //217a

begin
  xb := 0;
  xe := 0;
  ys := 0;            //  these to keep the compiler happy.

  if main_road_i <> 0 then
    endx := xorg + main_road_endx      // stop at end of main-road exit  217a
  else
    endx := turnoutx;                // stop at end of template.

  case aq of

    eRD_VeePointGaugeFace: begin                        // gauge-face.
      ys := g;
      xb := bnx;
      xe := endx;   //  217a  turnoutx;
    end;

    eRD_VeePointOuterFace: begin                       // outer edge.
      ys := g + j;
      xb := bnox;
      xe := endx;   //  217a  turnoutx;

    end;

    else
      run_error(37);
  end;//case

  dostr(aq, xb, xe, ys);                   // fill list.

end;
//_______________________________________________________________________________________________________________________________

procedure cuvee(aq: ERailData{; fl:extended});    // curved vee rail (up to return curve if any).

var
  xb, xe: double;

begin

  xb := 0;
  xe := 0;           //  these to keep the compiler happy.


  if (turnout_road_i > 1) and (turnoutx < (xorg + min_turnout_road_endx))
  // 209a ...      was turnout_road_i=2 217a
  then begin
    case aq of

      eRD_VeeSpliceGaugeFace: begin                        // curved vee rail, gauge-face.
        xb := bnxx;
        xe := turnoutx;
      end;

      eRD_VeeSpliceOuterFace: begin                       // ditto, outer-edge.
        xb := bnox;
        xe := turnoutx;
      end;

      else
        run_error(38);
    end;//case
  end
  else begin
    case aq of

      eRD_VeeSpliceGaugeFace: begin                        // curved vee rail, gauge-face.
        xb := bnxx;
        xe := vendx;
      end;

      eRD_VeeSpliceOuterFace: begin                       // ditto, outer-edge.
        xb := bnox;
        xe := vendox;
      end;

      else
        run_error(38);
    end;//case
  end;

  docrossing(aq,{fl,}xb, xe, 1);              // go calc it.
end;
//_______________________________________________________________________________________________________________________________

function returncurve(xs, radmod: double): double;   // calc ys, ks for return curve.
  // enter with xs.  (aq not needed.)
var
  ys: double;
  ysmod_sq: double;
  kscos: double;

begin
  if xs >= retrorgx                         // on parallel part.
  then begin
    ys := retrorgy + retr + radmod;     // continue parallel straight beyond return curve.
    ks := 0;
    Result := ys;
    EXIT;
  end;

  ysmod_sq := SQR(retr + radmod) - SQR(retrorgx - xs);
  if (ysmod_sq < minfp) or (xs <= (retrorgx - retr - radmod)) or (xs < fpx)
  // no curve fits or xs too short.
  then begin
    abandon_calcs := True;     // abandon ship.
    Result := 0;
    EXIT;
  end;

  ys := retrorgy + SQRT(ysmod_sq);    // on return curve.
  if ABS(retr + radmod) > minfp then begin
    kscos := (ys - retrorgy) / (retr + radmod);                     // mod 2-9-98
    if ABS(kscos) < (1.0 - minfp) then
      ks := ARCCOS(kscos)        // mod 10-5-99 angle for timbering.
    else
      ks := 0;
  end
  else
    ks := 0;       // zero radius? surely not. (just for completeness).
  Result := ys;
end;
//______________________________________________________________________________________

function radcurve(aq: ERailData; {fl,k5,}xs: double{; flway:integer}): double;

  // return ys along turnout curve at this xs.

var
  rto, x: double;
  ytemp, costemp, temp: double;

begin
  Result := 0;      // default init.
  //081  with cpi do begin

  if tradius_is_straight = True    //^^^ turnout radius is straight at k3 crossing angle.
  then begin
    costemp := 1 / COS(k3);
    ytemp := h + (xs - heelx) * TAN(k3);  // offset.

    case aq of                    // which rail ?
      eRD_CurvedTurnoutWingGaugeFace:
        Result := ytemp;                    // turnout-road crossing rail, gauge-face.
      eRD_CurvedStockGaugeFace:
        Result := ytemp + g * costemp;          // turnout-road stock rail, gauge-face.
      eRD_CurvedTurnoutWingOuterFace:
        Result := ytemp - j * costemp;          // turnout-road crossing rail, outer-edge.
      eRD_CurvedStockOuterFace:
        Result := ytemp + (g + j) * costemp;      // turnout-road stock rail, outer-edge.
      eRD_KCrossingCheckMainSideGaugeFace:
        Result := ytemp + fw * costemp;         // K-crossing MS check rail, gauge-face.
      eRD_KCrossingCheckMainSideOuterEdge:
        Result := ytemp + (fw + j) * costemp;     // K-crossing MS check rail, outer-edge.
      else
        run_error(67);
    end;//case

    ks := k3;
  end
  else begin
    rto := tradius;    //^^^ // to keep the compiler happy.

    case aq of                     // which rail ?
      eRD_CurvedTurnoutWingGaugeFace,
      eRD_VeeSpliceGaugeFace:
        rto := tradius;      //^^^               // trg radius.
      eRD_CurvedTurnoutWingOuterFace,
      eRD_VeeSpliceOuterFace:
        rto := tradius + j;    //^^^               // tro radius.
      eRD_CurvedStockGaugeFace:
        rto := tradius - g;                        // srg radius.
      eRD_CurvedStockOuterFace:
        rto := tradius - g - j;                      // sro radius.
      eRD_StraightTurnoutWingGaugeFace,
      eRD_StraightTurnoutWingOuterFace {,26,27}:
        rto := flarerad(aq,{fl,k5,}xs{,1});
      // turnout-side wing rail, go calc radius (flare-out).
      {// and K-crossing check rail, main-side.}

      eRD_TurnoutSideCheckGaugeFace,
      eRD_TurnoutSideCheckOuterFace:
        rto := flarerad(aq,{fl,k5,}xs{,flway}); // turnout-side check rail, (flare in or out).
      else
        run_error(68);
    end;//case

    x := 0;       // keep compiler happy.

    repeat
      if xs > (torgx + ABS(rto) * 0.98)
      // 0.98*radius, arbitrary x limits to turnout curve.  0.79.a
      then begin
        x := ABS(rto) * 0.98;        // limit x from rad centre.
        BREAK;
      end;

      if xs < (torgx - ABS(rto) * 0.98) then begin
        x := 0 - ABS(rto) * 0.98;      // limit x from rad centre.
        BREAK;
      end;

      x := xs - torgx;    // ok, x from rad centre.
      BREAK;
    until 0 <> 0;

    try
      temp := SQR(rto) - SQR(x);
      Result := torgy - SQRT(temp) * SGZ(rto);    // calc turnout curve.
      ks := ARCSIN(x / rto);                    // and gradient angle.
    except
      //081 abandon_calcs[7]:=True;       // abandon ship. Cannot be if x is under 90 degrees ?
      abandon_calcs := True;       // abandon ship. Cannot be if x is under 90 degrees ?

      Result := 0;
      EXIT;
    end;//try
  end;
  //081  end;//with cpi
end;
//_______________________________________________________________________________________________________________________________

function turnoutst_main(aq: ERailData; xb, xe, xs: double): double;
  // calc ys, ks for main turnout rails on straight section.

var
  x, yst, k3cos: double;

begin

  if xing_calc_i = 1 then
    run_error(70);   // should not be here for curviform V-crossing.

  k3cos := COS(k3);

  if ABS(k3cos) < minfp then begin
    ys := g;         // div zero abort.
    ks := 0;
    Result := ys;
    EXIT;
  end;

  x := 0;
  yst := 0;           //  these to keep the compiler happy.

  case aq of        // straight crossing, which rail ?

    // first calc offset at xb or xe point of each rail.

    eRD_CurvedTurnoutWingGaugeFace: begin
      yst := th;                               // curved turnout rail, gauge-face.
      x := xs - xb;
    end;

    eRD_CurvedTurnoutWingOuterFace: begin
      yst := th - j * COS(k3);                     // ditto, outer-edge.
      x := xs - xb;
    end;

    eRD_CurvedStockGaugeFace: begin
      yst := th + g * COS(k3);                     // curved stock rail, gauge-face.
      x := xs - xb;
    end;

    eRD_CurvedStockOuterFace: begin
      yst := th + (g + j) * COS(k3);                 // ditto, outer edge.
      x := xs - xb;
    end;

    eRD_VeeSpliceGaugeFace: begin
      yst := g + (bnx - fpx) / k3n;                 // curved vee rail, gauge face.
      x := xs - xb;
    end;

    eRD_VeeSpliceOuterFace: begin
      yst := g + j;                              // ditto, outer edge.
      x := xs - xb;
    end;

    else
      run_error(73);
  end;//case

  ys := yst + x / k3n;                   // calc along straight crossing at this x.
  ks := k3;                          // gradient angle constant.

  Result := ys;
end;
//______________________________________________________________________________________

function turnoutst_wing(aq: ERailData; {fl,}xb, xe, xs: double): double;
  // calc ys, ks for turnout-side wing rail.

  // calc ys, ks for turnout-side wing rail.
  // also for K-crossing MS check rail

var
  y_temp, fl_offset: double;

  k_temp: double;  // 0.93.a

begin
  //081  with cpi do begin

  k_temp := 0; // keep compiler happy

  case aq of
    // TS wing rail: 0.71.a 27-5-01 now using aq2offset for the TS wing rail (for long wing rail, return curve, etc.)

    eRD_StraightTurnoutWingGaugeFace: begin
      if ccd.end_diff_tr.type_diff = 3      // no flare
      then
        fl_offset := 0
      else
        fl_offset := cuflare(flen_tr, k5_tr, flarecx, flcendx, xs, 1); // flare-out offset.

      y_temp := aq2offset(xs, k_temp);
      // get y_temp to running rail and angle k_temp.   // 0.93.a  bug fix (was ks).

      if ABS(COS(k_temp)) > minfp then
        ys := y_temp + (fw + fl_offset) / COS(k_temp)  // to wing rail gauge face.
      else
        ys := fw + fl_offset;  //!!!
    end;

    eRD_StraightTurnoutWingOuterFace: begin

      case get_flare_type(ccd.end_diff_tr.type_diff) of
        1:
          fl_offset := cuflare(flen_tr, k5_tr, flarecox, flcendox, xs, 1);  // bent flares.
        else
          fl_offset := 0;
          // machined flares or none, plain outer-edge.
      end;//case

      y_temp := aq2offset(xs, k_temp);   // get y_temp to running rail.

      if ABS(COS(k_temp)) > minfp then
        ys := y_temp + (fw + j + fl_offset) / COS(k_temp) // to check rail outer edge.
      else
        ys := fw + j + fl_offset; //!!!
    end;

    // MS K-crossing check rail...

    eRD_KCrossingCheckMainSideGaugeFace: begin
      fl_offset := cuflare(flen_mk, k5_mk, kckmsflx, kckmsflendx, xs, 1); // flare-out offset.

      y_temp := aq2offset(xs, k_temp);   // get y_temp to running rail and angle.

      if ABS(COS(k_temp)) > minfp then
        ys := y_temp + (fw + fl_offset) / COS(k_temp)  // to wing rail gauge face.
      else
        ys := fw + fl_offset;  //!!!
    end;

    eRD_KCrossingCheckMainSideOuterEdge: begin
      case get_flare_type(ccd.end_diff_mk.type_diff) of
        1:
          fl_offset := cuflare(flen_mk, k5_mk, kckmsflox, kckmsflendox, xs, 1); // bent flares.
        else
          fl_offset := 0;
          // machined flares, plain outer-edge.
      end;//case

      y_temp := aq2offset(xs, k_temp);   // get y_temp to running rail.

      if ABS(COS(k_temp)) > minfp then
        ys := y_temp + (fw + j + fl_offset) / COS(k_temp) // to check rail outer edge.
      else
        ys := fw + j + fl_offset; //!!!
    end;

    else
      run_error(79);   // shouldn't be here for any other rail.

  end;//case

  Result := ys;

  //081  end;//with cpi
end;
//______________________________________________________________________________

function turnoutst_check(aq: ERailData; {fl,}xb, xe, xs: double): double;
  // calc ys, ks for turnout-side check rail.

var
  y_temp, fl_offset: double;

begin
  case aq of
    // TS check rail: 0.71.a 27-5-01 now using aq3offset for the TS check rail (for long check rails, return curve, etc.)

    eRD_TurnoutSideCheckGaugeFace: begin
      if xb < cuckfpx then
        fl_offset := cuflare(flen_tw, k5_tw, cuckx, cuckfwx, xs, -1)    // flare-in offset.
      else
        fl_offset := cuflare(flen_te, k5_te, cuckflx, cuckendx, xs, 1); // flare-out offset.

      y_temp := aq3offset(xs, ks);
      // y_temp to running rail.
      if ABS(COS(ks)) > minfp then
        ys := y_temp - (fw + fl_offset) / COS(ks)  // to check rail gauge face.
      else
        ys := g - fw - fl_offset;  //!!!
    end;

    eRD_TurnoutSideCheckOuterFace: begin                      // TS check rail outer-edge...

      if xb < cuckfpox then begin
        case get_flare_type(ccd.end_diff_tw.type_diff) of
          1:
            fl_offset := cuflare(flen_tw, k5_tw, cuckox, cuckfwox, xs, -1)
          else
            fl_offset := 0;    // machined flares, plain outer-edge.
        end;//case
      end
      else begin
        case get_flare_type(ccd.end_diff_te.type_diff) of
          1:
            fl_offset := cuflare(flen_te, k5_te, cuckflox, cuckendox, xs, 1)
          else
            fl_offset := 0;    // machined flares, plain outer-edge.
        end;//case
      end;

      y_temp := aq3offset(xs, ks);
      // y_temp to running rail.
      if ABS(COS(ks)) > minfp then
        ys := y_temp - (fw + j + fl_offset) / COS(ks) // to check rail outer edge.
      else
        ys := g - fw - j - fl_offset; //!!!
    end;

    else
      run_error(80);   // should only be here for TS check rail.
  end;//case

  Result := ys;
end;
//______________________________________________________________________________________

// mods 31-5-00 ...

procedure cuckrail(aq: ERailData);      // turnout-side check rail.

var
  xb, xe: double;

begin
  case aq of

    eRD_TurnoutSideCheckGaugeFace: begin                // gauge-face...

      if (cuckx >= 0) and (cuckfwx > 0) and (cuckox >= 0) and (cuckfwox > 0)
      // tidy start - do flare only if it's all in the template. 0.71.a  29-5-01.
      then begin
        xb := cuckx;                   // check rail start.
        xe := cuckfwx;                 // stop at end of flare-in
        docrossing(aq,{fl,}xb, xe, -1);  // fill list along flare-in
      end;

      xb := cuckfwx;                   // start at end of flare-in
      if xb < 0 then
        xb := 0;            // ensure tidy start  0.71.a  29-5-01.
      xe := cuckfpx;                   // stop opposite f.p.
      docrossing(aq,{fl,}xb, xe, -1);       // fill list up to f.p.

      xb := xe;                        // then do from f.p. to flare-out.
      xe := cuckflx;
      docrossing(aq,{fl,}xb, xe, 1);        // fill list to flare out.

      xb := xe;                        // then do flare-out.
      xe := cuckendx;
      docrossing(aq,{fl,}xb, xe, 1);        // fill list to end of flare.

    end;

    eRD_TurnoutSideCheckOuterFace: begin                    // ditto, inner-edge...

      if (cuckx >= 0) and (cuckfwx > 0) and (cuckox >= 0) and (cuckfwox > 0)
      // tidy start - do flare only if it's all in the template. 0.71.a  29-5-01.
      then begin
        xb := cuckox;                // check rail start.
        xe := cuckfwox;              // stop at end of flare-in
        docrossing(aq,{fl,}xb, xe, -1);   // fill list along flare-in
      end;

      xb := cuckfwox;                   // start at end of flare-in
      if xb < 0 then
        xb := 0;             // ensure tidy start  0.71.a  29-5-01.
      xe := cuckfpox;                   // stop opposite f.p.
      docrossing(aq,{fl,}xb, xe, -1);     // fill list up to f.p.

      xb := xe;                        // then do from f.p. to flare-out.
      xe := cuckflox;
      docrossing(aq,{fl,}xb, xe, 1);     // fill list to flare out.

      xb := xe;                        // then do flare-out.
      xe := cuckendox;
      docrossing(aq,{fl,}xb, xe, 1);     // fill list to end of flare.

    end;

    else
      run_error(87);
  end;//case
end;
//_________________________________________________________________________________________

procedure stckrail(aq: ERailData);        // main-side check rail.

var
  xb, xe, ys: double;

begin
  case aq of
    eRD_MainSideCheckGaugeFace: begin                     // gauge-face
      if (ckx_ms >= 0) and (ckfwx > 0) and (ckox >= 0) and (ckfwox > 0)
      // tidy start - do flare only if it's all in the template. 0.71.a  29-5-01.
      then begin
        xb := ckx_ms;
        xe := ckfwx;
        stflare(aq, flen_mw, k5_mw, xb, xe, fw, -1, 1,
          (get_flare_type(ccd.end_diff_mw.type_diff) = 0));     // flare-in.
      end;

      xb := ckfwx;
      if xb < 0 then
        xb := 0;             // ensure tidy start  0.71.a  29-5-01.
      xe := ckflarex;
      ys := fw;
      dostr(aq, xb, xe, ys);            // parallel part.

      xb := xe;
      xe := ckendx;
      stflare(aq, flen_me, k5_me, xb, xe, fw, 1, 1,
        (get_flare_type(ccd.end_diff_me.type_diff) = 0));
      // flare-out.
    end;

    eRD_MainSideCheckOuterFace: begin                    // outer-edge.
      if (ckx_ms >= 0) and (ckfwx > 0) and (ckox >= 0) and (ckfwox > 0)
      // tidy start - do flare only if it's all in the template. 0.71.a  29-5-01.
      then begin
        xb := ckox;
        xe := ckfwox;
        stflare(aq, flen_mw, k5_mw, xb, xe, fw + j, -1, 1,
          (get_flare_type(ccd.end_diff_mw.type_diff) = 0));   // flare-in.
      end;

      xb := ckfwox;
      if xb < 0 then
        xb := 0;             // ensure tidy start  0.71.a  29-5-01.
      xe := ckflarox;
      ys := fw + j;
      dostr(aq, xb, xe, ys);             // parallel part.

      xb := xe;
      xe := ckendox;
      stflare(aq, flen_me, k5_me, xb, xe, fw + j, 1, 1,
        (get_flare_type(ccd.end_diff_me.type_diff) = 0));
      // flare-out.
    end;

    else
      run_error(39);
  end;//case
end;
//_______________________________________________________________________________________________________________________________

procedure stflare(aq: ERailData; fl, flk, xb, xe, yfl: double; fldir: integer;
  flsgn: double; machined_end: boolean);      // fill list for straight flare.

//  flsgn  flag used in calcs, so it's a float.
var
  xs, ys, xend: double;

begin
  xs := blank_start(xb);

  xend := xe;                             // for cuflare angle calcs.
  if xe > turnoutx then
    xe := turnoutx;     // stop at end of turnout. v:0.76.a  28-4-02

  if xs > (xe - minfp) then
    EXIT;  // !!! 0.76.a  18-1-02.

  repeat
    if xs > xe then
      xs := xe;                           // ensure we hit the end.

    if (machined_end = True) and ((aq = eRD_CurvedTurnoutWingOuterFace) or
      (aq = eRD_MainSideCheckOuterFace) {or (aq=27)} or
      (aq = eRD_KCrossingCheckTurnoutSideOuterEdge))
    // MS wing or check rail outer-edges
    then
      ys := yfl                                                          // machined flares.
    else
      ys := yfl + cuflare(fl, flk, xb, xend, xs, fldir) * flsgn; // bent flares.

    if abandon_calcs = True then
      EXIT;                 // snag in the calc of ys.

    if (f28000(aq, xs, ys) = 1) or (xs >= xe) then
      BREAK;
    xs := xs + incx;                                     // increment xs.
  until 0 <> 0;
end;
//__________________________________________________________________________________________

procedure k_checkrail_ds(aq: ERailData);        // K-crossing check rail, DS.

var
  xb, xe, ys: double;

begin
  case aq of
    eRD_KCrossingCheckTurnoutSideGaugeFace: begin                     // gauge-face
      xb := kckdsx;
      xe := kckdsflx;
      ys := g - fw;
      dostr(aq, xb, xe, ys);     // parallel part.

      xb := xe;
      xe := kckdsflendx;
      stflare(aq, flen_dk, k5_dk, xb, xe, ys, 1, -1,
        (get_flare_type(ccd.end_diff_dk.type_diff) = 0));
      // fill list for flare-out.
    end;

    eRD_KCrossingCheckTurnoutSideOuterEdge: begin                    // outer-edge.
      xb := kckdsox;
      xe := kckdsflox;
      ys := g - fw - j;
      dostr(aq, xb, xe, ys);     // parallel part.

      xb := xe;
      xe := kckdsflendox;
      stflare(aq, flen_dk_oe, k5_dk, xb, xe, ys, 1, -1,
        (get_flare_type(ccd.end_diff_dk.type_diff) = 0));
      // fill list for flare-out.
    end;

    else
      run_error(139);
  end;//case
end;
//_________________________________________________________________________________________

procedure doradcurve(aq: ERailData; {fl,}xb, xe: double);            // do a turnout curve.

var
  xs, ys: double;

begin
  if xb > turnoutx then
    EXIT;             // !!! mod 26-3-99
  if xe > turnoutx then
    xe := turnoutx;     // !!! mod 26-3-99

  if isolated_crossing = True    // 217a
  then begin
    if aq = eRD_CurvedTurnoutWingGaugeFace then
      xs := blank_start(wingx_minus - scale / 6)                  // 2" arbitrary
    else
    if aq = eRD_CurvedTurnoutWingOuterFace then
      xs := blank_start(wingox_minus - scale / 6)
    else
      xs := blank_start(xb);
  end
  else
    xs := blank_start(xb);      // start xs from xb.

  if xs > (xe - minfp) then
    EXIT;  // !!! 0.76.a  18-1-02.

  repeat
    if xs > xe then
      xs := xe;                                // ensure we hit the end.
    ys := radcurve(aq,{fl,k5,}xs{,1});                     // go calc curved part.
    if abandon_calcs = True then
      EXIT;                     // snag in the calc of ys.

    if (f28000(aq, xs, ys) = 1) or (xs >= xe) then
      BREAK;       // fill list.
    xs := xs + incx;
  until 0 <> 0;
end;
//_______________________________________________________________________________________

function cuflare(fl, flk, flb, fle, xs: double; fld: integer): double;
  // calc flare-out on turnout-side wing rail.

  // enter with fl flare length along rail edge, flk flare angle
  // flb,fle x to flare start, flare end.
  // and fld flare direction. -1 = flare-in. +1 = flare-out.
  // return flare offset at this xs.

  // n.b. this routine does not need aq.
var
  gfl: double;

begin

  gfl := 0;     //  to keep the compiler happy.

  Result := 0;          //  in case of EXIT.

  if ABS(fle - flb) < minfp then
    EXIT;                       // division by zero.

  case fld of

    1: begin                                       // +1 = flare-out.
      if xs < flb then
        EXIT
      else
        gfl := (xs - flb) / (fle - flb) * fl;         // length along flare-out.
    end;
    -1: begin                                       // -1 = flare-in
      if xs > fle then
        EXIT
      else
        gfl := (fle - xs) / (fle - flb) * fl;         // length along flare-in
    end;

    else
      run_error(59);
  end;//case
  Result := gfl * SIN(flk);       // offset to this point on flare.
end;
//_________________________________________________________________________________________

function flarerad(aq: ERailData; {fl,k5,}xs: double{; flinout:integer}): double;
  // calc instantaneous radius in curved flares.

begin
  //081  with cpi do begin

  case aq of            // which rail ?
    // turnout-side wing rail, gauge face.
    eRD_StraightTurnoutWingGaugeFace:
      Result := tradius - fw - cuflare(flen_tr, k5_tr, flarecx, flcendx, xs, 1);
    // rad to this xs.
    eRD_StraightTurnoutWingOuterFace:
      Result := tradius - fw - j - cuflare(flen_tr, k5_tr, flarecox, flcendox, xs, 1);
    // ditto, outer edge

    eRD_TurnoutSideCheckGaugeFace:
      if xs < cuckfpx
      // turnout-side check rail, gauge_face     x to check rail opposite f.p.
      then
        Result := csradius + fw + cuflare(flen_tw, k5_tw, cuckx, cuckfwx, xs, -1)      // flare-in.
      else
        Result := csradius + fw + cuflare(flen_te, k5_te, cuckflx, cuckendx, xs, 1);
    // flare-out.

    eRD_TurnoutSideCheckOuterFace:
      if xs < cuckfpox           // turnout-side check rail, inner-edge:
      then
        Result := csradius + fw + j + cuflare(flen_tw, k5_tw, cuckox, cuckfwox, xs, -1)
      // flare-in.
      else
        Result := csradius + fw + j + cuflare(flen_te, k5_te, cuckflox, cuckendox, xs, 1);
      // flare-out.

    else begin
      Result := 0;
      run_error(95);
    end;

  end;//case
  //081  end;//with cpi
end;
//_________________________________________________________________________________________

function calc_slew(x, slew, slew_length: double; var y: double): boolean;

  //  x is distance into slewing zone.
  //  slew_2_kmax is used to determine the maximum value of theta for TANH. (gets closer to +/-1).
var
  theta: double;
  pin, pout: Tpex;
  temp: double;

begin
  Result := False;

  if ABS(slew_length) < minfp then begin
    y := 0;
    EXIT;
  end;

  try
    case slew_mode of

      1: begin                         // COS curve method.
        theta := x * Pi / slew_length;
        // theta is a dummy angle - runs from 0 to pi in the slewing zone.
        y := (1 - COS(theta)) * slew / 2;
        // track follows stretched cosine curve, COS(theta) runs from +1 to -1 in the slewing zone.
      end;

      2: begin         // rotated TANH curve method.

        temp := slew2_ymax - slew2_ymin;
        if ABS(temp) < minfp then begin
          y := 0;
          EXIT;
        end;

        pin.x := 0 - slew2_kmax + x * (slew2_kmax * 2) / slew_length;     // this k for tanh.
        pin.y := TANH(pin.x);                                       // tanh at this k.
        dotransform(0 - slew2_rot, 0, 0, pin, pout);
        // rotate to modify y (ignore x).

        y := (pout.y - slew2_ymin) * slew / temp;   // return shift mm  at this x mm.

      end;
    end;//case

    Result := True;
  except
    y := 0;
    Result := False;
  end;//try
end;
//________________________________________________________________________________________

procedure docurving(transform_flag, slew_flag: boolean; xs, ys: double;
  var xc, yc, tn, rn: double);
// calc curving, and call any transforms wanted.

//   Do  any slewing/curving as required.
//   Enter with xs,ys (measured along the curve).
//   (ys is from straight stock rail);
//   Return xc,yc  ,  tn rads (from template origin) ,  rn radius.

//   If transform_flag = True, perform any transformations on xc,yc.

var
  slew_over, slew_over1, slew_over2, x1, x2, y1, y2, slew_twist: double;
  delta_xs, xc1, xc2, yc1, yc2, xc_mid, yc_mid, offs: double;
  dummy1, dummy2: double;

  pc: Tpex;                        //  point  xc,yc  after slewing/curving.
  pf: Tpex;                        //  point  xc,yc  after any transforms.

  //////////////////////////////////////////////////////////////////

  procedure do_curve_calcs(xs, ys: double; var xc, yc, tn, rn: double);

  var
    ymod, tsn, xonr2, xn, yn: double;

    //======= do plain curve along r1...

    procedure do_r1;

    begin
      xc := xt1 + (r1 + ymod) * SIN(tn);
      yc := yt1 - (r1 + ymod) * COS(tn);
    end;
    //==========================================

  begin
    if (ABS(nomrad) > max_rad_test) and (spiral = False)  // straight template..
    then begin
      xc := xs;
      yc := ys;
      tn := 0;
      rn := max_rad;
      EXIT;
    end;

    ymod := ssrad1 - ys - r1;    // signed offset from nominal curve line.

    if spiral = False then begin
      // no transition, plain curve.
      {if sliding_wrap=False      // mods 0.77.a  2-8-02.
                               then}
      tn := xs / r1;
      // angle turned through. (start square to origin, at tn=0).
      {else begin
                                      if ABS(r1+ymod)>minfp     // div 0.
                                         then tn:=xs/(r1+ymod)  // mods 0.77.a  2-8-02.
                                         else tn:=xs/r1;
                                    end;}

      do_r1;       // do plain curve along r1.
      rn := r1;
    end
    else begin                       // do transition, r1-transition-r2.
      if xs > os then begin
        // zone is not r1
        tsn := xs - os + ts1;
        xonr2 := tsn - ts1 - tst;
        if xonr2 > 0 then begin                      // we are in r2 zone.
          tn := t2 + xonr2 / r2;
          xc := xt2 + (r2 + ymod) * SIN(tn);
          yc := yt2 - (r2 + ymod) * COS(tn);
          rn := r2;
        end
        else begin         // we are in the transition zone.

          if transcalcs(False, False, trans_k, tsn, xn, yn, tn, rn) = True then begin
            xc := xt0 + xn + ymod * SIN(tn);
            yc := yn - ymod * COS(tn);
          end
          else begin       // transition calcs failed
            xc := xs;
            yc := ys;
            tn := 0;
          end;
        end;
      end//then

      else begin               // we are in r1 zone.
        tn := xs / r1 + t0;     // angle turned through.
        do_r1;
        rn := r1;
      end;
    end;//else                      // end of transition coding.
  end;
  ////////////////////////////////////////////////////////////

begin

  // first do any slewing required (includes curving calcs if curved=True) ...

  if (slew_flag = True) and (slewing = True) and (slew <> 0) and (xs > slew_s)
  // into the slewing zone or beyond...
  then begin
    try
      if (ABS(slew_l) < minfp) or (xs > (slew_s + slew_l))   // beyond slewing zone..
      then begin
        do_curve_calcs(xs, ys, xc, yc, tn, rn);  // do the normal curving calcs,

        xc := xc - slew * SIN(slew_t);
        // and then push over at the slewing angle..
        yc := yc + slew * COS(slew_t);

      end
      else begin         // in slewing zone...

        delta_xs := 0.1;
        // get 3 slew_over values...

        calc_slew(xs - slew_s - delta_xs, slew, slew_l, slew_over1);
        // 0.1 mm behind the current xs
        calc_slew(xs - slew_s, slew, slew_l, slew_over);   // at the current xs
        calc_slew(xs - slew_s + delta_xs, slew, slew_l, slew_over2);
        // 0.1 mm in front of the current xs.

        do_curve_calcs(xs - delta_xs, g / 2, xc1, yc1, dummy1, dummy2);
        // points on track centre-line each side.
        do_curve_calcs(xs + delta_xs, g / 2, xc2, yc2, dummy1, dummy2);

        x1 := xc1 - slew_over1 * SIN(slew_t);        // push them over at slewing angle.
        x2 := xc2 - slew_over2 * SIN(slew_t);

        y1 := yc1 + slew_over1 * COS(slew_t);
        y2 := yc2 + slew_over2 * COS(slew_t);


        if ABS(x2 - x1) < minfp then
          slew_twist := Pi * SGZ(y2 - y1) / 2            // +/-90 degrees.
        else
          slew_twist := ARCTAN((y2 - y1) / (x2 - x1));   // and get actual slew centre-line angle.

        if (x2 - x1) < 0 then
          slew_twist := slew_twist + Pi;   // !!!!! correct any foldover.

        do_curve_calcs(xs, g / 2, xc_mid, yc_mid, dummy1, rn);
        // get current centre-line point (and return rn).

        offs := ys - g / 2;               // offset from centre-line.

        xc := xc_mid - slew_over * SIN(slew_t) - offs * SIN(slew_twist);
        // recalc into the slewing zone...
        yc := yc_mid + slew_over * COS(slew_t) + offs * COS(slew_twist);

        tn := slew_twist;     // for peg calcs.
      end;
    except
      xc := xs;
      yc := ys;
      tn := 0;
      rn := max_rad;
    end;//try
  end             // end of any slewing calcs.

  else
  if (ABS(nomrad) < max_rad_test) or (spiral = True)  // curved template...
  then
    do_curve_calcs(xs, ys, xc, yc, tn, rn)       // do the normal curving calcs.
  else begin
    xc := xs;        // normal straight track.
    yc := ys;
    tn := 0;
    rn := max_rad;
  end;

  // finally, perform any transformations...

  if transform_flag = True then begin
    pc.X := xc;
    pc.Y := yc;
    dotransform(kform, xform, yform, pc, pf);

    xc := pf.X + xshift;     // and shifts.
    yc := pf.Y + yshift;
  end;
end;
//_____________________________________________________________________________________

function f28000(aq: ERailData; xs, ys: double): integer;   // calc any curving and put in list.

var
  pc: Tpex;
  xc, yc, tc, rc: double;

begin
  Result := 0;
  //if (turnoutx<(fpx+vendx)/2) and (xs>turnoutx) then Exit;              //!!! 6-7-98. For catch points, etc.

  if xs < (startx - minfp) then
    EXIT;       // 1-11-99

  // mods 209a for adjustable turnout-road exit...

  if ((aq = eRD_CurvedStockGaugeFace) or (aq = eRD_CurvedStockOuterFace) or
    (aq = eRD_VeeSpliceGaugeFace) or (aq = eRD_VeeSpliceOuterFace) or
    (aq = eRD_TurnoutRoadCentreLine))   // turnout road
    and (turnout_road_i > 1)                                  // was turnout_road_i=2 217a
  then begin
    if xs > (xorg + turnout_road_endx + incx * 2) then
      EXIT; // no data allowed beyond this. // 209a
  end
  else begin
    if xs > (turnoutx + incx * 2) then
      EXIT; // no data allowed beyond this.
  end;

  if nlnow_array[aq] = 0          // start point of rail edge.   14-4-99
  then begin
    xy_ends[aq, 0].x := xs;
    xy_ends[aq, 0].y := ys;
  end;

  xy_ends[aq, 1].x := xs;   // cumulative end point of rail edge.
  xy_ends[aq, 1].y := ys;

  docurving(True, True, xs, ys, xc, yc, tc, rc);
  // curve and transform this xs,ys to xc,yc. (tc, rc not used here)

  pc.x := xc;
  pc.y := yc;
  Result := f29000(aq, pc);             // put in data array, and return array full flag.
end;
//___________________________________________________________________________________________

function f29000(aq: ERailData; pc: Tpex): integer;       //  Put xc,yc (in pc) in rail-data array.
  //  Change hand if required.
var
  pt: TPoint;
  n, xlist, ylist, nl: integer;

  //////////////////////////////////////////////////////

  function check_rings(n: integer): boolean;
    // check for any infringement of this ring.

    // if n=0 keep record of infringement amount (current ring).
    // all calcs in 1/100ths mm.
    // this code assumes aq remains constant on consecutive calls until line finished.

  var
    diag_distance, stepx, stepy, ring_rad: double;
    i, xlist_old, ylist_old: integer;

    //============================================

    function check_ring_point(x, y: double): double;
      // calc a single point distance from ring centre.

    begin
      Result := maxfp;  // default init, no infringement.
      try
        Result :=
          SQRT(SQR(x - rings[n, 0] * 100) + SQR(y + (y_datum - rings[n, 1]) * 100));
      except
        Result := maxfp;
      end;//try

      if (n = 0) and (Result < min_ring_distance) then
        min_ring_distance := Result;
    end;
    //===========================================

  begin
    Result := False;  // default init.

    diag_distance := check_ring_point(xlist, ylist);

    if (cl_only = True) or (warn_centrelines = True) then
      ring_rad := rings[n, 2] * 50
    // DIA!!! in 1/100ths mm (*100/2). centre-lines infringe inner diameter.
    else
      ring_rad := rings[n, 3] * 50;
    // DIA!!! in 1/100ths mm (*100/2). rails (gauge-faces) infringe outer diameter.

    if diag_distance < (ring_rad + incx125)
    // closer than 1.25*incx to ring.  1.25 arbitrary

    // and might be inside ring.
    // go back to previous point and micro-step forwards to ths one.
    then begin
      if (rings_checkpoints[n].aq = aq) and (rings_checkpoints[n].infringed)
      // same line and previous point was also.
      then begin
        xlist_old := rings_checkpoints[n].x;
        ylist_old := rings_checkpoints[n].y;

        stepx := (xlist - xlist_old) / 40;    // 40 arbitrary.
        stepy := (ylist - ylist_old) / 40;

        for i := 1 to 40 do begin

          if check_ring_point(xlist_old + stepx * i, ylist_old + stepy * i) < ring_rad then begin
            Result := True;
            // this point infringed ring.
            if n <> 0 then
              BREAK;   // don't need minimum distance for ring copies
          end;
        end;//for
      end
      else begin
        // previous was more than 1.25*incx outside ring (or was a different aq).
        // so impossible to have crossed through ring,
        // and no need to go back and use smaller steps.
        if diag_distance < ring_rad
        // but now actually inside ring?
        then
          Result := True;      // must be the first point on a new line.
      end;

      rings_checkpoints[n].x := xlist;  // for next time...
      rings_checkpoints[n].y := ylist;
      rings_checkpoints[n].infringed := True;

    end
    else
      rings_checkpoints[n].infringed := False;
    // for next time - this point more than 1.25*incx outside ring.

    rings_checkpoints[n].aq := aq;   // now on this line.
  end;//func
  ////////////////////////////////////////////////////////

begin

  //  first go convert to scale/hand, ensure all inputs are within range for 32-bits,
  //  do re-origination and distortions, round off and convert to integer.

  //  if list already full, new data overwrites final entry.

  pt := xy_to_list(pc);

  xlist := pt.X;
  ylist := pt.Y;

  nl := nlnow_array[aq];         // pick up next free index for this aq.
  nlmax_array[aq] := nl;         // and return it as current max.

  if intolist(aq, nl, pt) <> 0 then
    run_error(47);      // fill the point data.

  if nl >= (nldim_array[aq] - 1)         // max index.
  then
    Result := 1                  // flag array full. Do not bump index.
  else begin
    Inc(nlnow_array[aq]);    // bump index and save for next time.
    Result := 0;                // flag array not full.
  end;

  if (ring_warn = True) or (ring_copies_warn = True) then begin
    if ((cl_only = False) and (warn_centrelines = False) and
      (aq in [eRD_StraightStockGaugeFace..eRD_TurnoutSideCheckGaugeFace]))
      // gauge-faces for main rails only (check against OUTER ring).
      or (((cl_only = True) or (warn_centrelines = True)) and
      ((aq = eRD_MainRoadCentreLine) or (aq = eRD_TurnoutRoadCentreLine)))
    // centre-lines
    then begin
      if ring_warn = True then begin
        if check_rings(0) = True then
          ring_infringed := True;
      end;
      if (ring_copies_warn = True) and (ring_index > 0) and (ring_copies_infringed = False)
      // no need to go on checking once we have an infringement,
      then begin
        for n := 1 to ring_index do begin
          if check_rings(n) = True then
            ring_copies_infringed := True;
        end;//for
      end;
    end;
  end;
end;
//___________________________________________________________________________________________

function intolist(aq: ERailData; nl: integer; pt: TPoint): integer;

  // insert data pt into rail list,
  // and return 0 if o.k. ...
begin
  Result := 1;       // init default return

  if (nl < 0) then begin
    run_error(51);
    EXIT;
  end;

  if nl > High(xy_p[aq]) then begin
    run_error(53);     //  abandon ship if index outside limits.
    EXIT;
  end;

  xy_p[aq][nl] := pt;
  Result := 0;                  //  put data in list and flag o.k.

  if pt.X > xy_max[0] then
    xy_max[0] := pt.X;     // update max/min values for scaling calcs.
  if pt.X < xy_min[0] then
    xy_min[0] := pt.X;

  if pt.Y > xy_max[1] then
    xy_max[1] := pt.Y;     // update max/min values for scaling calcs.
  if pt.Y < xy_min[1] then
    xy_min[1] := pt.Y;
end;
//_____________________________________________________________________________________

function outoflist(aq: ERailData; nl: integer): TPoint;

  // return a value from rail list for x or y
begin
  if (nl < 0) then begin
    run_error(61);
    EXIT;
  end;

  if nl > High(xy_p[aq]) then begin
    run_error(63);     //  abandon ship if index outside limits.
    EXIT;
  end;

  Result := xy_p[aq][nl];    // get the data.
end;
//_____________________________________________________________________________________

function calc_curving: boolean;    // calc curving/transition constants.

var
  temp, xn, yn, tn, rn, x9, y9: double;

  slew_pull_back, slew_trans: double;    //!!! 1-11-99

  pin, pout: Tpex;

begin
  Result := False;                        // in case of error.

  if slewing = True   //!!! 1-11-99
  then begin
    if (ABS(slew) > slew_l) or (ABS(slew) < minfp)   // safety checks for SQRT, div by zero.
    then begin
      slew_pull_back := 0;
      slew_angle := 0;
    end
    else begin
      try
        slew_pull_back := (slew_l - SQRT(SQR(slew_l) - SQR(slew))) * 2;
        //!!! 1-11-99  *2 is arbitrary approx for shortening effect of S-curve.
        slew_angle := ARCTAN(slew_pull_back / slew);
      except
        slew_pull_back := 0;
        slew_angle := ARCTAN(2.0);
      end;//try
    end;
    slew_t := slew_angle;       //  slewing angle is same for straight track.

    if slew_mode = 2 then begin      // calc constants once only...

      if slew2_kmax < 0.02 then
        slew2_kmax := 0.02;         // safety.

      slew2_rot := ARCTAN(1 - SQR(TANH(slew2_kmax)));
      // dy/dx TANH(x) = 1-TANH^2(x).  rotation angle needed in trig units.

      pin.x := slew2_kmax;
      pin.y := TANH(slew2_kmax);
      dotransform(0 - slew2_rot, 0, 0, pin, pout);

      slew2_ymax := pout.y;
      slew2_ymin := 0 - slew2_ymax;
    end;
  end;

  if spiral = False                       // no transition
  then begin
    clrad1 := nomrad{+ycurv}; // track centre-line radius.
    ssrad1 := clrad1 + g / 2;
    // radius in main road stock rail : g/2 adjustment aways +ve, even for -ve rad.
    r1 := clrad1;             // fixed rad at track centre-line.
    xt1 := 0;                 // centre of radius...
    yt1 := r1 + g / 2;            // put straight stock rail gauge-face at datum level.

    if slewing = True then
      slew_t := slew_angle + (slew_s + (slew_l / 2)) / r1;
    // slewing angle at centre of slewing zone.

  end
  else begin                   // transition wanted - calc constants.

    //!!! these calcs are relative to the template datum.
    //!!! see also calc_transition (math_unit) for calcs based on the transition origin.

    clrad1 := nomrad1{+ycurv};  // track centre-line radius.
    ssrad1 := clrad1 + g / 2;
    // radius in main road stock rail : g/2 adjustment aways +ve, even for -ve rad.

    clrad2 := nomrad2{+ycurv};
    ssrad2 := clrad2 + g / 2;
    // radius in main road stock rail : g/2 adjustment aways +ve, even for -ve rad.

    r1 := clrad1;           // initial rad is at track centre-line.
    r2 := clrad2;           // final rad ditto.

    temp := r1 - r2;
    //if ABS(temp)<1 then temp:=SGZ(temp);    // limit to minimum difference of +/- 1 mm.

    if ABS(temp) < minfp then
      ts1 := maxfp * SGZ(temp)
    else
      ts1 := tst * r2 / temp;      // length along curve from transition origin to r1 point.

    //trans_k:=(ts1+tst)*r2;
    trans_k := ts1 * r1;                 // transition constant.

    t1 := ts1 / 2 / r1;                    // angle at r1 point.
    t2 := (tst + ts1) / 2 / r2;              // angle at r2 point.

    if transcalcs(False, True, trans_k, ts1, x9, y9, tn, rn) = False then
      EXIT;  // get  x9, y9  from transition equations (ignore tn (=t1) ).

    tos := os / r1;                     // angle turned along r1 from template origin.
    t0 := t1 - tos;
    //-ve!     // angle from centre of r1 back to template origin (-ve backwards).

    xt1 := 0 - r1 * SIN(t0);   //+ve      // x to centre of r1.
    yt1 := y9 + r1 * COS(t1);             // y to centre of r1.

    xtrans1 := xt1 + r1 * SIN(t1);        // x to r1 point.
    ytrans1 := y9;                    // y to r1 point.
    xt0 := xtrans1 - x9;                // x to transition datum.

    if transcalcs(False, True, trans_k, (ts1 + tst), xn, yn, tn, rn) = False then
      EXIT;

    xtrans2 := xt0 + xn;               // ditto for r2 point...
    ytrans2 := yn;
    xt2 := xtrans2 - r2 * SIN(t2);
    yt2 := ytrans2 + r2 * COS(t2);

    if slewing = True    //!!! 1-11-99
    then begin
      docurving(False, False, (slew_s + (slew_l / 2)), g / 2, xn, yn, slew_trans, rn);
      // get slew_trans angle at centre of slewing zone (with slew-flag off, xn,yn,rn ignored).
      slew_t := slew_angle + slew_trans;
    end;
  end;
  Result := True;
end;
//_________________________________________________________________________________________

function randomizing_warn(pdf: boolean): boolean;    // pre-init printing.

  // return False if he cancels.

const
  random_help_str: string = '    `0Output  Randomized  Timbering`9' +
    '||When timber randomizing is in force, every re-draw of the control template on the trackpad produces a fresh randomized effect.' +
    '||To "freeze" a randomized timbering layout for printing identical multiple copies of a template, click the `0MAIN > STORE & BACKGROUND`1 menu item to copy the template to the background drawing,' + ' and then click the `0OUTPUT > PRINT BACKGROUND TEMPLATES (TRACK PLAN)`1 menu item.' + '||To create a fresh randomized layout for a background template, click the `0GENERATOR > REBUILD`1 menu options.' + '||You should make as many print copies as you will need all in one Templot0 session, because it is not possible to save the exact timbering layout between sessions.' + ' When reloaded from a data file, the template will be rebuilt with a fresh randomized timbering layout.' + '||Alternatively, if you create a PDF file you can print identical copies at any time using a PDF reader program.';

var
  i: integer;

begin
  Result := False;       // default init.

  if (no_printer_available = True) and (pdf = False) then begin
    alert(6, '   no  printer',
      'Templot is unable to locate a printer on this system.' +
      '||If you have recently installed a printer, please save your work and restart Templot0.',
      '', '', '', '', '', 'O K', 0);
    EXIT;
  end;

  if (random_flag = True) and (print_entire_pad_flag = False) then begin
    repeat
      i := alert(3, '     timber  randomizing',
        '||You are about to print or create a PDF file of the control template with timber randomizing in force.'
        + '||It will not be possible to repeat the same timbering arrangement again later.'
        + '||To make multiple identical prints of a template containing randomized timbers, the template must be a background template.', '', '', '', 'more  information', 'cancel  output', 'O K  - continue', 4);
      case i of
        4:
          alert_help(0, random_help_str, '');
        5:
          EXIT;
      end;//case
    until i <> 4;
  end;

  //cancel_adjusts(False);
  Result := True;
end;
//_______________________________________________________________________________________________________________

function small_scale_hints: boolean;

const
  small_help_str: string =
    'When printing a complete track plan at a reduced size, you will not usually need the timber outline extension marks, which are intended as a full-size construction aid.' + '||Similarly the timber centre-line markings may not be needed, and the timber numbers may be printed illegibly small.' + '||For a neater printed result, all these features can be switched off.' + ' To do this, cancel printing then de-select the|`0GENERATOR > GENERATOR SETTINGS > OUTLINE EXTENSION MARKS`1 and/or|`0GENERATOR > GENERATOR SETTINGS > TIMBER CENTRE-LINES`1 menu items.' + '||Then if you are printing the entire trackpad click the|`0GENERATOR > REBUILD ALL BACKGROUND`1 menu item.' + '||When printing at a very small size, you may prefer to omit the timbering entirely. To do this, instead of the above you can simply select the ' + '`0OUTPUT > OUTPUT DRAWING OPTIONS > ELEMENT OPTIONS...`1 menu item and de-select the `0TIMBERING`1 option. In this case the timbering on the screen is unchanged.' + '||The timber numbering can be omitted from reduced size printing by selecting the ' + '`0OUTPUT > OUTPUT DRAWING OPTIONS > TIMBER NUMBERING > ON FULL-SIZE OUTPUT ONLY or OMIT ALL TIMBER NUMBERING`1 menu options.' + '||When printing the timber numbers, Templot0 normally scales the font size to match the output size, and omits the numbers if they would be too small to be of any use.' + '||Alternatively, if the `0OUTPUT > OUTPUT DRAWING OPTIONS > TIMBER NUMBERING > SCALE TIMBER NUMBERING`1 menu option is de-selected,' + ' the numbers will be printed at whatever font size you specify by selecting the `0OUTPUT > OUTPUT DRAWING OPTIONS > TIMBER NUMBERING > FONT FOR TIMBER NUMBERING`1 menu item.';
var
  i: integer;
  size_str: string;

begin
  Result := False;

  if small_print_msg_pref = True then
    EXIT;

  with pad_form do begin
    if ((out_factor < 0.7) or (fit_single_sheet = True)) and
      {(print_timbering_menu_entry.Checked=True)}// 0.82.b
      (print_settings_form.output_timbering_checkbox.Checked = True) then begin
      if out_factor < 0.7 then
        size_str := round_str(out_factor * 100, 2) + '% of full-size'
      else
        size_str := 'a reduced size';

      if ((timber_outlines_menu_entry.Checked = True) and
        ((outline_extensions_menu_entry.Checked = True) or
        (timber_centres_menu_entry.Checked = True))) or
        ((print_timber_numbering_menu_entry.Checked = True) and
        (timber_numbers_menu_entry.Checked = True)) then begin

        alert_box.preferences_checkbox.Checked := False;       //%%%%
        alert_box.preferences_checkbox.Show;

        repeat
          i := alert(3, '    small  size  output',
            '||You are about to print or create a PDF file at ' + size_str +
            ' with timber outline extension marks or timber centre-lines switched on.' +
            '||For a neater result when printing at a reduced size these features can be switched off.',
            '', '', '', 'more  information', 'cancel  output', 'O K', 4);
          if i = 4 then
            alert_help(0, '    `0Small  Size  Output`9||You are about to print or create a PDF file at '
              + size_str + '.||' + small_help_str, '');

          //%%%% was "today"

        until i <> 4;

        small_print_msg_pref := alert_box.preferences_checkbox.Checked;    //%%%%
        alert_box.preferences_checkbox.Hide;

        if i = 5 then
          Result := True;

      end;
    end;
  end;//with
end;
//____________________________________________________________________________________________

procedure print_control_template(pdf: boolean);  // 0.91.d

var
  i, kludge_count: integer;

begin
  show_modal_message('print_control_template');
  if pdf = True then
    export_form.Hide;

  print_form.diagram_mode_radiobutton.Enabled := False;
  pdf_form.diagram_mode_radiobutton.Enabled := False;

  try
    if output_diagram_mode = True then begin
      repeat
        i := alert(2, '    diagram  mode', '||The output is currently set for diagram mode.' +
          '||The control template can not be printed or output in diagram mode.' +
          '||Diagram mode is intended for background templates only, to display a track plan.| ',
          '', '', '', '? output  mode  -  help', 'cancel',
          'change  to  detail  mode  and  continue', 4);

        if i = 4 then
          alert_help(-300, output_mode_help_str, '');

      until i <> 4;

      if i = 5 then
        EXIT;

      pad_form.output_detail_mode_menu_entry.Click;
    end;

    print_entire_pad_flag := False;  // output the control template only

    if print_now_bang = False   // 0.93.a
    then begin

      if small_scale_hints = True then
        EXIT;         // he cancelled.
      if randomizing_warn(pdf) = False then
        EXIT;    // he cancelled.

      if (pdf = False) and (printer_setup_done = False) then
        printer_setup(False, False);   // must do setup at least once.
    end;

    //now on export form.  if pdf=True then get_pdf_dims;  // get PDF page sizes from user.

    if paper_bunching = True then
      cancel_paper_bunching;  // don't want bunching in the printing.

    kludge_count := create_fb_kludge_templates;  // 0.94.a  if any

    if pdf = True       // 0.91.d pdf
    then begin
      pad_caption('    create  PDF  file  from  the  control  template');

      if show_margins = 1 then
        show_margins := 2;   // change page outlines on pad, if showing for printer

      pdf_draw;     // go create PDF.

    end
    else begin        // normal print

      pad_caption('F11    print  the  control  template');

      if show_margins = 2 then
        show_margins := 1;   // change page outlines on pad, if showing for PDF

      print_draw;   // go do the print.
    end;

    if kludge_count > 0 then
      delete_fb_kludge_templates;  // 0.94.a  if any

    cancel_adjusts(False);                    //  update the caption.

    redraw_pad(False, False);                  //  force a redraw when finished.

  finally
    if (pdf = True) and (external_window_showing = False) then begin
      export_form.Show;
      export_form.BringToFront;
    end;
  end;//try

end;
//_______________________________________________________________________________________________________________________________

procedure print_entire_pad(pdf: boolean);  // 0.91.d

var
  kludge_count: integer;

begin
  if pdf = True then
    export_form.Hide;

  print_form.diagram_mode_radiobutton.Enabled := True;
  pdf_form.diagram_mode_radiobutton.Enabled := True;

  try

    print_entire_pad_flag := True;

    if print_now_bang = False   // 0.93.a
    then begin

      if small_scale_hints = True then
        EXIT;         // he cancelled.
      if randomizing_warn(pdf) = False then
        EXIT;    // he cancelled.

      if (pdf = False) and (printer_setup_done = False) then
        printer_setup(False, False);   // must do setup at least once.
    end;

    if classic_templot = False then
      store_and_background(False, True);
    // 0.93.a Quick mode - first store existing control template

    // now on export form.   if pdf=True then get_pdf_dims;  // get PDF page sizes from user.

    if paper_bunching = True then
      cancel_paper_bunching;  // don't want bunching in the print.

    if output_diagram_mode = False then
      kludge_count := create_fb_kludge_templates  // 0.94.a  if any
    else
      kludge_count := 0;

    if pdf = True       // 0.91.d pdf
    then begin

      if print_group_only_flag = True then
        pad_caption('    create  PDF  file  from  group  only')
      else
        pad_caption('    create  PDF  file  from  all  background  templates');

      if show_margins = 1 then
        show_margins := 2;   // change page outlines on pad, if showing for printer

      pdf_draw;

    end
    else begin        // normal print

      if print_group_only_flag = True then
        pad_caption('    print  group  only')
      else
        pad_caption('CTRL-F11    print  all  background  templates');

      {printing_in_progress:=}

      if show_margins = 2 then
        show_margins := 1;   // change page outlines on pad, if showing for PDF

      print_draw;         // go do the print.
    end;

    if kludge_count > 0 then
      delete_fb_kludge_templates;  // 0.94.a  if any

    cancel_adjusts(False);                    //  update the caption.

    redraw_pad(False, False);                  //  force a redraw when finished.

  finally
    if (pdf = True) and (external_window_showing = False) then begin
      export_form.Show;
      export_form.BringToFront;
    end;
  end;//try

end;
//______________________________________________________________________________

procedure action_panel_hint(hint_str: string);   // 205c  set hollow-triangle mouse action hint

// if hint_str='' set to default (last mouse action).

begin
  with action_form do begin
    if hint_str = '' then
      image_panel.Hint := ' repeat last mouse action '
    else
      image_panel.Hint := ' ' + hint_str + ' ';

    action_1_image.Hint := image_panel.Hint;
    action_2_image.Hint := image_panel.Hint;

  end;//with
end;
//______________________________________________________________________________

procedure cancel_adjusts(new_action: boolean);  //  cancel all adjusts and restore flags, etc..
//  if new_action=True we are swapping actions, no need to close the action panel.
var
  mps: TPoint;

begin

  with pad_form do begin

    //mouse_draw_menu_entry.Checked:=False;  // no more mouse drawing.

    mouse_draw_lines := False;
    mouse_drawing_in_progress := False;

    mouse_action_release(True);
    mouse_modify := -1;          // and then cancel any action selected.

    //pad_caption('..    F12    pad  re - drawn    ( mouse  actions  cancelled )');

    pad_caption('..    [  no  mouse  actions  active  ]');   // 0.82.d

    pad_form.cancel_mouse_action_popup_entry.Enabled := False;

    // save current adjust for repeat, and do any updates ...

    if spot_mod = 1 then
      repeat_last_index := 0;
    if zoom_mod = 1 then
      repeat_last_index := 1;
    if datum_mod = 1 then
      repeat_last_index := 2;
    if peg_mod = 1 then
      repeat_last_index := 3;
    if notch_mod = 1 then begin
      repeat_last_index := 4;
      Inc(notch_index);                             // to next rollback slot.
      if notch_index > notch_c then
        notch_index := 0;
      undo_notch[notch_index] := get_current_notch;   // save notch in this slot...
    end;

    if out_factor_mod = 1 then
      repeat_last_index := 5;
    if shove_along_mod = 1 then
      repeat_last_index := 6;
    if shove_throw_mod = 1 then
      repeat_last_index := 7;
    if trans_length_mod = 1 then
      repeat_last_index := 8;
    if trans_start_mod = 1 then
      repeat_last_index := 9;
    if slew_amount_mod = 1 then
      repeat_last_index := 10;
    if slew_length_mod = 1 then
      repeat_last_index := 11;
    if slew_start_mod = 1 then
      repeat_last_index := 12;
    if length_mod = 1 then
      repeat_last_index := 13;
    if approach_mod = 1 then
      repeat_last_index := 14;
    if shift_mod = 1 then
      repeat_last_index := 15;
    if slide_mod = 1 then
      repeat_last_index := 16;
    if ring_mod = 1 then
      repeat_last_index := 17;
    if shift_keeps_mod = 1 then
      repeat_last_index := 18;
    if twist_keeps_mod = 1 then
      repeat_last_index := 19;
    if zoffset_mod = 1 then
      repeat_last_index := 20;
    if twist_mod = 1 then
      repeat_last_index := 21;
    if orbit_mod = 1 then
      repeat_last_index := 22;
    if both_mod = 1 then
      repeat_last_index := 23;
    if sx_mod = 1 then
      repeat_last_index := 24;
    if curving_mod = 1 then
      repeat_last_index := 25;
    if roam_mod = 1 then
      repeat_last_index := 26;
    if slew_factor_mod = 1 then
      repeat_last_index := 27;
    if bunch_mod = 1 then
      repeat_last_index := 28;
    if porg_mod = 1 then
      repeat_last_index := 29;

    if corner1_mod = 1 then
      repeat_last_index := 30;
    if corner2_mod = 1 then
      repeat_last_index := 31;

    if oneshape_shift_mod = 1 then
      repeat_last_index := 32;
    if allshapes_shift_mod = 1 then
      repeat_last_index := 33;

    if snake_mod = 1 then
      repeat_last_index := 34;

    if allshapes_scale_mod = 1 then
      repeat_last_index := 35;
    if allshapes_rotate_mod = 1 then
      repeat_last_index := 36;

    if oneshape_scale_mod = 1 then
      repeat_last_index := 37;

    if shove_length_mod = 1 then
      repeat_last_index := 38;
    if shove_width_mod = 1 then
      repeat_last_index := 39;
    if shove_twist_mod = 1 then
      repeat_last_index := 40;

    if blanking_mod = 1 then
      repeat_last_index := 41;

    if roll_mod = 1 then
      repeat_last_index := 42;

    if ringdia_mod = 1 then
      repeat_last_index := 43;

    if ruler1_mod = 1 then
      repeat_last_index := 44;   // 0.78.a
    if ruler2_mod = 1 then
      repeat_last_index := 45;

    if swell_mod = 1 then
      repeat_last_index := 46;   // 0.78.c

    if shove_crab_mod = 1 then
      repeat_last_index := 47;   // 0.78.c

    if move_labels_mod = 1                                   // 0.82.d
    then begin
      if (xshift_labels <> 0) or (yshift_labels <> 0) then begin
        save_done := False;
        backup_wanted := True;      // save moved labels if any.
      end;
      repeat_last_index := 48;
    end;

    if entry_straight_mod = 1 then
      repeat_last_index := 49;   // 0.91.b


    if plat_ts_start_mod = 1 then
      repeat_last_index := 50;  // 0.93.a ...
    if plat_ts_length_mod = 1 then
      repeat_last_index := 51;
    if plat_ts_width1_mod = 1 then
      repeat_last_index := 52;
    if plat_ts_width2_mod = 1 then
      repeat_last_index := 53;

    if plat_ms_start_mod = 1 then
      repeat_last_index := 54;
    if plat_ms_length_mod = 1 then
      repeat_last_index := 55;
    if plat_ms_width1_mod = 1 then
      repeat_last_index := 56;
    if plat_ms_width2_mod = 1 then
      repeat_last_index := 57;

    if gaunt_offset_mod = 1 then
      repeat_last_index := 58;  // SHIFT+F12  // 0.93.a ex 081
    if vee_mod = 1 then
      repeat_last_index := 59;  // F9         // 0.93.a ex 081
    if hdk_mod = 1 then
      repeat_last_index := 60;  // F10        // 0.93.a ex 081

    if rect_left_mod = 1 then
      repeat_last_index := 61;  // output boundary rectangle 0.93.a ...
    if rect_right_mod = 1 then
      repeat_last_index := 62;
    if rect_top_mod = 1 then
      repeat_last_index := 63;
    if rect_bottom_mod = 1 then
      repeat_last_index := 64;
    if rect_move_mod = 1 then
      repeat_last_index := 65;

    if check_diffs_len_mod = 1 then
      repeat_last_index := 66;    // 0.94.a
    if check_diffs_flare_mod = 1 then
      repeat_last_index := 67;    // 0.94.a
    if check_diffs_gap_mod = 1 then
      repeat_last_index := 68;    // 0.94.a

    if dv_mod = 1 then
      repeat_last_index := 69;    // 0.98.a
    if dv_clear_mod = 1 then
      repeat_last_index := 70;    // 0.98.a


    if plat_ms_skew1_mod = 1 then
      repeat_last_index := 71;    // 207a
    if plat_ms_skew2_mod = 1 then
      repeat_last_index := 72;    // 207a
    if plat_ts_skew1_mod = 1 then
      repeat_last_index := 73;    // 207a
    if plat_ts_skew2_mod = 1 then
      repeat_last_index := 74;    // 207a

    if turnout_road_mod = 1 then
      repeat_last_index := 75;    // 209a  CTRL+F12

    if adjacent_ts_mod = 1 then
      repeat_last_index := 76;     // 213a
    if adjacent_ms_mod = 1 then
      repeat_last_index := 77;     // 213a

    if edge_ts_start_mod = 1 then
      repeat_last_index := 78;       // 215a...
    if edge_ts_length_mod = 1 then
      repeat_last_index := 79;

    if edge_ms_start_mod = 1 then
      repeat_last_index := 80;
    if edge_ms_length_mod = 1 then
      repeat_last_index := 81;

    if main_road_mod = 1 then
      repeat_last_index := 82;       // 217a

    if gaunt_radius_mod = 1 then
      repeat_last_index := 83;       // 217b

    if (adjacent_ts_mod = 1) and (grid_form.Showing = False) then begin
      if alert(3, '    adjust  adjacent  track  centres  TS',
        '||Do you now want to return the centre-line to its normal position ?' +
        '||This will not change the setting you have made for the TS adjacent track centres.' +
        '||If you want to roll the dummy vehicle tool along the adjacent centre-line, leave it where it is for now.',
        '', '', '', 'leave  unchanged', '', 'return  centre - line  to  normal', 0) = 6 then begin
        cl_options_code := 0;
        redraw(True);
      end;
    end;

    if (adjacent_ms_mod = 1) and (grid_form.Showing = False) then begin
      if alert(3, '    adjust  adjacent  track  centres  MS',
        '||Do you now want to return the centre-line to its normal position ?' +
        '||This will not change the setting you have made for the MS adjacent track centres.' +
        '||If you want to roll the dummy vehicle tool along the adjacent centre-line, leave it where it is for now.',
        '', '', '', 'leave  unchanged', '', 'return  centre - line  to  normal', 0) = 6 then begin
        cl_options_code := 0;
        redraw(True);
      end;
    end;

    //  then cancel them...

    spot_mod := 0;
    zoom_mod := 0;
    datum_mod := 0;
    peg_mod := 0;
    notch_mod := 0;
    out_factor_mod := 0;

    shove_along_mod := 0;
    shove_throw_mod := 0;
    shove_crab_mod := 0;
    shove_length_mod := 0;
    shove_width_mod := 0;
    shove_twist_mod := 0;

    trans_length_mod := 0;
    trans_start_mod := 0;

    slew_factor_mod := 0;
    slew_amount_mod := 0;
    slew_length_mod := 0;
    slew_start_mod := 0;

    length_mod := 0;
    approach_mod := 0;
    blanking_mod := 0;
    shift_mod := 0;
    slide_mod := 0;
    snake_mod := 0;
    ring_mod := 0;
    ringdia_mod := 0;
    shift_keeps_mod := 0;
    twist_keeps_mod := 0;
    zoffset_mod := 0;
    porg_mod := 0;

    dv_mod := 0;        // 0.98.a
    dv_clear_mod := 0;  // 0.98.a

    corner1_mod := 0;
    corner2_mod := 0;
    oneshape_shift_mod := 0;
    oneshape_scale_mod := 0;

    allshapes_shift_mod := 0;
    allshapes_scale_mod := 0;
    allshapes_rotate_mod := 0;

    bunch_mod := 0;
    twist_mod := 0;
    orbit_mod := 0;
    both_mod := 0;
    sx_mod := 0;
    curving_mod := 0;
    roam_mod := 0;
    roll_mod := 0;

    entry_straight_mod := 0;  // 0.91.b

    ruler1_mod := 0;
    ruler2_mod := 0;

    swell_mod := 0;

    move_labels_mod := 0;  // 0.82.d


    plat_ts_start_mod := 0;  // 0.93.a ...
    plat_ts_length_mod := 0;
    plat_ts_width1_mod := 0;
    plat_ts_width2_mod := 0;

    plat_ms_start_mod := 0;
    plat_ms_length_mod := 0;
    plat_ms_width1_mod := 0;
    plat_ms_width2_mod := 0;

    gaunt_offset_mod := 0;  // SHIFT+F12  // 0.93.a ex 081
    vee_mod := 0;           // F9         // 0.93.a ex 081
    hdk_mod := 0;           // F10        // 0.93.a ex 081

    rect_left_mod := 0;  // output boundary rectangle 0.93.a ...
    rect_right_mod := 0;
    rect_top_mod := 0;
    rect_bottom_mod := 0;
    rect_move_mod := 0;

    check_diffs_len_mod := 0;     // 0.94.a
    check_diffs_flare_mod := 0;   // 0.94.a
    check_diffs_gap_mod := 0;     // 0.94.a

    plat_ms_skew1_mod := 0;  // 207a
    plat_ms_skew2_mod := 0;  // 207a
    plat_ts_skew1_mod := 0;  // 207a
    plat_ts_skew2_mod := 0;  // 207a

    turnout_road_mod := 0;   // 209a  CTRL+F12

    adjacent_ts_mod := 0;    // 213a
    adjacent_ms_mod := 0;    // 213a

    edge_ts_start_mod := 0;       // 215a...
    edge_ts_length_mod := 0;

    edge_ms_start_mod := 0;
    edge_ms_length_mod := 0;

    main_road_mod := 0;     // 217a

    gaunt_radius_mod := 0;  // 217b

    //------------

    //shove_in_progress_str:='';

    select_centre := False;

    zoom_rectangle := False;
    group_fence_rectangle := False;
    output_boundary_rectangle := False;  // 0.93.a
    drawn_shape_rectangle := False;            // 214a

    rectangle_in_progress := False;
    rectangle_exists := False;

    panning_form.zoom_rectangle_latching_toolbutton.Down := False;
    pad_form.zoom_rectangle_latching_toolbutton.Down := False;
    pad_form.group_fence_latching_toolbutton.Down := False;
    pad_form.output_rectangle_latching_toolbutton.Down := False;  // 0.93.a

    //click_current:=False;

    click_bgnd_select := False;
    shift_click := False;
    name_highlighted := -1;    // remove any selection highlighting.

    lock_xing_popup_entry.Enabled := False;      // these only valid in F5...
    lock_switch_popup_entry.Enabled := False;

    unlock_both;

    if dummy_label_panel.Showing = True    // finished any label moving.
    then begin
      clicked_keep_index := -1;    // so can popup again.
      dummy_label_panel.Hide;    // finished moving.
    end;

    if (xshift_keeps <> 0) or (yshift_keeps <> 0)      // update after mouse shift all keeps.
    then begin
      Screen.Cursor := crHourglass;
      shift_all_group;
      if kform_keeps = 0 then
        rebuild_group(False, False);   // no need to do this if it will be done again below.
    end;

    if kform_keeps <> 0      // update after mouse twist all keeps.
    then begin
      Screen.Cursor := crHourglass;
      twist_all_group;
      rebuild_group(False, False);
    end;

    action_panel_hint(''); // 205c  reset hollow-triangle hint to default (last mouse action).

    Screen.Cursor := crDefault;
    Cursor := crDefault;

    if GetCursorPos(mps) = False then begin
      mps.X := 0;
      mps.Y := 0;
    end;

    SetCursorPos(mps.X, mps.Y);
    // need a mouse move event to ensure pad cursor setting after any screen cursor change.

  end;//with

  if bgnd_form_closed = True then
    bgnd_form.Show;
  // was closed for mouse actions from the shapes form buttons, so show it again now.
  bgnd_form_closed := False;

  {  !!! problems closing action panel if rapid mouse action swaps. panel closing now done via a timer...  15-4-00}

  if new_action = False then begin
    action_form.action_panel_timer.Enabled := True;
    allow_idle := not control_room_form.fast_100_menu_entry.Checked;
    // no mouse action - allow idle again (belt and braces - should have been done when the mouse action was released).
  end;
end;
//________________________________________________________________________________________

procedure trail_length(X: integer);

var
  dir: double;

begin
  if (peg_code = 11) or (peg_code = 600)   //  0.79.a  29-05-06
  then
    dir := -1                      //  change direction if peg on length.
  else
    dir := 1;

  //turnoutx:=endx_now*(X/length_now);

  turnoutx := endx_now + (X - length_now) * dir * ffx;
  //  ffx in mm per pixel at mouse-down.
  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;

  if plain_track = False then begin
    if turnoutx < xorg then
      turnoutx := xorg;        //  limit min to approach track for turnouts.
  end
  else begin
    if turnoutx < 0 then
      turnoutx := 0;              //  limit min to zero for plain track,
    xorg := turnoutx;                              //  and ensure xorg matches.
  end;

  turnout_i := 1;      // length locked at new turnoutx.

  if (peg_code = 11) or (peg_code = 600)   // CTRL-9 or TOLP        // 0.79.a  29-05-06
  then begin                                                        // peg is on length...
    pegx := turnoutx;
    if spiral = True then
      os := os_now - (pegx_now - pegx);            //  keep transition start constant.
    if slewing = True then
      slew_s := slew_s_now - (pegx_now - pegx);   //  slewing ditto.
    peg_curve;        // keep peg constant.
  end;

  if peg_code = 19   // peg on mid-length, extend both ways.  0.76.a  5-11-01.
  then begin
    pegx := turnoutx / 2;                                          // get new mid pegx.
    if spiral = True then
      os := os_now - (pegx_now - pegx);            //  keep transition start constant.
    if slewing = True then
      slew_s := slew_s_now - (pegx_now - pegx);   //  slewing ditto.
    peg_curve;
  end;


  //csi.switch_radius_inchormax:=50000-turnoutx*20;   //debug

end;
//__________________________________________________________________________________________

procedure trail_approach(X: integer);

var
  dir: double;

begin
  if peg_code = 0 then
    dir := 1
  else
    dir := -1;                       //  change direction unless peg is reset on rail-end.

  xorg := xorg_now + (X - approach_now) * dir * ffx;
  //  ffx in mm per pixel at mouse-down.
  if xorg < 0 then
    xorg := 0;                           //  xorg mustn't go negative.

  if plain_track = False then begin
    turnoutx := turnoutx_now - xorg_now + xorg;
    //  xorg changes reflected in turnoutx.
    if turnoutx > turnoutx_max then
      turnoutx := turnoutx_max;
    if turnoutx < xorg then
      turnoutx := xorg;
  end
  else begin
    if xorg > turnoutx_max then
      xorg := turnoutx_max;     // keep turnoutx=xorg for plain track
    turnoutx := xorg;
  end;

  turnout_i := 1;      // length locked at new turnoutx.

  if (peg_code <> 0) and (peg_code <> 19) then begin
    pegx := pegx_now - xorg_now + xorg;
    //  pegx changes with xorg unless peg is reset on rail-end, or at mid-point.
    if spiral = True then
      os := os_now - xorg_now + xorg;            //  os transition start changes with xorg ditto.
    if slewing = True then
      slew_s := slew_s_now - xorg_now + xorg;   //  slewing ditto.
  end;

  if peg_code = 19   // peg on mid-length, extend both ways.  0.76.a  5-11-01.
  then begin
    pegx := turnoutx / 2;                                               // get new mid pegx.
    if spiral = True then
      os := os_now + (pegx_now - pegx) - xorg_now + xorg;
    //  os transition start changes with xorg ditto.
    if slewing = True then
      slew_s := slew_s_now + (pegx_now - pegx) - xorg_now + xorg;   //  slewing ditto.
  end;

  udpegx := udpegx_now - xorg_now + xorg;      //  user-defined peg position.

  peg_curve;  // keep template on the peg.
end;
//___________________________________________________________________________________________

procedure trail_roam(X: integer);      // change xorg but maintain turnoutx constant.

begin
  if plain_track = True then
    EXIT;                //  !!! shouldn't be here.

  xorg := xorg_now + (X - roam_now) * ffx;
  //  ffx in mm per pixel at mouse-down.
  if xorg < 0 then
    xorg := 0;                                  //  xorg mustn't go negative.
  if xorg > (turnoutx - toel * 2) then
    xorg := turnoutx - toel * 2;    //  or greater than this (arbitrary).

  pegx := pegx_now - xorg_now + xorg;
  //  correct peg position in case not on a pre-set.
  udpegx := udpegx_now - xorg_now + xorg;                        //  and user-defined peg position.

  turnout_i := 1;      // length locked at turnoutx.
end;
//___________________________________________________________________________________________

procedure trail_roll(X: integer);      // CTRL-F4  roll rails and sleepers

begin
  tb_roll_percent := tb_roll_percent_now + (roll_now - X) * tb_roll_factor;

  if tb_roll_percent < 0 then
    tb_roll_percent := 0;
  if tb_roll_percent > 100 then
    tb_roll_percent := 100;

  //  ffx in mm per pixel at mouse-down.
end;
//_________________________________________________________________________________________

procedure trail_blanking(X: integer);      // change startx.

begin
  if plain_track = True then
    EXIT;                //  !!! shouldn't be here.
  startx := startx_now + (X - blanking_now) * ffx;
  // ffx in mm per pixel at mouse-down.
  if startx > (turnoutx - 3 * inscale) then
    startx := turnoutx - 3 * inscale;  // 3" scale arbitrary maximum blanking.
  if (half_diamond = False) and (startx < 0) then
    startx := 0;
end;
//___________________________________________________________________________________________

procedure trail_turnout_road(X: integer);   // 209a  CTRL+F12

begin
  if plain_track = True then
    EXIT;                //  !!! shouldn't be here.

  turnout_road_endx := turnout_road_endx_now + (X - turnout_road_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if turnout_road_endx < min_turnout_road_endx then
    turnout_road_endx := min_turnout_road_endx;  // 213b

  if peg_code = 241   // TEXITP        // 213b
  then begin
    pegx := xorg + turnout_road_endx;
    peg_curve;        // keep peg constant.
  end;
end;
//______________________________________________________________________________

procedure trail_main_road(X: integer);   // 217a

begin
  if plain_track = True then
    EXIT;                //  !!! shouldn't be here.

  main_road_endx := main_road_endx_now + (X - main_road_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if main_road_endx < min_main_road_endx then
    main_road_endx := min_main_road_endx;  // 213b

  if peg_code = 261   // MEXITP        // 217a
  then begin
    pegx := xorg + main_road_endx;
    peg_curve;                    // keep peg constant.
  end;
end;
//______________________________________________________________________________

procedure trail_dv_start(X: integer);      // roll dummy vehicle  0.98.a

begin
  cdvi.dv_start := dv_start_now + ((X - dv_now) * ffx) / inscale;
  // ffx in mm per pixel at mouse-down.

  if cdvi.dv_start < (0 - cdvi.dv_length) then
    cdvi.dv_start := 0 - cdvi.dv_length;  // 205a limits

  if cdvi.dv_start > (turnoutx / inscale + cdvi.dv_length - cdvi.dv_wheelbase) then
    cdvi.dv_start := turnoutx / inscale + cdvi.dv_length - cdvi.dv_wheelbase;  // 205a limits
end;
//______________________________________________________________________________

procedure trail_dv_clearance(Y: integer);      // dummy vehicle clearance  0.98.a

begin
  cdvi.dv_clearance := dv_clearance_now + ((Y - dv_clear_now) * ffy) / inscale;
  // ffy in mm per pixel at mouse-down.

  if cdvi.dv_clearance < 0 then
    cdvi.dv_clearance := 0;   // negative is confusing.
end;
//______________________________________________________________________________

procedure trail_adj_centres_ts(Y: integer);    // adjacent centres TS  213a

begin
  cpi.trtscent_pi := trtscent_pi_now + (Y - ts_adj_now) * hand_i * ffy;
  // ffy in mm per pixel at mouse-down.

  if cpi.trtscent_pi < (g / 2) then
    cpi.trtscent_pi := g / 2;   // smaller is confusing.

  get_cpi;
end;
//______________________________________________________________________________

procedure trail_adj_centres_ms(Y: integer);    // adjacent centres MS  213a

begin
  cpi.trmscent_pi := trmscent_pi_now + (ms_adj_now - Y) * hand_i * ffy;
  // ffy in mm per pixel at mouse-down.

  if cpi.trmscent_pi < (g / 2) then
    cpi.trmscent_pi := g / 2;   // smaller is confusing.

  get_cpi;
end;
//______________________________________________________________________________

procedure trail_platform_ts_start_mm(X: integer);   // TS platform start  0.93.a

begin
  platform_ts_start_mm := platform_ts_start_mm_now + (X - platform_ts_start_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if platform_ts_start_mm > turnoutx then
    platform_ts_start_mm := turnoutx;

  if platform_ts_start_mm < 0 then
    platform_ts_start_mm := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ts_length_mm(X: integer);   // TS platform length  0.93.a

begin
  platform_ts_length_mm := platform_ts_length_mm_now + (X - platform_ts_length_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if turnoutx < (platform_ts_start_mm + platform_ts_length_mm) then
    platform_ts_length_mm := turnoutx - platform_ts_start_mm;

  if platform_ts_length_mm < 0 then
    platform_ts_length_mm := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ts_start_width_ins(Y: integer);
// TS platform starting width in full-size inches  0.93.a

begin
  platform_ts_start_width_ins := platform_ts_start_width_ins_now +
    (Y - platform_ts_start_width_now_Y) * ffy * hand_i / inscale;
  // ffy in mm per pixel at mouse-down.

  if platform_ts_start_width_ins < 0 then
    platform_ts_start_width_ins := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ts_end_width_ins(Y: integer);
// TS platform ending width in full-size inches  0.93.a

begin
  platform_ts_end_width_ins := platform_ts_end_width_ins_now +
    (Y - platform_ts_end_width_now_Y) * ffy * hand_i / inscale;
  // ffy in mm per pixel at mouse-down.

  if platform_ts_end_width_ins < 0 then
    platform_ts_end_width_ins := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ms_start_mm(X: integer);   // MS platform start  0.93.a

begin
  platform_ms_start_mm := platform_ms_start_mm_now + (X - platform_ms_start_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if platform_ms_start_mm > turnoutx then
    platform_ms_start_mm := turnoutx;

  if platform_ms_start_mm < 0 then
    platform_ms_start_mm := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ms_length_mm(X: integer);   // MS platform length  0.93.a

begin
  platform_ms_length_mm := platform_ms_length_mm_now + (X - platform_ms_length_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if turnoutx < (platform_ms_start_mm + platform_ms_length_mm) then
    platform_ms_length_mm := turnoutx - platform_ms_start_mm;

  if platform_ms_length_mm < 0 then
    platform_ms_length_mm := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ms_start_width_ins(Y: integer);
// MS platform starting width in full-size inches  0.93.a

begin
  platform_ms_start_width_ins := platform_ms_start_width_ins_now -
    (Y - platform_ms_start_width_now_Y) * ffy * hand_i / inscale;
  // ffy in mm per pixel at mouse-down.

  if platform_ms_start_width_ins < 0 then
    platform_ms_start_width_ins := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ms_end_width_ins(Y: integer);
// MS platform ending width in full-size inches  0.93.a

begin
  platform_ms_end_width_ins := platform_ms_end_width_ins_now -
    (Y - platform_ms_end_width_now_Y) * ffy * hand_i / inscale;
  // ffy in mm per pixel at mouse-down.

  if platform_ms_end_width_ins < 0 then
    platform_ms_end_width_ins := 0;
end;
//______________________________________________________________________________

procedure trail_platform_ms_start_skew_mm(X: integer);   // MS platform skew at start  207a

begin
  platform_ms_start_skew_mm := platform_ms_start_skew_mm_now -
    (X - platform_ms_start_skew_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if platform_ms_start_skew_mm > (25 * scale) then
    platform_ms_start_skew_mm := 25 * scale;     // +/-25ft arbitrary limits

  if platform_ms_start_skew_mm < (0 - 25 * scale) then
    platform_ms_start_skew_mm := 0 - 25 * scale;

end;
//______________________________________________________________________________

procedure trail_platform_ms_end_skew_mm(X: integer);     // MS platform skew at end  207a

begin
  platform_ms_end_skew_mm := platform_ms_end_skew_mm_now + (X - platform_ms_end_skew_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if platform_ms_end_skew_mm > (25 * scale) then
    platform_ms_end_skew_mm := 25 * scale;     // +/-25ft arbitrary limits

  if platform_ms_end_skew_mm < (0 - 25 * scale) then
    platform_ms_end_skew_mm := 0 - 25 * scale;

end;
//______________________________________________________________________________

procedure trail_platform_ts_start_skew_mm(X: integer);   // TS platform skew at start  207a

begin
  platform_ts_start_skew_mm := platform_ts_start_skew_mm_now -
    (X - platform_ts_start_skew_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if platform_ts_start_skew_mm > (25 * scale) then
    platform_ts_start_skew_mm := 25 * scale;     // +/-25ft arbitrary limits

  if platform_ts_start_skew_mm < (0 - 25 * scale) then
    platform_ts_start_skew_mm := 0 - 25 * scale;

end;
//______________________________________________________________________________

procedure trail_platform_ts_end_skew_mm(X: integer);     // TS platform skew at end  207a

begin
  platform_ts_end_skew_mm := platform_ts_end_skew_mm_now + (X - platform_ts_end_skew_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if platform_ts_end_skew_mm > (25 * scale) then
    platform_ts_end_skew_mm := 25 * scale;     // +/-25ft arbitrary limits

  if platform_ts_end_skew_mm < (0 - 25 * scale) then
    platform_ts_end_skew_mm := 0 - 25 * scale;
end;
//______________________________________________________________________________

procedure trail_trackbed_ts_start_mm(X: integer);   // TS trackbed start  215a

begin
  trackbed_ts_start_mm := trackbed_ts_start_mm_now + (X - trackbed_ts_start_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if trackbed_ts_start_mm > turnoutx then
    trackbed_ts_start_mm := turnoutx;

  if trackbed_ts_start_mm < 0 then
    trackbed_ts_start_mm := 0;
end;
//______________________________________________________________________________

procedure trail_trackbed_ts_length_mm(X: integer);   // TS trackbed length  215a

begin
  trackbed_ts_length_mm := trackbed_ts_length_mm_now + (X - trackbed_ts_length_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if turnoutx < (trackbed_ts_start_mm + trackbed_ts_length_mm) then
    trackbed_ts_length_mm := turnoutx - trackbed_ts_start_mm;

  if trackbed_ts_length_mm < 0 then
    trackbed_ts_length_mm := 0;
end;
//______________________________________________________________________________

procedure trail_trackbed_ms_start_mm(X: integer);   // MS trackbed start  215a

begin
  trackbed_ms_start_mm := trackbed_ms_start_mm_now + (X - trackbed_ms_start_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if trackbed_ms_start_mm > turnoutx then
    trackbed_ms_start_mm := turnoutx;

  if trackbed_ms_start_mm < 0 then
    trackbed_ms_start_mm := 0;
end;
//______________________________________________________________________________

procedure trail_trackbed_ms_length_mm(X: integer);   // MS trackbed length  215a

begin
  trackbed_ms_length_mm := trackbed_ms_length_mm_now + (X - trackbed_ms_length_now_X) * ffx;
  // ffx in mm per pixel at mouse-down.

  if turnoutx < (trackbed_ms_start_mm + trackbed_ms_length_mm) then
    trackbed_ms_length_mm := turnoutx - trackbed_ms_start_mm;

  if trackbed_ms_length_mm < 0 then
    trackbed_ms_length_mm := 0;
end;
//______________________________________________________________________________

procedure trail_entry_straight(X: integer);      // change fixed_sl.   0.91.b

var
  new_fixed_sl: double;

begin
  new_fixed_sl := fixed_sl_now - (X - entry_straight_now) * ffx;
  // ffx in mm per pixel at mouse-down.

  //if new_fixed_sl<min_sl then new_fixed_sl:=min_sl;         // not beyond knuckle.

  if new_fixed_sl < 0 then
    new_fixed_sl := 0;   // 214a   not beyond FP.

  if (g - new_fixed_sl / k3n) > min_sl_offset then
    fixed_sl := new_fixed_sl;  // change value only if it will fit beyond switch heel.

  gocalc(0, 0);   // calc it for peg.
  peg_curve;     // maintain on peg
end;
//___________________________________________________________________________________________

procedure trail_slide(X: integer);

begin
  pegx := pegx_now - (X - peg_now_x) * ffx;
  // gocalc runs peg along current rail or centre-line.
  gocalc(0, 0);                                      // to get new pegy and arm_angle.
  peg_curve;                                        // shift onto previous position.
  rotate_turnout(pegangle_now - pegangle, False);      // and re-align to previous angle.
end;
//___________________________________________________________________________________________

procedure trail_snake(X: integer);        // (same as slide if no transition or slewing.)

begin
  pegx := pegx_now - (X - peg_now_x) * ffx;
  // gocalc runs peg along current rail or centre-line.
  if spiral = True then
    os := os_now - (X - peg_now_x) * ffx;
  if slewing = True then
    slew_s := slew_s_now - (X - peg_now_x) * ffx;

  //gocalc(0,0);    !!! unlike slide (above) we don't need this because snake is always on ms centre-line (pegy and angle constant).

  peg_curve;                                        // shift onto previous position.

  //rotate_turnout(pegangle_now-pegangle,False);    !!! ditto.
end;
//___________________________________________________________________________________________

procedure trail_shift(X, Y: integer);

begin
  xshift := xshift_now + (X - shift_now_x) * ffx;
  yshift := yshift_now + (Y - shift_now_y) * ffy * hand_i;
end;
//___________________________________________________________________________________________

procedure trail_shift_keeps(X, Y: integer);

begin
  xshift_keeps := xshift_now + (X - shift_now_x) * ffx;
  yshift_keeps := yshift_now + (Y - shift_now_y) * ffy;
end;
//____________________________________________________________________________________________

procedure trail_twist_keeps(Y: integer);

begin
  kform_keeps := kform_now + twist_dir * (Y - shift_now_y) * ffy * 100 /
    (mouse_rot_factor * fine_adjust * screenx);
  // 100 arbitrary.
  normalize_angle(kform_keeps);
end;
//__________________________________________________________________________________________

procedure trail_shift_labels(X, Y: integer);      // 0.82.d

var
  n: integer;

begin
  xshift_labels := xlabels_now + (X - labels_now_x) * ffx;
  yshift_labels := ylabels_now + (Y - labels_now_y) * ffy;

  for n := 0 to (keeps_list.Count - 1) do begin

    with keeps_list[n] do begin

      if group_selected = False then
        CONTINUE;     // not in group.
      if bg_copied = False then
        CONTINUE;          // not on background.

      with template_info.keep_dims.box_dims1 do begin

        mod_text_x := mod_text_x - xshift_labels_old + xshift_labels;
        mod_text_y := mod_text_y - yshift_labels_old + yshift_labels;

      end;//with
    end;//with
  end;//next template

  xshift_labels_old := xshift_labels;   // save modifiers for next calc.
  yshift_labels_old := yshift_labels;
end;
//____________________________________________________________________________________________

procedure trail_notch(X, Y: integer);

begin
  notchx := notchx_now + (X - notch_now_x) * ffx;
  notchy := notchy_now + (Y - notch_now_y) * ffy;
end;
//________________________________________________________________________________________

procedure trail_ring(X, Y: integer);

begin
  rings[0, 0] := xring_now + (X - ring_now_x) * ffx;
  rings[0, 1] := yring_now + (Y - ring_now_y) * ffy;
end;
//_________________________________________________________________________________________

procedure trail_ruler1(X, Y: integer);

begin
  ruler_startx := ruler_startx_now + (X - ruler1_now_x) * ffx;
  ruler_starty := ruler_starty_now + (Y - ruler1_now_y) * ffy;
end;
//_________________________________________________________________________________________

procedure trail_ruler2(X, Y: integer);

begin
  ruler_endx := ruler_endx_now + (X - ruler2_now_x) * ffx;
  ruler_endy := ruler_endy_now + (Y - ruler2_now_y) * ffy;
end;
//_________________________________________________________________________________________

procedure trail_ringdia(Y: integer);

begin
  ring_dia := ring_dia_now + (Y - ringdia_now_y) * ffy;

  if ring_dia > screenx_max then
    ring_dia := screenx_max;
  if ring_dia < 0 then
    ring_dia := 0;

  rings[0, 2] := ring_dia;
  rings[0, 3] := ring_dia + railtop * 2; // outer diameter.

  grid_form.dia_label.Caption := 'dia: ' + round_str(ring_dia, 2) + ' mm';
end;
//_________________________________________________________________________________________

procedure calc_peg_pad_pos;    // calculate position of peg on screen.

var
  peg_p: Tpex;
  dummy: double;

begin
  docurving(True, True, pegx, pegy, peg_p.x, peg_p.y, now_peg_k, dummy);
  // calc new curving angle and peg position on pad for caption.

  pad_peg_point := xy_to_dwg100(peg_p);
  pad_peg_point.x := pad_peg_point.x / 100;
  // position in mm. after curving, transforms and distortions, (Tpex),
  pad_peg_point.y := pad_peg_point.y / 100 + y_datum;
  // these dims used only for caption display on mouse peg move.
end;
//__________________________________________________________________________________________

procedure trail_peg(X, Y: integer);

var
  modin, modout: Tpex;

begin

  modin.x := (X - peg_now_x) * ffx;
  modin.y := (Y - peg_now_y) * ffy * hand_i;

  if peg_rail = 0                           // free peg move...
  then begin
    dotransform(now_peg_k - kform, 0, 0, modin, modout);
    // transform move at current angle.

    pegx := pegx_now + modout.x;   // to keep movements matching the mouse.
    pegy := pegy_now + modout.y;
  end
  else
    pegx := pegx_now + modin.x;      // gocalc runs peg along current rail.

  calc_peg_pad_pos;      // calc screen peg position for mouse action caption.

end;
//__________________________________________________________________________________________

procedure trail_zoffset(X, Y: integer);

begin
  zoom_offsetx := zoom_offsetx_now - (X - zoff_now_x) * ffx;
  zoom_offsety := zoom_offsety_now - (Y - zoff_now_y) * ffy;
end;
//____________________________________________________________________________________________

procedure trail_porg(X, Y: integer);

begin
  print_pages_top_origin := print_pages_top_origin_now - (porg_now_x - X) * ffx;
  print_pages_left_origin := print_pages_left_origin_now - (porg_now_y - Y) * ffy;
end;
//____________________________________________________________________________________________

procedure trail_rect_x1(X: integer);

begin
  output_rectangle_x1 := output_rectangle_x_now - (rect_now_X - X) * ffx;
end;
//______________________________________________________________________________

procedure trail_rect_x2(X: integer);

begin
  output_rectangle_x2 := output_rectangle_x_now - (rect_now_X - X) * ffx;
end;
//______________________________________________________________________________

procedure trail_rect_y1(Y: integer);

begin
  output_rectangle_y1 := output_rectangle_y_now - (rect_now_Y - Y) * ffy;
end;
//______________________________________________________________________________

procedure trail_rect_y2(Y: integer);

begin
  output_rectangle_y2 := output_rectangle_y_now - (rect_now_Y - Y) * ffy;
end;
//______________________________________________________________________________

procedure trail_rect_position(X, Y: integer);    // output boundary rectangle move

begin
  output_rectangle_x1 := output_rectangle_x_now - (rect_now_X - X) * ffx;
  output_rectangle_y1 := output_rectangle_y_now - (rect_now_Y - Y) * ffy;

  output_rectangle_x2 := output_rectangle_x1 + output_rectangle_width;
  output_rectangle_y2 := output_rectangle_y1 + output_rectangle_height;
end;
//______________________________________________________________________________

procedure trail_corner1(X, Y: integer);

begin
  shapes_shiftx_now := (X - shapes_now_x) * ffx;
  shapes_shifty_now := (Y - shapes_now_y) * ffy;

  shift_this_shape(shapes_shiftx_now - shifted_already_x, shapes_shifty_now -
    shifted_already_y, 1);

  shifted_already_x := shapes_shiftx_now;
  shifted_already_y := shapes_shifty_now;
end;
//__________________________________________________________________________________________

procedure trail_corner2(X, Y: integer);

begin
  shapes_shiftx_now := (X - shapes_now_x) * ffx;
  shapes_shifty_now := (Y - shapes_now_y) * ffy;

  shift_this_shape(shapes_shiftx_now - shifted_already_x, shapes_shifty_now -
    shifted_already_y, 2);

  shifted_already_x := shapes_shiftx_now;
  shifted_already_y := shapes_shifty_now;
end;
//__________________________________________________________________________________________

procedure trail_shape(X, Y: integer);

begin
  shapes_shiftx_now := (X - shapes_now_x) * ffx;
  shapes_shifty_now := (Y - shapes_now_y) * ffy;

  shift_this_shape(shapes_shiftx_now - shifted_already_x, shapes_shifty_now -
    shifted_already_y, 0);

  shifted_already_x := shapes_shiftx_now;
  shifted_already_y := shapes_shifty_now;
end;
//__________________________________________________________________________________________

procedure trail_allshapes_shift(X, Y: integer);

begin
  shapes_shiftx_now := (X - shapes_now_x) * ffx;
  shapes_shifty_now := (Y - shapes_now_y) * ffy;

  shift_all_shapes(shapes_shiftx_now - shifted_already_x, shapes_shifty_now - shifted_already_y);

  shifted_already_x := shapes_shiftx_now;
  shifted_already_y := shapes_shifty_now;
end;
//__________________________________________________________________________________________

procedure trail_allshapes_scale(Y: integer);

var
  shapes_scalefactor: double;

begin
  if pad_form.ClientHeight < 1 then
    EXIT;

  shapes_scalefactor := 1.0 + (shapes_now_y - Y) / pad_form.ClientHeight;

  if shapes_scalefactor < 0.01 then
    shapes_scalefactor := 0.01;   // 1/100th arbitrary limit in one go.

  if (shapes_scaled_already > minfp) and (shapes_scalefactor > minfp) then
    scale_all_shapes(shapes_scalefactor / shapes_scaled_already, shapes_scalefactor /
      shapes_scaled_already);

  shapes_scaled_already := shapes_scalefactor;
end;
//__________________________________________________________________________________________

procedure trail_allshapes_rotate(Y: integer);

var
  shapes_rot: double;

begin
  shapes_rot := shapes_rot_now + twist_dir * (Y - shapes_now_y) * ffy * 100 /
    (mouse_rot_factor * fine_adjust * screenx);   // 100 arbitrary.
  rotate_all_shapes(False, False, shapes_rot - shapes_rotated_already);
  // False,False = not sync from group rotate,  not picture shapes

  shapes_rotated_already := shapes_rot;
end;
//__________________________________________________________________________________________

procedure trail_oneshape_scale(X: integer);

var
  shapes_scalefactor: double;

begin
  if pad_form.ClientWidth < 1 then
    EXIT;

  shapes_scalefactor := 1.0 + (X - shapes_now_x) / pad_form.ClientWidth;

  if shapes_scalefactor < 0.01 then
    shapes_scalefactor := 0.01;   // 1/100th arbitrary limit in one go.

  if (shapes_scaled_already > minfp) and (shapes_scalefactor > minfp) then
    scale_this_shape(shapes_scalefactor / shapes_scaled_already, shapes_scalefactor /
      shapes_scaled_already);

  shapes_scaled_already := shapes_scalefactor;
end;
//_________________________________________________________________________________________

procedure trail_bunch(X, Y: integer);

begin
  bunching_jump := bunching_jump_now + (bunch_now - X) * ffx;
  if bunching_jump < 0 then
    bunching_jump := 0;

  bunching_shear := bunching_shear_now + (Y - shear_now) * ffy;
end;
//__________________________________________________________________________________________

procedure trail_twist(Y: integer);

begin
  kform := kform_now + twist_dir * (Y - shift_now_y) * ffy * hand_i * 100 /
    (mouse_rot_factor * fine_adjust * screenx);
  // 100 arbitrary.
  normalize_kform;
end;
//___________________________________________________________________________________________

procedure trail_orbit(X: integer);

begin
  kform := kform_now + orbit_dir * (X - shift_now_x) * ffx * 100 /
    (mouse_orbit_factor * fine_adjust * orbit_rad);
  //  100 arbitrary.
  normalize_kform;
end;
//____________________________________________________________________________________________

procedure trail_zoom(X: integer);

var
  temp: double;

begin
  if X < 1 then
    X := 1;
  temp := screenx;                                   // previous screenx.
  //screenx:=screenx_zoom_now*(X/zoom_now);
  screenx := screenx_zoom_now * (zoom_now / X);

  if screenx < screenx_min then
    screenx := screenx_min; // minimum for screen width (max zoom in).
  if screenx > screenx_max then
    screenx := screenx_max; // maximum zoom out.

  zoom_offsetx := zoom_offsetx * screenx / temp;          // keep pad view zero lines stable.
  zoom_offsety := zoom_offsety * screenx / temp;
end;
//________________________________________________________________________________________

procedure trail_spot(X, Yneg: integer);

var
  temp: double;
  x_offset_mod: double;

begin
  temp := screeny / screenx;                            // aspect ratio

  if Yneg < 1 then
    Yneg := 1;                           // no zero div.
  screenx := screenx_spot_now * (spot_now / Yneg);

  if screenx < screenx_min then
    screenx := screenx_min; // minimum for screen width (max zoom in).
  // ( ! getting strange draw problems if zoom in any more).
  if screenx > screenx_max then
    screenx := screenx_max; // maximum zoom out.

  x_offset_mod := (screenx_spot_now - screenx) / 2;
  zoom_offsetx := zoom_offsetx_now + x_offset_mod;           // keep screen centre stable.
  zoom_offsety := zoom_offsety_now + x_offset_mod * temp;

  if pad_form.spot_and_scale_menu_entry.Checked = True then begin
    screenx_zoom_now := screenx;     // scale zoom also on X move.
    trail_zoom(X);
  end;
end;
//_______________________________________________________________________________________

procedure trail_datum(Y: integer);

begin
  y_datum := y_datum_now - (datum_now - Y) / fy;        // fy is pixels per mm (fy -ve).
end;
//______________________________________________________________________________________

procedure trail_trans_start(X: integer);          // adjust transition start.

var
  old_os, dummy1, dummy2, dummy3, new_rad: double;
  limit_code: integer;
  //temp:double;

begin
  old_os := os;
  os := os_now + (X - trans_start_now) / fx;

  // see if he wants to keep the spiral constant fixed by adjusting the 1st rad...

  if pad_form.zone_rollout_menu_entry.Checked = True
  //!!! don't use clrad_at_x function (won't work when zone increasing).
  then begin
    if transcalcs(False, False, trans_k, ts1 + os - old_os, dummy1, dummy2, dummy3, new_rad) =
      True   // get new 1st rad.
    then begin

      if new_rad < 0 then
        new_rad := limits(0 - max_rad, 0 - g * 2, new_rad, limit_code)
      // ensure radius within limits.
      else
        new_rad := limits(g * 2, max_rad, new_rad, limit_code);      // minimum 2*g arbitrary.

      if ((os - old_os) < tst) and (limit_code = 0) then begin
        // don't let tst go negative or rads exceed limits.
        nomrad1 := new_rad;         // ok, change 1st radius.
        tst := tst + old_os - os;       // keep transition unchanged.
      end
      else
        os := old_os;       // not ok, no change.
    end
    else
      os := old_os;       // not ok, no change.
  end;
  peg_curve;            // keep transition on peg.
end;
//________________________________________________________________________________________

procedure trail_trans_length(X: integer);           // adjust transition length.

var
  old_tst, dummy1, dummy2, dummy3, new_rad: double;
  limit_code: integer;
  //temp:double;

begin
  old_tst := tst;     // in case we need to re-instate.

  tst := tst_now + (X - trans_length_now) / fx;
  if tst < 0 then
    tst := 0;

  // see if he wants to keep the spiral constant fixed by adjusting the 2nd rad...

  if pad_form.zone_rollout_menu_entry.Checked = True
  //!!! don't use clrad_at_x function (won't work when zone increasing).
  then begin
    if tst < g then
      tst := g; // 0.93.a  prevent crash in roll-out mode on very short transition zone. g arbitrary.

    if transcalcs(False, False, trans_k, (ts1 + tst), dummy1, dummy2, dummy3, new_rad) =
      True   // get new 2nd rad.
    then begin

      if new_rad < 0 then
        new_rad := limits(0 - max_rad, 0 - g * 2, new_rad, limit_code)
      // ensure radius within limits.
      else
        new_rad := limits(g * 2, max_rad, new_rad, limit_code);      // minimum 2*g arbitrary.

      if limit_code = 0 then
        nomrad2 := new_rad          // ok, change 2nd radius.
      else
        tst := old_tst;             // not ok, no change.
    end
    else
      tst := old_tst;
  end;
  peg_curve;            // keep transition on peg.
end;
//________________________________________________________________________________________

procedure trail_slew_start(X: integer);           // adjust slewing start.

begin
  slew_s := slew_s_now + (X - slew_start_now) / fx;      // neg OK.
  peg_curve;                                     // keep slew on peg.
end;
//________________________________________________________________________________________

procedure trail_slew_length(X: integer);           // adjust slewing length.

begin
  slew_l := slew_l_now + (X - slew_length_now) / fx;
  if slew_l < ABS(slew) then
    slew_l := ABS(slew);     // ??? arbitrary minimum. (can't go neg).
  if slew_l < 1 then
    slew_l := 1;                     // 1 mm safety minimum (div by zero).
  peg_curve;                                      // keep slew on peg.
end;
//________________________________________________________________________________________

procedure trail_slew_amount(Y: integer);           // adjust amount of slew.

begin
  slew := slew_now + (Y - slew_amount_now) * hand_i / fy;          // neg OK
  if ABS(slew) > slew_l then
    slew := slew_l * SGZ(slew);       // arbitrary limit = slew length.
  peg_curve;                                             // keep slew on peg.
end;
//________________________________________________________________________________________

procedure trail_slew2_factor(X: integer);          // adjust slew mode 2 factor.

begin
  slew2_kmax := slew2_kmax_now + (X - slew_factor_now) * 6 / (pad_form.ClientWidth + 1);
  // 6 arbitrary.

  if slew2_kmax < 0.02 then
    slew2_kmax := 0.02;      // ??? arbitrary minimum. (can't go neg).
  if slew2_kmax > 10 then
    slew2_kmax := 10;          // ??? arbitrary maximum.

  peg_curve;                                     // keep slew on peg.
end;
//________________________________________________________________________________________

procedure trail_printsize(X: integer);     // adjust print size.

begin
  if X < 1 then
    X := 1;                       // prevent div 0.
  out_factor := out_factor_now * (printsize_now_X / X);
end;
//__________________________________________________________________________________________

procedure trail_shove_along(X: integer);

begin
  shovex := shovex_now + (X - shove_now_x) / fx / shove_mouse_factor / 2;
  // /2 arbitrary.
  current_shove_list[shove_index].sv_x := shovex;

  shovetimbx := shovetimbx_now + (X - shovetimb_now) / fx / shove_mouse_factor / 2;

  //if show_shove_fs=True then shove_timber_form.xtb_panel.Caption:=' centre :  '+round_str((shovetimbx-shovetimbx_zero)/inscale,2)+' ins'
  //                      else shove_timber_form.xtb_panel.Caption:=' centre :  '+round_str((shovetimbx-shovetimbx_zero),2)+' mm';
end;
//________________________________________________________________________________________

procedure trail_shove_throw(Y: integer);

begin
  shoveo := shoveo_now + (Y - shove_now_y) * ffy * hand_i / shove_mouse_factor;
  current_shove_list[shove_index].sv_o := shoveo;
end;
//________________________________________________________________________________________

procedure trail_shove_crab(X: integer);

begin
  shovec := shovec_now + (X - shove_now_x) / fx / shove_mouse_factor / 2;     // /2 arbitrary.
  current_shove_list[shove_index].sv_c := shovec;
end;
//________________________________________________________________________________________

procedure trail_shove_length(Y: integer);

begin
  shovel := shovel_now + (Y - shove_now_y) * ffy * hand_i / shove_mouse_factor;
  current_shove_list[shove_index].sv_l := shovel;
end;
//________________________________________________________________________________________

procedure trail_shove_width(X: integer);

begin
  shovew := shovew_now + (X - shove_now_x) / fx / shove_mouse_factor / 4;
  // /4 arbitrary.
  current_shove_list[shove_index].sv_w := shovew;
end;
//________________________________________________________________________________________

procedure trail_shove_twist(Y: integer);

begin
  shovek := shovek_now + (Y - shove_now_y) * ffy * hand_i / (shove_mouse_factor * screenx);
  normalize_angle(shovek);
  current_shove_list[shove_index].sv_k := shovek;
end;
//________________________________________________________________________________________

procedure set_xing_k_i;      // set selector list index to match current k3n.

begin
  //  if k3n<2 then k3n:=2;      //  sensible minimum to avoid calc problems.

  if k3n < 1.5 then
    k3n := 1.5;        // 0.93.a  1:1.5 sensible minimum.

  // mods 0.73.a 20-9-01....
  //  set new list index.

  xing_k_i := 16;  // default init "other".

  if ABS(k3n - 4) < minfp then
    xing_k_i := 0;   //  k3n:=4;
  if ABS(k3n - 4.5) < minfp then
    xing_k_i := 1;   //  k3n:=4.5;
  if ABS(k3n - 4.75) < minfp then
    xing_k_i := 2;   //  k3n:=4.75;
  if ABS(k3n - 5) < minfp then
    xing_k_i := 3;   //  k3n:=5;
  if ABS(k3n - 5.25) < minfp then
    xing_k_i := 4;   //  k3n:=5.25;
  if ABS(k3n - 5.5) < minfp then
    xing_k_i := 5;   //  k3n:=5.5;
  if ABS(k3n - 5.75) < minfp then
    xing_k_i := 6;   //  k3n:=5.75;
  if ABS(k3n - 6) < minfp then
    xing_k_i := 7;   //  k3n:=6;
  if ABS(k3n - 6.25) < minfp then
    xing_k_i := 8;   //  k3n:=6.25;
  if ABS(k3n - 6.5) < minfp then
    xing_k_i := 9;   //  k3n:=6.5;
  if ABS(k3n - 7) < minfp then
    xing_k_i := 10;   //  k3n:=7;
  if ABS(k3n - 7.5) < minfp then
    xing_k_i := 11;   //  k3n:=7.5;
  if ABS(k3n - 8) < minfp then
    xing_k_i := 12;   //  k3n:=8;
  if ABS(k3n - 9) < minfp then
    xing_k_i := 13;   //  k3n:=9;
  if ABS(k3n - 10) < minfp then
    xing_k_i := 14;   //  k3n:=10;
  if ABS(k3n - 12) < minfp then
    xing_k_i := 15;   //  k3n:=12;

  if xing_k_i = 16            // not in the list...
  then
    other_k3n_i := 1    // other angle.
  else
    other_k3n_i := 0;

  xing_select_form.other_label.Caption := '1 : ' + round_str(k3n, 2);
end;
//___________________________________________________________________________________________

procedure trail_xing(X: integer);    //  adjust crossing size on new mouse X position.

var
  temp, dummy1, dummy2: double;
  pc, pf: Tpex;

begin
  if xing_free = True                 //  ignore if he's locked it.
  then begin

    k3n := k3n_now + (X - xing_now) * ffx * 1000 / (mouse_xing_factor * fine_adjust * screenx);
    // 1000 arbitrary.

    if k3n < 1.5 then
      K3n := 1.5;   // 0.93.a bottom limit.

    if half_diamond = False then begin
      if f5_quarter_steps = True then begin
        k3n := INT(k3n * 4 + 0.5) / 4;
        //  round unusual crossing angles to nearest .25.
        //out 0.93. irregular now ok  while k3n>(k2n-0.1) do k3n:=k3n-0.25;  //  crossing can't be flatter than the switch.
      end;
      //out 0.93. irregular now ok   else while k3n>(k2n-0.1) do k3n:=k3n-0.1;     //  crossing can't be flatter than the switch.
    end
    else begin
      if f5_quarter_steps = True then
        k3n := INT(k3n * 4 + 0.5) / 4;  //  round unusual crossing angles to nearest .25.
      hdkn := k3n;
      // F5 maintains regular half-diamond (use F9, F10 for irregular)
    end;

    set_xing_k_i;

  end

  else begin
    temp := X * 12 / (ABS(pad_form.ClientWidth) + 1);  // range 0-12   (+1 in case div 0).

    switch_only := Round(temp) + 9;
    //  so can change switch if crossing doesn't change. (range now 9-21)

  end;

  gocalc(0, 0);   // recalc to get new pegx, pegy, arm_angle.

  docurving(False, True, pegx, pegy, pc.x, pc.y, dummy1, dummy2);  // first curve peg position.

  dotransform(kform, xform, yform, pc, pf);                // then rotate it (without shifts).

  xshift := now_peg_x - pf.x;
  // maintain peg position constant (now_peg includes the now_shift).
  yshift := now_peg_y - pf.y;

  rotate_turnout(arm_angle_now - arm_angle, False);    // re-align to previous angle.
end;
//_______________________________________________________________________________________

procedure peg_curve;  // do curving calcs for the current peg position.
// called after radius changes, e.g. from F6 curving mouse action.
// N.B. this routine does not do a redraw - calcs only.
var
  peg_k: double;
  peg600, peg_kkk: double;
  dummy1, dummy2, dummy3: double;
  pc, pf: Tpex;

begin
  if calc_curving = False then
    EXIT;    // calc new curving/transition constants.

  peg600 := 0;  // for a curviform V-crossing in codes 241,600 (peg on TEXITP TOLP)   0.79.a  29-05-06

  case peg_code of
    15:
      pegx := os;       // keep peg on transition start.
    16:
      pegx := os + tst;   // keep peg on transition end.


    // 0.93.a ex 081 ...

    200, 220:
      if (curving_mod = 1) or (swell_mod = 1) or (sx_mod = 1) or (vee_mod = 1) or
        (hdk_mod = 1) or (both_mod = 1) or (gaunt_offset_mod = 1) or
        (gaunt_radius_mod = 1)   // 217b
        or (entry_straight_mod = 1) or (turnout_road_mod = 1)   // 213b
      then
        gocalc(0, 0);      // to keep peg on geometrical tangent points.

    241:
      if turnout_road_mod = 1   // 241 = peg on TEXITP   213b
      then begin
        pegx := xorg + turnout_road_endx;
        pegy := aq25offset(pegx, peg_kkk);
        peg600 := now_peg600 - peg_kkk;
      end;

    300:
      pegx := slew_s;          // keep peg on slewing start.
    301:
      pegx := slew_s + slew_l;   // keep peg on slewing end.

    400:
      pegx := os - ts1;   // keep peg on transition origin.

    600:
      if length_mod = 1  // peg on TOLP    // 0.79.a
      then begin
        pegx := turnoutx;
        pegy := aq25offset(pegx, peg_kkk);
        // adjust peg angle for a curviform V-crossing.
        peg600 := now_peg600 - peg_kkk;
      end;
  end;//case

  docurving(False, True, pegx, pegy, dummy1, dummy2, peg_k, dummy3);
  // then calc new curving angle to peg.

  kform := kform_now + now_peg_k - peg_k + peg600;
  // adjust rotation angle to keep peg angle constant.  // 0.79.a
  normalize_kform;
  // then calc new peg position on pad...

  docurving(False, True, pegx, pegy, pc.x, pc.y, dummy1, dummy2);  // first curve it.

  dotransform(kform, xform, yform, pc, pf);                     // then rotate it.

  xshift := now_peg_x - pf.x;
  // finally maintain peg position constant (now_peg includes the now_shift).
  yshift := now_peg_y - pf.y;
end;
//_______________________________________________________________________________________


procedure trail_gaunt_offset(Y: integer);

var
  dummy1, dummy2: double;
  pc, pf: Tpex;
  old_dp, new_dp: double;

begin
  old_dp := dpx - xorg;

  gaunt_offset_in := (gaunt_offset_now_mm + (Y - gaunt_now) * ffy * hand_i /
    (mouse_gaunt_offset_factor * fine_adjust * screenx)) / inscale;

  // offset can't exceed the knuckle..

  if gaunt_offset_in > ((g - fw - minfp) / inscale) then
    gaunt_offset_in := (g - fw - minfp) / inscale;

  // or the entry straight if any (for curviform and generic crossings, th=g)..

  if gaunt_offset_in > ((th - minfp) / inscale) then
    gaunt_offset_in := (th - minfp) / inscale;

  // negative offset can't go beyond MS centres (arbitrary)...

  // out 217b if gaunt_offset_in<(0-trmscent/inscale) then gaunt_offset_in:=0-trmscent/inscale;

  gocalc(0, 0);              // calc new dpx

  new_dp := dpx - xorg;         // maintain overall length and V-crossing alignment
  xorg := xorg + old_dp - new_dp;

  if xorg < 0 then begin
    turnoutx := turnoutx - xorg;
    // increase overall length to keep V-crossing and exit track.
    if spiral = True then
      os := os - xorg;
    if slewing = True then
      slew_s := slew_s - xorg;
    xorg := 0;
  end;

  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;
  if xorg > turnoutx then
    xorg := turnoutx;

  gocalc(0, 0);   // recalc to get new pegx, pegy, arm_angle.

  docurving(False, True, pegx, pegy, pc.x, pc.y, dummy1, dummy2);  // first curve peg position.

  dotransform(kform, xform, yform, pc, pf);      // then rotate it (without shifts).

  xshift := now_peg_x - pf.x;
  // maintain peg position constant (now_peg includes the now_shift).
  yshift := now_peg_y - pf.y;

  rotate_turnout(arm_angle_now - arm_angle, False);    // re-align to previous angle.
end;
//_______________________________________________________________________________________

procedure trail_gaunt_curvature(Y: integer);

var
  dummy1, dummy2: double;
  pc, pf: Tpex;
  old_dp, new_dp: double;
  gaunt_rad, new_gaunt_offset: double;

begin
  old_dp := dpx - xorg;

  gaunt_curvature := (gaunt_curvature_now + (Y - gaunt_rad_now) * ffy * hand_i /
    (mouse_gaunt_radius_factor * fine_adjust * screenx));

  try

    if gaunt_curvature > (1 / (g * 5)) then
      gaunt_curvature := 1 / (g * 5);     // 5g radius bottom limit

    if gaunt_curvature < (1 / (g * 2000)) then
      gaunt_curvature := 1 / (g * 2000);  // 2000g radius top limit (xorg becomes excessive)

    gaunt_rad := 1 / gaunt_curvature + g / 2;             // to rail.
    new_gaunt_offset := gaunt_rad * (COS(k3) - 1) + g;
  except
    EXIT;
  end;//try

  gaunt_offset_in := new_gaunt_offset / inscale;

  gocalc(0, 0);              // calc new dpx

  new_dp := dpx - xorg;         // maintain overall length and V-crossing alignment
  xorg := xorg + old_dp - new_dp;

  if xorg < 0 then begin
    turnoutx := turnoutx - xorg;
    // increase overall length to keep V-crossing and exit track.
    if spiral = True then
      os := os - xorg;
    if slewing = True then
      slew_s := slew_s - xorg;
    xorg := 0;
  end;

  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;
  if xorg > turnoutx then
    xorg := turnoutx;

  gocalc(0, 0);   // recalc to get new pegx, pegy, arm_angle.

  docurving(False, True, pegx, pegy, pc.x, pc.y, dummy1, dummy2);  // first curve peg position.

  dotransform(kform, xform, yform, pc, pf);      // then rotate it (without shifts).

  xshift := now_peg_x - pf.x;
  // maintain peg position constant (now_peg includes the now_shift).
  yshift := now_peg_y - pf.y;

  rotate_turnout(arm_angle_now - arm_angle, False);    // re-align to previous angle.
end;
//_______________________________________________________________________________________

procedure trail_vee(X: integer);    //  F9 adjust V-crossing size on new mouse X position.

var
  temp, dummy1, dummy2, gaunt_rad, k3_angle: double;
  pc, pf: Tpex;

  old_dp, new_dp: double;

  old_k3n: double;

  new_gaunt_offset: double;

begin
  old_dp := dpx - xorg;         // mods 217a for fixed gaunt radius ...
  gaunt_rad := tradius;       // to gauge-face

  old_k3n := k3n;

  k3n := vee_now + (X - veexing_now) * ffx * 1000 / (mouse_xing_factor * fine_adjust * screenx);
  // 1000 arbitrary.

  if f9_quarter_steps = True then
    k3n := INT(k3n * 4 + 0.5) / 4;  //  round unusual V-crossing angles to nearest .25.

  if k3n < 1.5 then
    k3n := 1.5;  // 1:1.5   33.69 degrees limit.

  if (gaunt = True) and (f9_gaunt_rad = True) and (xing_calc_i = 1) and
    (half_diamond = False) and (plain_track = False) and (spiral = False)
  // curviform only    217a ...
  then begin
    try
      k3_angle := ARCTAN(1 / k3n);
      new_gaunt_offset := gaunt_rad * (COS(k3_angle) - 1) + g;

      if new_gaunt_offset > (g - fw - minfp) then begin
        // don't let gaunt_offset_in go out of range.
        k3n := old_k3n;
        EXIT;
      end
      else
        gaunt_offset_in := new_gaunt_offset / inscale;

      gocalc(0, 0);              // calc new dpx

      new_dp := dpx - xorg;         // maintain overall length and V-crossing alignment
      xorg := xorg + old_dp - new_dp;

      if xorg < 0 then begin
        turnoutx := turnoutx - xorg;
        // increase overall length to keep V-crossing and exit track.
        if spiral = True then
          os := os - xorg;
        if slewing = True then
          slew_s := slew_s - xorg;
        xorg := 0;
      end;

      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;
      if xorg > turnoutx then
        xorg := turnoutx;
    except
      do_nothing;
    end;//try
  end;

  if (half_diamond = True) and (f9_hd_rad = True) and (xing_calc_i = 1) and
    (gaunt = False) and (plain_track = False) and (spiral = False)
  // curviform only    218b ...
  then begin
    try
      k3_angle := ARCTAN(1 / k3n);
      hdk := ARCCOS(COS(k3_angle) + g / tradius);
      hdkn := 1 / TAN(hdk);
      if (creating_tandem = True) and (turnoutx < mvjpx) then
        turnoutx := mvjpx;
    except
      do_nothing;
    end;//try
  end;

  gocalc(0, 0);   // recalc to get new pegx, pegy, arm_angle.

  docurving(False, True, pegx, pegy, pc.x, pc.y, dummy1, dummy2);  // first curve peg position.

  dotransform(kform, xform, yform, pc, pf);                // then rotate it (without shifts).

  xshift := now_peg_x - pf.x;
  // maintain peg position constant (now_peg includes the now_shift).
  yshift := now_peg_y - pf.y;

  rotate_turnout(arm_angle_now - arm_angle, False);    // re-align to previous angle.
end;
//_______________________________________________________________________________________

procedure trail_hdk(X: integer);    // F10 adjust K-crossing size on new mouse X position.

var
  temp, dummy1, dummy2: double;
  pc, pf: Tpex;

begin
  if half_diamond = False then
    EXIT;    //??? no K-crossing?

  hdkn := hdkn_now + (X - hdxing_now) * ffx * 1000 / (mouse_xing_factor * fine_adjust * screenx);
  // 1000 arbitrary.

  if f10_quarter_steps = True then
    hdkn := INT(hdkn * 4 + 0.5) / 4;  //  round unusual K-crossing angles to nearest .25.

  if hdkn < 1.5 then
    hdkn := 1.5;  // 1:1.5    33.69 degrees limit.

  gocalc(0, 0);   // recalc to get new pegx, pegy, arm_angle.

  docurving(False, True, pegx, pegy, pc.x, pc.y, dummy1, dummy2);  // first curve peg position.

  dotransform(kform, xform, yform, pc, pf);                // then rotate it (without shifts).

  xshift := now_peg_x - pf.x;
  // maintain peg position constant (now_peg includes the now_shift).
  yshift := now_peg_y - pf.y;

  rotate_turnout(arm_angle_now - arm_angle, False);    // re-align to previous angle.
end;
//_______________________________________________________________________________________

procedure trail_curving(Y: integer);
//  adjust curving radius (pegged) on new mouse Y position.

var
  new_curvature: double;
  dummy: integer;

begin
  new_curvature := curvature_now + (Y - curving_now) * ffy * hand_i /
    (mouse_curv_factor * fine_adjust * scale * screenx);

  if Abs(new_curvature) > minfp then begin
    nomrad := 1 / new_curvature;

    if nomrad < 0 then
      nomrad := limits(0 - max_rad, 0 - g * 2, nomrad, dummy)   // ensure radius within limits.
    else
      nomrad := limits(g * 2, max_rad, nomrad, dummy);      // minimum 2*g arbitrary.

    new_curvature := 1 / nomrad;
  end
  else begin
    nomrad := max_rad;        // "straight"
    new_curvature := 0;
  end;

  if spiral = True then begin
    case adjust_trans_rad of
      1: begin
        // check spiral constant will not exceeed the limit, leave nomrad1 unchanged if so.

        temp := nomrad - nomrad2;
        if ABS(temp) > minfp  // no change to nomrad1 if nomrad=nomrad2
        then begin
          // no change to nomrad1 if spiral too gentle.

          if ABS(nomrad * nomrad2 * tst / temp) < max_spiral_constant then
            nomrad1 := nomrad;
        end;
      end;

      2: begin
        // check spiral constant will not exceeed the limit, leave nomrad2 unchanged if so.

        temp := nomrad1 - nomrad;
        if ABS(temp) > minfp  // no change to nomrad2 if nomrad=nomrad1
        then begin
          // no change to nomrad2 if spiral too gentle..

          if ABS(nomrad1 * nomrad * tst / temp) < max_spiral_constant then
            nomrad2 := nomrad;
        end;
      end;
      else
        run_error(197);
    end;//case
  end
  else begin                                     // constant radius
    if f6_swing_fixed = True      // 0.91.b   // maintain swing angle...
    then begin
      turnoutx := ABS(nomrad * f6_swing_angle);
      // nomrad may be negative.
      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;
      if plain_track = True then
        xorg := turnoutx;               //  ensure xorg matches.
      turnout_i := 1;
      // length locked at new turnoutx.
      gocalc(0, 0);
      // maintain peg position.
    end;
  end;

  peg_curve;  // do curving calcs for the current peg position.
end;
//_________________________________________________________________________________________

procedure trail_swell(Y: integer);     //  adjust curving radius (swell) on new mouse Y position.

var
  new_curvature, temp: double;
  dummy: integer;
  swing_sin: double;

begin
  new_curvature := curvature_now - (Y - curving_now) * ffy * hand_i /
    (mouse_curv_factor * fine_adjust * scale * screenx);

  swing_sin := ends_apart_now * ABS(new_curvature) / 2;      // SIN of swing angle.

  if swing_sin > (1 - minfp) then
    EXIT;    // more than 180 degs swing, ignore until he reduces it.

  if Abs(new_curvature) > minfp then begin
    nomrad := 1 / new_curvature;

    if nomrad < 0 then
      nomrad := limits(0 - max_rad, 0 - g * 2, nomrad, dummy)   // ensure radius within limits.
    else
      nomrad := limits(g * 2, max_rad, nomrad, dummy);      // minimum 2*g arbitrary.

    new_curvature := 1 / nomrad;
  end
  else begin
    nomrad := max_rad;        // "straight"
    new_curvature := 0;
  end;

  // swell between fixed ends...
  try
    turnoutx := ABS(nomrad) * ARCSIN(swing_sin) * 2;
    kform := kform_now + (curvature_now * turnoutx_now - new_curvature * turnoutx) / 2;
    // or for fixed ends.
    normalize_kform;
  except
    turnoutx := turnoutx_now;
    kform := kform_now;
    nomrad := nomrad_now;
  end;//try

  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;
  if turnoutx < 0 then
    turnoutx := 0;

  if plain_track = True then
    xorg := turnoutx
  else begin
    if xorg > turnoutx then
      xorg := turnoutx;
    if xorg < 0 then
      xorg := 0;
  end;

  turnout_i := 1;    // lock length at new turnoutx.
end;
//_________________________________________________________________________________________

procedure action_update(trail_str: string);

begin
  with action_form do begin
    trail_dim_label.Caption := Trim(trail_str);

    trail_dim_label.Width := Canvas.TextWidth(trail_dim_label.Caption) + 2; // bug fix for Wine

    if (trail_dim_label.Left + trail_dim_label.Width) > ClientWidth then
      action_panel_resize;
  end;//with
end;
//_____________________________________________________________________________________________

procedure mouse_action_selected(caption_str, mouse_str, trail_str: string);

var
  mps: TPoint;
  i: integer;

begin

  hidden_on_store := 0;
  // don't need to show the control automatically -- it will cancel the mouse action  205e

  if slide_on_store > 0  // 206a cancel sliding after store
  then begin
    slide_on_store := 0;
    xshift := stored_xshift;
    yshift := stored_yshift;
  end;

  pad_form.cancel_mouse_action_popup_entry.Enabled := True;

  pad_caption(caption_str);
  caption_add(trail_str);

  mouse_label_string := mouse_str;

  with action_form do begin

    if mouse_click_action = 0     // use drag mode only...
    then begin
      mouse_action_button_down := True;                    // so start with button down.
      action_label.Caption := ' •  ' + mouse_label_string;   // add bullet marker.
    end
    else
      action_label.Caption := mouse_label_string;

    action_label.Width := Canvas.TextWidth(action_label.Caption) + 2;  // 205b bug fix for Wine

    action_update(trail_str);

    if mouse_labels = True then begin
      action_form.Tag := 0;        // allow it to resize for the new action.
      action_panel_resize;
      Show;
    end;

  end;//with

  pad_form.Cursor := mouse_action_cursor;

  mouse_modify := 0;                         // 0=selected, but not in progress yet.

  if GetCursorPos(mps) = False then begin
    mps.X := 0;
    mps.Y := 0;
  end;

  SetCursorPos(mps.X, mps.Y);
  // need a mouse move event to ensure pad cursor setting after any screen cursor change.
end;
//______________________________________________________________________________________

procedure pad_mouse_move(shift_state: TShiftState; X, Y: integer);

// !!! N.B. also comes here on Mouse UP (after doing MouseUp).
var
  oppx, oppy: integer;
  mode, zoom_mode: integer;
  //mouse_str,bullet_str:string;
  info_caption_str, jotter_abs_xy_str, jotter_rel_xy_str: string;
  //ring_caption_str:string;
  trail_str: string;

  //tx_str:string;             // for name highlighting ...
  //tx_x, tx_y, f_z:integer;

  mouse_relx, mouse_rely: double;
  measured_x, measured_y, measured_diag: double;

  //maxbg:integer;
  //bgk:integer;
  //md_label_left, md_label_top:integer;

  grid_factor: double;
  grid_str: string;

  /////////////////////////////////////

  procedure opp_convert;

  begin
    if opposite_way = True                         // turnout facing opposite way ?
    then begin
      oppx := pad_form.ClientWidth - X;
      // so reverse sense of mouse movements.
      oppy := pad_form.ClientHeight - Y;
    end
    else begin
      oppx := X;
      oppy := Y;
    end;
    if oppx = 0 then
      oppx := 1;    // prevent divisions by zero later (screen-edge clicked).
    if oppy = 0 then
      oppx := 1;
  end;
  /////////////////////////////////////

  function do_edge_panning: boolean;

  var
    mps, mpp: TPoint;
    // mouse position for edge scrolling.   whole screen, pad form.

  begin
    Result := True;    // default = done some panning.

    with pad_form do begin
      if X > (ClientWidth - 4) then begin
        lock_scaling_menu_entry.Click;

        zoom_offsetx_now := zoom_offsetx;
        zoom_offsety_now := zoom_offsety;

        repeat
          pan_button_click(1.0, 2, (ssCtrl in shift_state));
          if Application.Terminated = False then
            Application.ProcessMessages;
          if GetCursorPos(mps) = False then begin
            mps.X := 0;
            mps.Y := 0;
          end;
          mpp := pad_form.ScreenToClient(mps);
        until (mpp.X < (ClientWidth - 4)) or (edge_panning_on_menu_entry.Checked = False) or
          ((GetKeyState(VK_SCROLL) and 1) <> 0);
        // scroll locked.
        EXIT;
      end;

      if (X < 3) and (Y > (ClientHeight div 3))
      // to avoid conflicts when accessing the control menu.
      then begin
        lock_scaling_menu_entry.Click;

        zoom_offsetx_now := zoom_offsetx;
        zoom_offsety_now := zoom_offsety;

        repeat
          pan_button_click(1.0, 1, (ssCtrl in shift_state));
          if Application.Terminated = False then
            Application.ProcessMessages;
          if GetCursorPos(mps) = False then begin
            mps.X := 0;
            mps.Y := 0;
          end;
          mpp := pad_form.ScreenToClient(mps);
        until (mpp.X > 3) or (edge_panning_on_menu_entry.Checked = False) or
          ((GetKeyState(VK_SCROLL) and 1) <> 0);  // scroll locked.
        EXIT;
      end;

      if Y > (ClientHeight - 15) then begin
        lock_scaling_menu_entry.Click;

        zoom_offsetx_now := zoom_offsetx;
        zoom_offsety_now := zoom_offsety;

        repeat
          pan_button_click(1.0, 4, (ssCtrl in shift_state));
          if Application.Terminated = False then
            Application.ProcessMessages;
          if GetCursorPos(mps) = False then begin
            mps.X := 0;
            mps.Y := 0;
          end;
          mpp := pad_form.ScreenToClient(mps);
        until (mpp.Y < (ClientHeight - 15)) or (edge_panning_on_menu_entry.Checked = False) or
          ((GetKeyState(VK_SCROLL) and 1) <> 0);
        // scroll locked.
        EXIT;
      end;

      if (Y < 16) and (X > (ClientWidth - (ClientWidth div 5)))
      // to avoid conflicts with the menu bar.
      then begin
        lock_scaling_menu_entry.Click;

        zoom_offsetx_now := zoom_offsetx;
        zoom_offsety_now := zoom_offsety;

        repeat
          pan_button_click(1.0, 3, (ssCtrl in shift_state));
          if Application.Terminated = False then
            Application.ProcessMessages;
          if GetCursorPos(mps) = False then begin
            mps.X := 0;
            mps.Y := 0;
          end;
          mpp := pad_form.ScreenToClient(mps);
        until (mpp.Y > 16) or (edge_panning_on_menu_entry.Checked = False) or
          ((GetKeyState(VK_SCROLL) and 1) <> 0);  // scroll locked.
        EXIT;
      end;
      Result := False;     // no panning done.
    end;//with pad_form
  end;
  /////////////////////////////////////////////////////////////

  function jot_xy_text(d: double): string;

  begin
    Result := FormatFloat('###0.00;"- "###0.00', d * grid_factor);
    if (omit_neg_brackets = False) and (d < 0) then
      Result := '[ ' + Result + ' ]';
  end;
  //////////////////////////////////////////////////////////////////

begin

  if (X = old_mouse_move_X) and (Y = old_mouse_move_Y) then
    EXIT;  // 205e   no actual move

  old_mouse_move_X := X;   // 205e
  old_mouse_move_Y := Y;   // 205e


  if (shift_state = [ssMiddle]) or (allow_left_button_pan = True)
  // 0.91.c    move pad on middle button down (or left).
  then begin
    zoom_offsetx := zoom_offsetx_now - (X - zoff_now_x) * ffx;
    zoom_offsety := zoom_offsety_now - (Y - zoff_now_y) * ffy;

    do_rollback := False;       // no need to put this in rollback register on redraw.
    redraw(False);

    EXIT;
  end;

  if (mouse_modify > 0) and (mouse_action_button_down = False) and (mouse_click_action < 1)
  // only need to do it once once (and if allowed).
  then begin
    if ((ABS(X - pad_click_X) > 10) or (ABS(Y - pad_click_Y) > 10)) and
      ((ssLeft in shift_state = True) or (ssMiddle in shift_state = True) or
      (ssRight in shift_state = True)) then begin
      mouse_action_button_down := True;
      // moved with button down.
      action_form.action_label.Caption := ' •  ' + mouse_label_string;
      // add bullet marker.
      action_form.action_label.Width :=
        action_form.Canvas.TextWidth(action_form.action_label.Caption) + 2;
      // 205b bug fix for Wine
    end;
  end;

  mouse_now_x := mouse_x(X);     //  keep track of mouse position in mm.
  mouse_now_y := mouse_y(X, Y);

  mouse_relx := mouse_now_x - jotter_dx_org;
  mouse_rely := mouse_now_y - jotter_dy_org;

  case jot_readout_units of
    0: begin      // as grid
      case grid_labels_code_i of
        1:
          grid_str := 'feet';     //  labels in feet.
        2:
          grid_str := 'inches';   //  labels in inches.
        3:
          grid_str := 'proto-feet'; //  labels in prototype feet.
        4:
          grid_str := 'cm';       //  labels in cm.
        6:
          grid_str := 'mm';       //  labels in mm.
        else
          grid_str := 'mm';       //  was run_error(223);
      end;//case
    end;
    1:
      grid_str := 'mm';
    2:
      grid_str := 'inches';
    else
      grid_str := 'mm';
  end;//case

  case jot_readout_units of
    0: begin      // as grid
      case grid_labels_code_i of
        1:
          grid_factor := 1 / 304.8; //  labels in feet.
        2:
          grid_factor := 1 / 25.4;  //  labels in inches.
        3:
          grid_factor := 1 / scale; //  labels in prototype feet.
        4:
          grid_factor := 1 / 10;    //  labels in cm.
        6:
          grid_factor := 1;       //  labels in mm.
        else
          grid_factor := 1;       //  mm, was run_error(222);
      end;//case
    end;
    1:
      grid_factor := 1.0;       // mm
    2:
      grid_factor := 1 / 25.4;    // inches
    else
      grid_factor := 1.0;       // mm
  end;//case

  info_caption_str := ' X : ' + captext(mouse_now_x) + ' mm     Y : ' +
    captext(mouse_now_y) + ' mm';
  jotter_abs_xy_str := '   X = ' + jot_xy_text(mouse_now_x) + '     Y = ' +
    jot_xy_text(mouse_now_y) + '  ' + grid_str + ' (grid)';
  // abs dimensions for the jotter read-out.
  jotter_rel_xy_str := ' dX = ' + jot_xy_text(mouse_relx) + '   dY = ' +
    jot_xy_text(mouse_rely) + '   Diag = ' +
    jot_xy_text(SQRT(SQR(mouse_relx) + SQR(mouse_rely))) + '  ' + grid_str + ' (moved)';
  // rel dimensions for the jotter read-out.

  if Screen.Cursor <> crNone then begin
    info_form.mouse_now_panel.Caption := info_caption_str;
    // show current mouse position in the info.
    jotter_form.jotter_abs_xy_readout_panel.Caption := jotter_abs_xy_str;    // 0.71.b 2-6-01
    jotter_form.jotter_rel_xy_readout_panel.Caption := jotter_rel_xy_str;    // 0.71.c 4-6-01
  end
  else begin
    info_form.mouse_now_panel.Caption := ' ( mouse action )';
    jotter_form.jotter_abs_xy_readout_panel.Caption := ' ( mouse action )';
    jotter_form.jotter_rel_xy_readout_panel.Caption := ' ( mouse action )';
  end;

  // pad edge panning...

  if (pad_form.edge_panning_on_menu_entry.Checked = True) and
    ((GetKeyState(VK_SCROLL) and 1) = 0) and (mouse_modify < 1)
  // edge panning on and not locked off.
  then begin
    if do_edge_panning = True          // go do any edge-panning.
    then
      EXIT;
  end;

  if mouse_draw_lines = True then begin
    caption_add(info_caption_str);     // show cross-hair position.
    if mouse_drawing_in_progress = True  // do a temporary drawn line...
    then begin

      with pad_form.Canvas do begin
        Pen.Width := 1;
        Pen.Mode := pmXor;              // so can erase

        if bgnd_form.dotted_radio_button.Checked = True then begin
          Brush.Color := paper_colour;    // gaps in dotted lines
          Brush.Style := bsClear;
          TextOut(0, 0, '');
          // !!! Delphi bug? This seems to be necessary before dotted lines will draw properly.
          // TextOut obviously initialises some background mask property which I have been unable
          // to find or set any other way.

          Pen.Style := psDot;
        end
        else
          Pen.Style := psSolid;

        if check_dark_paper = False then
          Pen.Color := paper_colour  // ditto with xor to give black line on any paper.
        else
          Pen.Color := clWhite;      // or white line on black paper.

        MoveTo(draw_mouse_down_X, draw_mouse_down_Y);
        // saved line starting point.
        LineTo(temp_mouse_X, temp_mouse_Y);
        // erase last temporary line.

        MoveTo(draw_mouse_down_X, draw_mouse_down_Y);
        // saved line starting point.
        LineTo(X, Y);                                   // and draw a new one.
      end;//with

      temp_mouse_X := X;    // for next time.
      temp_mouse_Y := Y;
    end;
    EXIT;
  end;

  if (zoom_rectangle = True) or (group_fence_rectangle = True) or
    (output_boundary_rectangle = True)  // 0.93.a    // this is not a mouse action.
    or (drawn_shape_rectangle = True) then begin
    caption_add(info_caption_str);   // show cross-hair position.
    if (rectangle_in_progress = True)  // do a temporary rectangle...
    then begin

      with pad_form.Canvas do begin

        Pen.Width := 1;
        // draw two rectangles (not for shapes) for bolder line, each with pen width 1,
        // this gives accurate square corners, unlike pen width 2.
        Pen.Mode := pmXor;       // so can erase
        Pen.Style := psSolid;

        if check_dark_paper = False then
          Pen.Color := paper_colour  // ditto with xor to give black line on any paper.
        else
          Pen.Color := clWhite;      // or white line on black paper.

        // first erase last rectangles...

        if rectangle_exists = True then begin
          MoveTo(draw_mouse_down_X, draw_mouse_down_Y);
          // saved inner rectangle top left.
          LineTo(temp_mouse_X, draw_mouse_down_Y);        // saved top edge.
          LineTo(temp_mouse_X, temp_mouse_Y);
          // saved right edge.
          LineTo(draw_mouse_down_X, temp_mouse_Y);
          // saved bottom edge.
          LineTo(draw_mouse_down_X, draw_mouse_down_Y);
          // saved left edge.

          if drawn_shape_rectangle = False then begin
            MoveTo(draw_mouse_down_X - 1, draw_mouse_down_Y - 1);
            // saved outer rectangle top left.
            LineTo(temp_mouse_X + 1, draw_mouse_down_Y - 1);
            // saved top edge.
            LineTo(temp_mouse_X + 1, temp_mouse_Y + 1);
            // saved right
            LineTo(draw_mouse_down_X - 1, temp_mouse_Y + 1);
            // saved bottom edge..
            LineTo(draw_mouse_down_X - 1, draw_mouse_down_Y - 1);
            // saved left edge.
          end;
        end;

        // then draw the new ones ...

        MoveTo(draw_mouse_down_X, draw_mouse_down_Y);
        LineTo(X, draw_mouse_down_Y);                   // new top edge.
        LineTo(X, Y);                                   // new right edge.
        LineTo(draw_mouse_down_X, Y);                   // new bottom edge.
        LineTo(draw_mouse_down_X, draw_mouse_down_Y);   // new left edge.

        if drawn_shape_rectangle = False then begin
          MoveTo(draw_mouse_down_X - 1, draw_mouse_down_Y - 1);
          LineTo(X + 1, draw_mouse_down_Y - 1);
          // new top edge.
          LineTo(X + 1, Y + 1);
          // new right edge.
          LineTo(draw_mouse_down_X - 1, Y + 1);
          // new bottom edge.
          LineTo(draw_mouse_down_X - 1, draw_mouse_down_Y - 1);
          // new left edge.
        end;

        rectangle_exists := True;
      end;//with

      temp_mouse_X := X;    // for next time.
      temp_mouse_Y := Y;
    end;
    EXIT;
  end;

  if (grid_form.Visible = True) and ((ring_mod = 0) or (mouse_modify < 1))
  // no ring moving - measure to actual mouse position
  then begin
    measured_x := mouse_now_x - measure_org_x;
    // if ring moving must wait until after trail_ring to get its position.
    measured_y := mouse_now_y - measure_org_y;

    measured_diag := SQRT(SQR(measured_x) + SQR(measured_y));

    with grid_form do begin
      measuring_panel.Color := clwhite;
      x_label.Caption := 'X :   ' + captext(measured_x) + '  mm';
      y_label.Caption := 'Y :   ' + captext(measured_y) + '  mm';
      diag_label.Caption := 'Diagonal :   ' + captext(measured_diag) + '  mm';
    end;//with
  end;

  if select_centre = True       // this is not a mouse action - just show cross-hair position.
  then begin
    caption_add(info_caption_str);
    EXIT;
  end;

  if mouse_modify < 0 {adjust_in_progress=False}      // no mouse action, check for selection...
  then begin
    if ((GetKeyState(VK_CAPITAL) and 1) <> 0)     // caps lock on?
      //or (click_current=True)
      or (click_bgnd_select = True) or (shift_click = True) or (shift_state = [ssShift])

    // go find/highlight any background keep at this location.
    then begin
      mouse_on_bgkeep(X, Y, False);      // (in keep_select)
      EXIT;
    end;
    //EXIT;
  end;

  if (shove_timber_form.Showing = True) and (mouse_modify < 0) and (hide_current_flag = False) then
    mouse_on_timber_number(X, Y);  // see if it needs highlighting.

  if (check_diffs_form.Showing = True) and (mouse_modify < 0) and (hide_current_flag = False) then
    mouse_on_check_label(X, Y);  // see if it needs highlighting.

  //   -----  mouse actions...

  if mouse_modify < 1 then
    EXIT;   //  no mouse actions in progress.

  //  0.82.a  //  ignore adjust moves while wrong buttons down (Shift key or Left mouse button allowed)..

  if (shift_state <> []) and (shift_state <> [ssLeft]) and (shift_state <> [ssShift]) and
    (shift_state <> [ssLeft, ssShift]) then
    EXIT;

  if X = 0 then
    X := 1;           //  prevent div 0 calc problems (mouse on screen-edge).
  if Y = 0 then
    Y := 1;

  //if off_screen=True then begin

  mode := 7;
  zoom_mode := 9;

  (*  out 0.93.a            end
                     else begin
                            {    out v:0.68.a 9-3-01.
                               if bgkeeps_form.bgkeeps_listbox.Items.Count<mode_swap
                               then mode:=1     // (might be changed to zoom_mode below).
                               else}
                            mode:=3;
                            zoom_mode:=5;
                          end;
*)

  case mouse_modify of

    1: begin
      opp_convert;

      trail_curving(oppy);      // first change the curving.
      trail_xing(oppx);         // then the size.

      // both size and curving

      if draw_mode <> 2 then
        mode := zoom_mode;                 // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click})
      else
        init_resize;                 // ensure switch mods if no tracing.

      if spiral = True then
        trail_str := captext(nomrad1) + ' mm  /  ' + captext(nomrad2) + ' mm'
      else
        trail_str := captext(nomrad) + ' mm';
    end;

    2: begin
      opp_convert;
      trail_xing(oppx);      // F5  size

      if draw_mode <> 2 then
        mode := zoom_mode;    // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click})
      else
        init_resize;           // ensure switch mods if no tracing.

      trail_str := '1 : ' + captext(k3n);
    end;

    3: begin                            // F6  curving...
      opp_convert;
      trail_curving(oppy);

      if trace_mouse = True then
        gocalc(2, mode{+first_click});

      if spiral = True then
        trail_str := captext(nomrad1) + ' mm  /  ' + captext(nomrad2) + ' mm'
      else
        trail_str := captext(nomrad) + ' mm';
    end;

    4: begin
      opp_convert;
      trail_length(oppx);    // F4  overall length

      if draw_mode <> 2 then
        mode := zoom_mode;                  // free-scaling - change mode.
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(turnoutx) + ' mm';
    end;

    5: begin
      if f7_beginner = True then
        f7_snap_allow := not (ssShift in shift_state)   // F7 snapping 0.82.a
      else
        f7_snap_allow := (ssShift in shift_state);      // 215a

      trail_shift(X, Y);      // F7  shift

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'X : ' + captext(xshift) + ' mm      Y : ' + captext(yshift) + ' mm';
    end;

    6: begin
      trail_twist(Y);        // F8  rotate

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'by : ' + captext((kform - kform_start) * hand_i * 180 / Pi) +
        ' degrees.   peg  at : ' + captext(arm_angle * hand_i * 180 / Pi) +
        ' degrees' + k_ram_str(arm_angle * hand_i);
    end;

    7: begin
      trail_zoom(X);         // scale zoom

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'pad  width : ' + captext(screenx) + ' mm';
    end;

    8: begin
      opp_convert;
      trail_approach(oppx);  // F3  approach length (F3 / F4  plain-track length)

      if draw_mode <> 2 then
        mode := zoom_mode;    // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(xorg) + ' mm';
    end;

    9: begin
      trail_datum(Y);        // datum

      mode := zoom_mode;       // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(y_datum) + ' mm';
    end;

    10: begin
      opp_convert;
      trail_trans_length(oppx);   // SHIFT+CTRL-F4  transition length

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(tst) + ' mm';
    end;

    11: begin
      trail_zoffset(X, Y);    // move pad origin

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := ' X : ' + captext(zoom_offsetx) + ' mm   Y : ' + captext(zoom_offsety) + ' mm';
    end;

    12: begin
      trail_spot(X, pad_form.ClientHeight - Y);    // neg, so up screen zooms in.
      // CTRL-F1  spot zoom

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'pad  width : ' + captext(screenx) + ' mm';
    end;

    13: begin
      if peg_rail <> 0            // peg moves along a rail.
      then begin
        opp_convert;
        trail_peg(oppx, oppy);  // CTRL-F8  move peg along.
      end
      else
        trail_peg(X, Y);          // CTRL-F8  peg moves free.

      if trace_mouse = True then begin
        gocalc(2, mode{+first_click});
        //if notch_linked_to_peg=True then new_notch(get_peg_for_notch,True);
      end;

      trail_str := 'X : ' + captext(pad_peg_point.x) + ' mm   Y : ' +
        captext(pad_peg_point.y) + ' mm';
    end;

    14: begin
      trail_orbit(X);        // CTRL-F5  orbit

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'peg  at : ' + captext(arm_angle * hand_i * 180 / Pi) +
        ' degrees' + k_ram_str(arm_angle * hand_i);
    end;

    15: begin
      trail_notch(X, Y);      // move notch

      if mode = 1 then
        mode := 3;      // otherwise doesn't erase on pad.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});

      trail_str := 'X : ' + captext(notchx) + ' mm   Y : ' + captext(notchy) + ' mm';
    end;

    16: begin
      opp_convert;
      trail_trans_start(oppx);  // SHFT+CTRL-F3  transition start

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(os) + ' mm';
    end;

    17: begin
      trail_shift_keeps(X, Y);   // SHFT+CTRL-F7  shift group

      if mode = 1 then
        mode := 3;                                // otherwise doesn't erase on pad.
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'X  by : ' + captext(xshift_keeps) + ' mm   Y  by : ' +
        captext(yshift_keeps) + ' mm';
    end;

    18: begin
      trail_twist_keeps(Y);     // SHIFT+CTRL-F8  rotate group

      if mode = 1 then
        mode := 3;                                // otherwise doesn't erase on pad.
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'by : ' + captext(0 - kform_keeps * 180 / Pi) + ' degrees' +
        k_ram_str(0 - kform_keeps);
      // change of sign needed because of ??
    end;

    19: begin
      trail_ring(X, Y);       // move ring

      if mode = 1 then
        mode := 3;                                // otherwise doesn't erase on pad.
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'X : ' + captext(rings[0, 0]) + ' mm   Y : ' + captext(rings[0, 1]) + ' mm';


      if grid_form.Visible = True
      // ring moving - can measure to ring now its been moved.
      then begin
        measured_x := rings[0, 0] - measure_org_x;
        // ring moving - measure to ring.
        measured_y := rings[0, 1] - measure_org_y;

        measured_diag := SQRT(SQR(measured_x) + SQR(measured_y));

        with grid_form do begin
          measuring_panel.Color := clYellow;
          x_label.Caption := 'X :   ' + captext(measured_x) + '  mm';
          y_label.Caption := 'Y :   ' + captext(measured_y) + '  mm';
          diag_label.Caption := 'Diagonal :   ' + captext(measured_diag) + '  mm';
        end;//with
      end;
    end;

    20: begin
      opp_convert;
      trail_slide(oppx);     // F9  slide

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'X : ' + captext(0 - pegx) + ' mm';
    end;

    21: begin
      opp_convert;
      trail_slew_start(oppx);    // SHIFT+CTRL-F5  slew start

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(slew_s) + ' mm';
    end;

    22: begin
      opp_convert;
      trail_slew_length(oppx);   // SHIFT+CTRL-F6  slew length';

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(slew_l) + ' mm';
    end;

    23: begin
      opp_convert;
      trail_slew_amount(oppy);   // CTRL-F7  slew amount

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(slew) + ' mm';
    end;

    24: begin
      trail_printsize(X);     // adjust print size.

      if trace_mouse = True then
        gocalc(2, zoom_mode);
      trail_str := captext(out_factor * 100) + ' %';
    end;

    25: begin
      trail_shove_along(X);          // shove along

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := current_shove_str + '  along  by : ' + captext(shovex) + ' mm';
    end;

    26: begin
      trail_shove_throw(Y);         // shove throw

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := current_shove_str + '  throw  by : ' + captext(shoveo) + ' mm';
    end;

    27: begin
      opp_convert;
      trail_roam(oppx);      // CTRL-F9  roam along length

      if draw_mode <> 2 then
        mode := zoom_mode;    // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'approach  length : ' + captext(xorg) + ' mm';
    end;

    28: begin
      opp_convert;
      trail_slew2_factor(oppx);  // mode 2 slew factor

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(slew2_kmax * 50);
    end;

    29: begin
      trail_bunch(X, Y);   // pad bunching

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'bunched  by  (X) : ' + captext(bunching_jump) +
        ' mm    sheared  by  (Y) : ' + captext(bunching_shear) + ' mm';
    end;

    30: begin
      trail_porg(X, Y);    // SHIFT+CTRL-F10  page origin

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'X : ' + captext(print_pages_top_origin) + ' mm   Y : ' +
        captext(print_pages_left_origin) + ' mm';
    end;

    31: begin
      trail_corner1(X, Y);    // shape corner 1

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'by  X : ' + captext(shapes_shiftx_now) + ' mm   Y : ' +
        captext(shapes_shifty_now) + ' mm';
    end;

    32: begin
      trail_corner2(X, Y);    // shape corner 2

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'by  X : ' + captext(shapes_shiftx_now) + ' mm   Y : ' +
        captext(shapes_shifty_now) + ' mm';
    end;

    33: begin
      trail_shape(X, Y);      // shift shape

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'by  X : ' + captext(shapes_shiftx_now) + ' mm   Y : ' +
        captext(shapes_shifty_now) + ' mm';
    end;

    34: begin
      trail_allshapes_shift(X, Y);  // shift all shapes

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'by  X : ' + captext(shapes_shiftx_now) + ' mm   Y : ' +
        captext(shapes_shifty_now) + ' mm';
    end;

    35: begin
      opp_convert;
      trail_snake(oppx);     // CTRL-F6 snake.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'X : ' + captext(0 - pegx) + ' mm';
    end;

    36: begin
      trail_allshapes_scale(Y);  // scale all shapes

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'by : ' + captext(shapes_scaled_already * 100) + ' %';
    end;

    37: begin
      trail_allshapes_rotate(Y);  // rotate all shapes

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'by : ' + captext(shapes_rotated_already * 180 / Pi) + ' degrees';
    end;

    38: begin
      trail_oneshape_scale(X);  // scale one shape.

      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'by : ' + captext(shapes_scaled_already * 100) + ' %';
    end;


    39: begin
      trail_shove_length(Y);          // shove length

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := current_shove_str + '  lengthened  by : ' + captext(shovel) + ' mm';
    end;

    40: begin
      trail_shove_width(X);          // shove width

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := current_shove_str + '  widened  by : ' + captext(shovew * 2) + ' mm';
    end;

    41: begin
      trail_shove_twist(Y);          // shove twist

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := current_shove_str + '  twisted  by : ' + captext(shovek * 180 / Pi) +
        ' degrees' + k_ram_str(shovek);
    end;

    42: begin
      opp_convert;
      trail_blanking(oppx);  // blanking length

      //if draw_mode<>2 then mode:=zoom_mode;    // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(startx) + ' mm';
    end;

    43: begin
      opp_convert;
      trail_roll(oppx);      // CTRL-F4  roll rails and sleepers

      //if draw_mode<>2 then mode:=zoom_mode;    // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'rolled - in : ' + captext(tb_roll_percent) + ' %  of  a  rail';
    end;

    44: begin
      trail_ringdia(Y);         // adjust ring diameter.
      if mode = 1 then
        mode := 3;   // otherwise doesn't erase on pad.
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'inner  dia : ' + captext(ring_dia) + ' mm';
    end;


    45: begin
      trail_ruler1(X, Y);       // move ruler start end.

      if mode = 1 then
        mode := 3;                                // otherwise doesn't erase on pad.
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'X : ' + captext(ruler_startx) + ' mm   Y : ' + captext(ruler_starty) + ' mm';
    end;

    46: begin
      trail_ruler2(X, Y);       // move ruler start end.

      if mode = 1 then
        mode := 3;                                // otherwise doesn't erase on pad.
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := 'X : ' + captext(ruler_endx) + ' mm   Y : ' + captext(ruler_endy) + ' mm';
    end;

    47: begin                            // curving swell...
      opp_convert;
      trail_swell(oppy);
      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(nomrad) + ' mm';
    end;

    48: begin
      trail_shove_crab(X);         // shove crab

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := current_shove_str + '  crab  by : ' + captext(shovec) + ' mm';
    end;

    49: begin      // move name labels  // 0.82.d

      trail_shift_labels(X, Y);

      //if mode=1 then mode:=3;                                // otherwise doesn't erase on pad.
      if trace_mouse = True then
        gocalc(2, zoom_mode{+first_click});
      trail_str := 'X  by : ' + captext(xshift_labels) + ' mm   Y  by : ' +
        captext(yshift_labels) + ' mm';
    end;

    // 0.93.a mouse_modify matches repeat_last_index above 49 (see 99)...


    50: begin              // TS platform start  0.93.a
      opp_convert;
      trail_platform_ts_start_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ts_start_mm) + ' mm';
    end;

    51: begin              // TS platform length  0.93.a
      opp_convert;
      trail_platform_ts_length_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ts_length_mm) + ' mm';
    end;

    52: begin              // TS platform starting width  0.93.a
      opp_convert;
      trail_platform_ts_start_width_ins(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ts_start_width_ins) + '  inches full-size';
    end;

    53: begin              // TS platform ending width  0.93.a
      opp_convert;
      trail_platform_ts_end_width_ins(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ts_end_width_ins) + '  inches full-size';
    end;

    54: begin              // MS platform start  0.93.a
      opp_convert;
      trail_platform_ms_start_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ms_start_mm) + ' mm';
    end;

    55: begin              // MS platform length  0.93.a
      opp_convert;
      trail_platform_ms_length_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ms_length_mm) + ' mm';
    end;

    56: begin              // MS platform starting width  0.93.a
      opp_convert;
      trail_platform_ms_start_width_ins(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ms_start_width_ins) + '  inches full-size';
    end;

    57: begin              // MS platform ending width  0.93.a
      opp_convert;
      trail_platform_ms_end_width_ins(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ms_end_width_ins) + '  inches full-size';
    end;


    58: begin                  // SHIFT-F12   0.93.a
      opp_convert;
      trail_gaunt_offset(oppy);      // gaunt offset
      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(gaunt_offset_in) + '  inches full-size';
    end;//case 58


    59: begin                  // F9   0.93.a
      opp_convert;
      trail_vee(oppx);      // V-crossing angle.
      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := '1 : ' + captext(k3n);
    end;

    60: begin                 // F10   0.93.a
      opp_convert;
      trail_hdk(oppx);      // K-crossing angle.
      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := '1 : ' + captext(hdkn);
    end;


    61: begin
      trail_rect_x1(X);    // output boundary rectangle left

      if trace_mouse = True then
        gocalc(2, zoom_mode);
      trail_str := 'X : ' + captext(output_rectangle_x1) + ' mm';
    end;

    62: begin
      trail_rect_x2(X);    // output boundary rectangle right

      if trace_mouse = True then
        gocalc(2, zoom_mode);
      trail_str := 'X : ' + captext(output_rectangle_x2) + ' mm';
    end;

    63: begin
      trail_rect_y2(Y);    // output boundary rectangle top

      if trace_mouse = True then
        gocalc(2, zoom_mode);
      trail_str := 'Y : ' + captext(output_rectangle_y2) + ' mm';
    end;

    64: begin
      trail_rect_y1(Y);    // output boundary rectangle top

      if trace_mouse = True then
        gocalc(2, zoom_mode);
      trail_str := 'Y : ' + captext(output_rectangle_y1) + ' mm';
    end;

    65: begin
      trail_rect_position(X, Y);    // output boundary rectangle move

      if trace_mouse = True then
        gocalc(2, zoom_mode);
      trail_str := 'X : ' + captext(output_rectangle_x1) + ' mm   Y : ' +
        captext(output_rectangle_y1) + ' mm';
    end;

    66: begin              // check diff length 0.94.a
      opp_convert;
      trail_check_len_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := 'adjust  by : ' + captext(mouse_diff.len_diff * inscale) + ' mm';
    end;

    67: begin              // check diff flare length 0.94.a
      opp_convert;
      trail_check_flare_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := 'adjust  by : ' + captext(mouse_diff.flr_diff * inscale) + ' mm';
    end;

    68: begin              // check diff end gap 0.94.a
      opp_convert;
      trail_check_gap_mm(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := 'adjust  by : ' + captext(mouse_diff.gap_diff) + ' mm';
    end;

    69: begin              // dummy vehicle start
      opp_convert;
      trail_dv_start(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := 'roll  to :  ' + captext(cdvi.dv_start * inscale) + ' mm';
    end;

    70: begin              // dummy vehicle clearance
      opp_convert;
      trail_dv_clearance(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(cdvi.dv_clearance) + ' inches  ( ' +
        captext(cdvi.dv_clearance * inscale) + ' mm )';
    end;

    // 207a ...

    71: begin              // MS platform skew at start
      opp_convert;
      trail_platform_ms_start_skew_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ms_start_skew_mm) + ' mm';
    end;

    72: begin              // MS platform skew at end
      opp_convert;
      trail_platform_ms_end_skew_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ms_end_skew_mm) + ' mm';
    end;

    73: begin              // TS platform skew at start
      opp_convert;
      trail_platform_ts_start_skew_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ts_start_skew_mm) + ' mm';
    end;

    74: begin              // TS platform skew at end
      opp_convert;
      trail_platform_ts_end_skew_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(platform_ts_end_skew_mm) + ' mm';
    end;

    75: begin                  // turnout road CTRL+F12
      opp_convert;
      trail_turnout_road(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(xorg + turnout_road_endx) + ' mm';
    end;


    76: begin              // adjacent centres TS  213a
      opp_convert;
      trail_adj_centres_ts(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(cpi.trtscent_pi) + ' mm';
    end;

    77: begin              // adjacent centres MS  213a
      opp_convert;
      trail_adj_centres_ms(oppy);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(cpi.trmscent_pi) + ' mm';
    end;


    78: begin              // TS trackbed start  215a ...
      opp_convert;
      trail_trackbed_ts_start_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(trackbed_ts_start_mm) + ' mm';
    end;

    79: begin              // TS trackbed length
      opp_convert;
      trail_trackbed_ts_length_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(trackbed_ts_length_mm) + ' mm';
    end;


    80: begin              // MS trackbed start
      opp_convert;
      trail_trackbed_ms_start_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(trackbed_ms_start_mm) + ' mm';
    end;

    81: begin              // MS trackbed length
      opp_convert;
      trail_trackbed_ms_length_mm(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(trackbed_ms_length_mm) + ' mm';
    end;

    82: begin                  // main road exit  217a
      opp_convert;
      trail_main_road(oppx);

      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(xorg + main_road_endx) + ' mm';
    end;

    83: begin                  // gaunt radius  217b
      opp_convert;
      trail_gaunt_curvature(oppy);
      if trace_mouse = True then
        gocalc(2, mode);
      trail_str := captext(tradius - g / 2{1/gaunt_curvature}) + ' mm';
    end;


    // 0.93.a  99 was 50 ...

    99: begin           // adjust crossing entry straight  0.91.b
      opp_convert;
      trail_entry_straight(oppx);  // entry straight length

      //if draw_mode<>2 then mode:=zoom_mode;    // free-scaling - change mode.

      if trace_mouse = True then
        gocalc(2, mode{+first_click});
      trail_str := captext(fixed_sl) + ' mm';
    end;


    else
      EXIT;  // 217b run_error(91);
  end;//case

  caption_add(trail_str);
  action_update(trail_str);

  //first_click:=0;      // for next time.

  do_linked_notch;   // link notch if wanted.

end;
//__________________________________________________________________________________________

procedure do_linked_notch;       // link notch to control template.

var
  temp_y, temp_k, dummy, linkx, linky, linkangle, link_arm_angle: double;
  dummy_str: string;

  // 217b ..

  curving_rad, mod_linkangle, shrink_factor, tanx: double;

begin

  if (notch_linked_to_current = True)    // notch linked to template?
  {
     and (peg_code<>-1)
     and ((peg_code<>20) or (peg_rail<>0))
     } then begin

    old_notchx := notchx;       // for group linking...
    old_notchy := notchy;
    old_notch_angle := notch_angle;

    linkx := pegx;    //  default inits...
    linky := pegy;
    linkangle := pegangle;

    // get notch data at the required peg position...

    dummy_str := calc_peg_dims(notch_linked_code, linkx, linky, linkangle);
    // don't need string result.
    normalize_angle(linkangle);
    docurving(True, True, linkx, linky, notchx, temp_y, temp_k, curving_rad);
    notchy := temp_y * hand_i + y_datum;

    // 217b  gradient correction for radial shrink/enlarge ...

    if ABS(linkangle) < minfp then
      mod_linkangle := linkangle
    else begin
      try
        shrink_factor := (curving_rad - (linky - g / 2)) / curving_rad;
        tanx := 1 / TAN(linkangle);
        tanx := tanx * shrink_factor;
        mod_linkangle := ARCTAN(1 / tanx);
      except
        mod_linkangle := linkangle;
      end;//try
    end;

    link_arm_angle := mod_linkangle + temp_k + kform;
    // arm angle (actual on pad including curving and transforms).

    //link_arm_angle:=linkangle+temp_k+kform;        // arm angle (actual on pad including curving and transforms).

    normalize_angle(link_arm_angle);
    notch_angle := link_arm_angle * hand_i;

    if group_notch_linked = True then
      do_group_link_to_notch;
  end;
end;
//____________________________________________________________________________________

procedure normalize_kform;

begin
  normalize_angle(kform);
end;
//_____________________________________________________________________________________

procedure normalize_transforms;     // update shifts so that xform, yform can be zero,
// i.e. any subsequent rotation is about the origin,
// until xform, yform are modified again.
var
  x, y: double;     // use current transform data to transform/shift the origin to x,y.

begin
  x := xform - xform * COS(kform) + yform * SIN(kform) + xshift;
  y := yform - xform * SIN(kform) - yform * COS(kform) + yshift;

  xshift := x;                       // then normalise the data...
  yshift := y;
  xform := 0;
  yform := 0;

  normalize_kform;
end;
//___________________________________________________________________________________

procedure click_bgnd_to_current(bgnd_options: boolean);

begin
  cancel_adjusts(False);  // cancel flags and update the pad caption.

  if (keeps_list.Count > 0) and (clicked_keep_index > -1) and
    (clicked_keep_index < keeps_list.Count) then begin
    list_position := clicked_keep_index;
    // make it current in the keeps box.
    copy_keep_to_current(False, bgnd_options, True, False);   // copy to pad.

    gocalc(0, 0);       // direct recalc for shifts.

    if onto_notch = True then
      shift_onto_notch(False, False);
    if copy_datum = True then
      clear_transform_data;
    onto_notch := False;                                                  // only once...
    copy_datum := False;

    show_and_redraw(True, True);   // redraw pad when ready. (allow rollback).
  end;
end;
//___________________________________________________________________________________

procedure click_bgnd_to_selected;

begin
  //click_current:=False;           // the click cancels these...
  shift_click := False;

  if (keeps_list.Count > 0) and (clicked_keep_index > -1) and
    (clicked_keep_index < keeps_list.Count) then begin
    with keeps_list[clicked_keep_index] do begin
      if template_info.keep_dims.box_dims1.bgnd_code_077 <> -1 then
        group_selected := not group_selected
      else
        group_selected := False;                       // library template???
    end;//with
  end;

  if (any_selected < 1) and (group_notch_linked = True) then
    unlink_group;
end;
//______________________________________________________________________________


procedure align_current_over_this(keep_dims: Tkeep_dims; clicked: boolean);

// align the control template over other template.
// (gauge, size, timbering, etc unchanged).
var
  y_offset: double;

begin
  with keep_dims.box_dims1 do begin

    with transform_info do begin

      y_datum := datum_y;                   // y datum (green dot).

      //transform:=transforms_apply;        // False = ignore transform data.

      xform := x1_shift;                    //  mm    shift info...
      yform := y1_shift;                    //  mm

      kform := k_shift;                     //  radians.
      normalize_kform;

      xshift := x2_shift;                   //  mm
      yshift := y2_shift;                   //  mm

    end;//with

    if (pad_form.align_match_length_menu_entry.Checked = True)  //  0.91.b match overall length.
      and (clicked = True) then begin
      turnoutx := turnout_info1.turnout_length;
      if plain_track = True then
        xorg := turnoutx;
      turnout_i := 1;                             // length locked at new turnoutx.
    end;

    with align_info do begin

      //curved:=curving_flag;    // True=curved, False=straight.
      spiral := trans_flag;      // True=transition, False=fixed radius curving.

      //ycurv:=rad_offset;       // curving line offset mm.  // scrapped 26-7-00  v:0.64.a
      y_offset := rad_offset;

      nomrad := fixed_rad + y_offset;
      // fixed radius mm.     (include any offset from old files pre 0.64.a)...
      nomrad1 := trans_rad1 + y_offset;     // first transition radius mm.
      nomrad2 := trans_rad2 + y_offset;     // second transition radius mm.

      tst := trans_length;                // length of transition mm.
      os := trans_start;                  // start of transition mm.

      slewing := slewing_flag;   // slewing flag.              // !!! replacing Tspares 10-7-99...
      slew_s := slew_start;      // slewing zone start mm.
      slew_l := slew_length;     // slewing zone length mm.
      slew := slew_amount;       // amount of slew mm.

      slew2_kmax := tanh_kmax;           {:double;}  {spare_int1:integer;}
      // stretch factor for mode 2 slews.
      {spare_int2:integer;}
      // !!! double used because only 8 bytes available in existing file format (2 integers).
      slew_mode := slew_type;             {:byte;}   {spare_flag3:boolean;}
      // !!! byte used because only 1 byte available in existing file format 1-11-99.

      //cl_only:=cl_only_flag;   // for bgnd centre-line only.

    end;//with

    if hand_i <> turnout_info1.hand then begin
      hand_i := turnout_info1.hand;      // need to swap hand.
      gocalc(0, 0);                     // calcs for the peg, datum, etc.
      invert_handing;                  // swap again to preserve his handing.
    end;

  end;//with
end;
//________________________________________________________________________________________

procedure align_current_over_bgnd(index: integer; facing_facing, clicked: boolean);

// align the control template over clicked background template.
// (gauge, size, timbering, etc unchanged).
var
  temp_ti: Ttemplate_info;
  i: integer;

begin
  if (index < 0) or (index > (keeps_list.Count - 1)) or (keeps_list.Count < 1) then
    EXIT;

  with keeps_list[index].template_info.keep_dims.box_dims1 do begin    // 205d

    if ABS(proto_info.gauge_pi - g) > minfp
    // ??? menu should be disabled   205d mixed-gauge templates
    then begin
      snake_onto_bgnd_peg(index, facing_facing, True);
      // 205d mixed-gauge must align on centre-lines.
      EXIT;
    end;
  end;//with

  align_current_over_this(keeps_list[index].template_info.keep_dims, clicked);
  if facing_facing = False then
    swap_end_for_end;

  if clicked = True then begin
    temp_ti.keep_shove_list := Tshoved_timber_list.Create;
    try
      fill_kd(temp_ti);
      // this sequence updates all the menu check marks, etc..
      copy_keep(temp_ti);
    finally
      temp_ti.keep_shove_list.Free;
      show_and_redraw(False, True);                // might be hidden. (allow rollback).
    end;

    if pad_form.align_match_length_menu_entry.Checked = True
    //  0.91.b matched overall length.
    then begin
      i := alert(3, '     align  and  match  length',
        '||The control template has been matched to the length of the selected background template and aligned over it.'
        + '||Do you now want to delete or wipe the background template from under the control template?'
        + '||If you do so, remember to store the control template in its place after making any further changes.| ', '', '', '', 'delete  background  template', 'leave  background  template  unchanged', 'wipe  background  template', 0);
      case i of
        4: begin
          list_position := index;
          delete_keep(False, True);   // delete the background template
        end;
        6:
          wipe_it(index);    // wipe the background template (ignore result).
      end;//case
    end;//match
  end;//clicked
end;
//________________________________________________________________________________________

function check_peg_on_main: boolean;

var
  i: integer;

begin
  Result := False;  // default init.

  if ABS(pegy - g / 2) > minfp then begin
    i := alert(3, '    current  peg  not  on  main-side  centre',
      '|Align Control Template over Background Template.' +
      '||For this function to work as intended, the peg on the control template should be located on the main-side track centre-line.' + '||This is not currently the case. If you continue with the peg in its present position, the result may not be as you intended.', '', '', '', 'continue  unchanged', 'cancel    ', 'move  peg  to  main-side  centre  and  continue          ', 0);
    case i of
      5:
        EXIT;
      6:
        pad_form.peg_on_rail8_menu_entry.Click;
    end;//case
  end;
  Result := True;  // carry on.
end;
//__________________________________________________________________________________________


function snake_onto_this_peg(keep_dims: Tkeep_dims; facing_facing, alerts: boolean): boolean;

var
  i: integer;
  this_pegx, this_pegy, this_g: double;
  saved_notch: Tnotch;

begin
  Result := False;                          // default init.
  saved_notch := get_current_notch;         // save his current notch position.

  this_pegx := keep_dims.box_dims1.transform_info.peg_pos.x;
  //  mm  peg position for bgnd template.
  this_pegy := keep_dims.box_dims1.transform_info.peg_pos.y;
  //  mm  peg position for bgnd template.
  this_g := keep_dims.box_dims1.proto_info.gauge_pi;

  if (ABS(this_pegy - this_g / 2) > minfp) and (alerts = True) then
    if alert(3, '    background  peg  not  on  main-road  centre',
      'Snake  onto  Background  Peg' +
      '||The fixing peg on the background template is not currently located on the main-road centre-line (the template curving line).' + '||Are you sure that you want to snake the control template onto this peg ?', '', '', '', '', 'no  -  cancel', 'yes  -  continue', 0) = 5 then
      EXIT;

  if (ABS(pegy - g / 2) > minfp) and (alerts = True) then begin
    i := alert(3, '    current  peg  not  on  main-road  centre',
      'Snake  onto  Background  Peg' +
      '||The fixing peg on the control template is not located on the main-road centre-line (the template curving line).'
      + '||Are you sure that you want to snake the control template onto this background template ?', '', '', '', 'yes  -  continue  unchanged', 'no  -  cancel',
      'move  peg  to  main-road  centre  and  continue     ', 0);
    case i of
      5:
        EXIT;
      6:
        pad_form.peg_on_rail8_menu_entry.Click;
    end;//case
  end;

  align_current_over_this(keep_dims, False);

  if facing_facing = True          // both templates to face the same way (ladder)..
  then begin
    if spiral = True then
      os := os - (this_pegx - pegx);              // maintain transition alignment.
    if slewing = True then
      slew_s := slew_s - (this_pegx - pegx);     // maintain slewing alignment.
  end
  else begin
    // ends swapped to a facing-trailing combination (crossover or toe-to-toe)..
    swap_end_for_end;
    if spiral = True then
      os := os + (this_pegx - (turnoutx - pegx));              // maintain transition alignment.
    if slewing = True then
      slew_s := slew_s + (this_pegx - (turnoutx - pegx));     // maintain slewing alignment.
  end;

  gocalc(0, 0);                           // calc new peg, etc.

  set_current_notch(keep_dims.box_dims1.transform_info.notch_info);
  shift_onto_notch(False, False);

  if facing_facing = False then
    rotate_turnout(Pi, True);

  set_current_notch(saved_notch);
  Result := True;
end;
//_______________________________________________________________________________________

procedure snake_onto_bgnd_peg(index: integer; facing_facing, alerts: boolean);

begin
  if (index < 0) or (index > (keeps_list.Count - 1)) or (keeps_list.Count < 1) then
    EXIT;

  if snake_onto_this_peg(keeps_list[index].template_info.keep_dims,
    facing_facing, alerts) = False then
    EXIT;
end;
//______________________________________________________________________________

function popup_if_clicked(right_click: boolean): boolean;
  // popup and highlight bgnd keep if clicked on within limit g+1 square (arbitrary).
  // first clear any existing highlighting...
var
  old_index: integer;
  now_bgkeep: Tbgnd_keep;
  menu_caption_str: string;
  fb_str: string;             // 0.95.a

begin

  Result := False; // init;    // 0.91.c for drag-panning

  copy_draw_to_pad;

  // see if mouse is on a bgnd keep and highlight it...

  old_index := clicked_keep_index;   // save any existing index;

  clicked_keep_index := hover_mousedown(mouse_x(pad_click_X),
    mouse_y(pad_click_X, pad_click_Y), g / 2 + 1);

  if clicked_keep_index = -1 then
    EXIT;    // not on one.

  if clicked_keep_index = old_index    // already clicked, so cancel the popup.
  then begin
    clicked_keep_index := -1;              // so cancels only on first click.
    pad_form.cancel_popup_entry.Click;
    EXIT;
  end;

  draw_background_templates(pad_form.Canvas, 0, clicked_keep_index, True, hover_colour);
  //  draw directly on pad and highlight this one.

  if (classic_templot = False) and (right_click = False)   // 0.93.a Quick mode click on template
  then begin
    bgnd_clicked_in_quick_mode := True;
    pad_form.make_control_popup_entry.Click;
    bgnd_clicked_in_quick_mode := False;
    Result := True;
    EXIT;
  end;

  now_bgkeep := keeps_list[clicked_keep_index].bgnd_keep;
  // next background keep.

  with now_bgkeep do begin

    menu_caption_str := UpperCase(Trim(full_label_string));
    if Length(menu_caption_str) > 20 then
      menu_caption_str := Copy(menu_caption_str, 1, 18) + '...';  // 20 arbitrary.

    with keeps_list[clicked_keep_index].template_info.keep_dims.box_dims1 do begin

      pad_form.align_current_popup_entry.Enabled := (ABS(proto_info.gauge_pi - g) < minfp);
      // 205d disabled for mixed-gauge templates

      if rail_type = 2   // 0.95.a FB rail
      then
        fb_str := 'FB •  '
      else
        fb_str := 'BH •  ';

    end;//with

    pad_form.top_name_info_popup_entry.Caption := 'I    ' + fb_str + menu_caption_str;

    list_position := clicked_keep_index;  // make it current in the box (for Show in Box).

    with pad_form.Canvas do begin

      Font.Assign(pad_form.bgnd_keeps_font_label.Font);
      Font.Color := clBlack;

      Brush.Style := bsSolid;

      if paper_colour = clAqua then
        Brush.Color := clFuchsia
      else
        Brush.Color := clAqua;

      Font.Height := text_font_height;

      if requested_label_string = '' then
        showing_label_string := full_label_string
      else
        showing_label_string := requested_label_string;

      text_end_X := text_begin_X + TextWidth(showing_label_string);
      text_end_Y := text_begin_Y + TextHeight(showing_label_string);

      if pad_form.boxed_over_names_menu_entry.Checked = True then begin
        Pen.Color := Font.Color;
        Pen.Style := psSolid;     // 215b
        Rectangle(text_begin_X - 2, text_begin_Y - 2, text_end_X + 2, text_end_Y + 2);
      end;

      TextOut(text_begin_X, text_begin_Y, showing_label_string); // highlight it.
    end;//with Canvas

    caption_add(full_label_string);         // and in the pad caption.

  end;//with now_bgkeep

  if user_popup_X = (0 - 1) then
    popup_X := 4                // 213a...
  else
    popup_X := user_popup_X;

  if user_popup_Y = (0 - 1) then
    popup_Y := Screen.Height div 2     // Windows will adjust to fit
  else
    popup_Y := user_popup_Y;

  with keeps_list[clicked_keep_index] do begin
    if (template_info.keep_dims.box_dims1.mod_text_x = 0) and
      (template_info.keep_dims.box_dims1.mod_text_y = 0) then
      pad_form.restore_label_popup_entry.Enabled := False
    else
      pad_form.restore_label_popup_entry.Enabled := True;

    pad_form.select_bg_popup_entry.Checked := group_selected;
  end;//with

  pad_form.selection_popup.PopUp(popup_X, popup_Y);

  Result := True;     // 0.91.c
end;
//________________________________________________________________________________________

procedure mouse_action_grab(mode, X, Y: integer);

var
  aq: ERailData;
  save_switch_free: boolean;

begin
  if trace_mouse = True then begin
    if mode = 1          // no longer used 0.93
    then begin
      for aq in ERailData do begin
        if aqyn[aq] = True then begin
          ink_colour := paper_colour;
          show_a_line(pad_form.Canvas, aq, 1, True);
          // need to erase outer edges (ignore return).
        end;
      end;//for
    end;

    if full_draw = False then begin
      railedges(True, False, centre_lines);   // gauge faces only.
      guide_marks := True;
      // but show the guide marks for alignment with background.
      rad_ends := spiral or slewing;
      // show radial ends if transition or slewing.
      timber_marks := False;
      // no timbers or joint marks while adjusting and re-drawing.
      joint_marks := False;
    end;

    //first_click:=1;        // mouse move increments the mode for the first click.
  end;

  if hide_current_flag = True             // no sense in adjusting an invisible template...
  then begin
    hide_current_flag := False;
    save_hide := False;

    //pad_form.hide_current_menu_entry.Checked:=False;
    //pad_form.hide_current_popup_entry.Checked:=False;

    pad_form.show_control_template_menu_entry.Checked := True;   // 209c  radio item
    pad_form.show_control_template_popup_entry.Checked := True;  // 209c  radio item

    {if trace_mouse=False
               then begin
                      first_click:=0;     // no mouse-move to do the showing,
                      gocalc(2,mode+1);   // so need to show it on first click.
                    end;
            }
  end;

  //if notch_linked_to_peg=True then new_notch(get_peg_for_notch,True);

  do_linked_notch;   // link notch if wanted.

  if (mouse_modify = 1) or (mouse_modify = 2)      // both, or F5 size, actions.
  then begin
    save_switch_free := switch_free;
    // don't want to change the switch, otherwise it might not stay pegged.
    switch_free := False;
    gocalc(2, mode + 1);                  // show it on first click.
    switch_free := save_switch_free;
  end
  else
    gocalc(2, mode + 1);                    // show it on first click (all other actions).


  //pad_mouse_move([ssLeft],X,Y);    // to put the mouse labels on.
end;
//__________________________________________________________________________________________

procedure mouse_action_release(cancelling_adjusts: boolean);     // 0.79.a

begin
  Screen.Cursor := crDefault;

  if mouse_click_action <> 0 then
    mouse_action_button_down := False;   // don't clear it if drag only allowed.

  if mouse_modify < 0 then
    EXIT;                          // it's been cleared to zero by the terminating click.

  mouse_modify := 0;                                      // in case of button_down mode.
  action_form.action_2_image.Hide;
  action_form.image_panel.Color := clGray;
  allow_idle := not control_room_form.fast_100_menu_entry.Checked;
  // no mouse action - allow idle again.

  if mouse_click_action <> 0 then begin
    action_form.action_label.Caption := mouse_label_string;    // remove any bullet.
    action_form.action_label.Width :=
      action_form.Canvas.TextWidth(action_form.action_label.Caption) + 2; // bug fix for Wine
  end;

  with pad_form do begin

    guide_marks := guide_marks_menu_entry.Checked;        // guide marks back off if not wanted.
    rad_ends := rad_end_marks_menu_entry.Checked;         // ditto rad end marks.
    timber_marks := timber_centres_menu_entry.Checked or timber_outlines_menu_entry.Checked or
      timber_numbers_menu_entry.Checked;
    // ditto timbering.
    joint_marks := joint_marks_menu_entry.Checked;        // ditto joint marks.

    railedges(gauge_faces, outer_edges, centre_lines);      // restore his settings.

    //demo_on:=False;
    redraw(False);

    Cursor := mouse_action_cursor;
  end;//with


  if (cancelling_adjusts = True)
    // 0.94.a bug fix -- was "list index out of bounds" on next mouse_down if mouse wasn't moved first time.
    and (shove_timber_form.Showing = True)     // update enabled shove buttons..
    and ((shove_along_mod = 1) or (shove_throw_mod = 1) or (shove_crab_mod = 1) or
    (shove_length_mod = 1) or (shove_width_mod = 1) or (shove_twist_mod = 1)) then begin
    shove_index := find_shove(current_shove_str, False);
    shove_buttons(True, shove_index);
  end;

  if (shift_mod = 1) and (cancelling_adjusts = False) then
    snap_onto_bgnd_pegs;                     // F7 shift mouse action   0.79.a  27-05-06

end;
//___________________________________________________________________________________________

procedure pad_mouse_down(mouse_button: TMouseButton; shift_state: TShiftState; X, Y: integer);

// now never come here if middle button 0.91.c

var
  dummy1, dummy2, dummy3: double;
  xc0, yc0, xc9, yc9: double;
  mode, zoom_mode: integer;
  menu_caption_str: string;
  fb_str: string;   // 0.95.a

  popup_loc_left, popup_loc_right, screen_poploc: TPoint; // 0.91.b

  ////////////////////////////////////////////////////////////

  procedure set_opp;

  var
    kopp: double;   // 0.93.a mods

  begin
    //if ( (kform<(0-Pi/2)) or (kform>(Pi/2)) ) and (auto_dir=True)  // turnout facing opposite way ?

    kopp := ABS(kform);                 // 0 to 360          // 0.93.a mods
    if kopp > Pi then
      kopp := kopp - Pi * 2;  // -180 to +180
    kopp := ABS(kopp);                  // 0 to 180

    if (kopp > (Pi / 2)) and (auto_dir = True)
    // 90 to 180 turnout facing opposite way ?
    then begin
      opposite_way := True;
      X := pad_form.ClientWidth - X;    // reverse sense of mouse action.
      Y := pad_form.ClientHeight - Y;
      if X = 0 then
        X := 1;             // prevent divisions by zero later (screen-edge clicked).
      if Y = 0 then
        Y := 1;
    end
    else
      opposite_way := False;
  end;
  ////////////////////////////////////////////////////////////

  procedure extend_if_zero;  // 0.93.a

  begin
    if turnoutx = 0 then begin  // 0.93.a extend it

      turnoutx := 132 * scale;     // arbitrary new length 2 chains.
      turnout_i := 1;            // length locked at turnoutx.
      if plain_track = True then
        xorg := turnoutx
      else
        xorg := 0;
      startx := 0;
    end;
  end;
  ////////////////////////////////////////////////////////////

begin
  //timb_num_click_X:=$7FFFFFFF;      // (for shove timbers) init off-screen defaults..
  //timb_num_click_Y:=$7FFFFFFF;

  allow_left_button_pan := False;   // 0.91.c  init.

  prev_pad_click_X := pad_click_X;  // save the previous clicked position.
  prev_pad_click_Y := pad_click_Y;

  pad_click_X := X;                 // and this one, used for mouse_action grab, shove timbers.
  pad_click_Y := Y;                 // (and bgnd shapes - in bgnd_unit)
  // (X,Y may be changed for opposite way).

  // 207a now modal if data_entry_form.Visible=True then EXIT;


  if shift_state = [ssAlt, ssLeft]     // left click with ALT key.   0.71.b 2-6-01
  then begin
    jotter_dx_org := mouse_now_x;       // zero the relative X,Y readout.
    jotter_dy_org := mouse_now_y;       // zero the relative X,Y readout.


    if Screen.Cursor <> crNone then
      jotter_form.jotter_rel_xy_readout_panel.Caption :=
        ''                    // wait for redraw to refill it.
    else
      jotter_form.jotter_rel_xy_readout_panel.Caption := ' ( mouse action )';
    if show_ruler_tool = True then begin
      ruler_startx := mouse_now_x;
      ruler_starty := mouse_now_y;
      redraw_pad(True, False);
    end;
    EXIT;
  end;

  if (shift_state = [ssAlt, ssRight]) and (show_ruler_tool = True)
  // right click with ALT key. mod 0.78.a  18-11-02
  then begin
    ruler_endx := mouse_now_x;
    ruler_endy := mouse_now_y;
    redraw_pad(True, False);
    EXIT;
  end;

  if (shift_state = [ssAlt, ssMiddle]) or (shift_state = [ssAlt, ssCtrl, ssLeft])
  // middle click (or Ctrl-left) with ALT key.   0.71.b 2-6-01
  then begin
    with jotter_form do begin
      if (jotter_abs_xy_readout_panel.Visible = True) or
        (jotter_rel_xy_readout_panel.Visible = True) then begin
        jotter_memo.Lines.Add('');
        if jotter_abs_xy_readout_panel.Visible = True then
          jotter_memo.Lines.Add(jotter_abs_xy_readout_panel.Caption);
        if jotter_rel_xy_readout_panel.Visible = True then
          jotter_memo.Lines.Add(jotter_rel_xy_readout_panel.Caption);
      end;
    end;//with
    EXIT;
  end;

  if (shift_state = [ssAlt, ssCtrl, ssRight]) and (mouse_modify > -1)
  // right click with ALT key.   0.71.b 2-6-01
  then begin                                                    // mouse action in force.
    with jotter_form do begin
      jotter_memo.Lines.Add('');
      jotter_memo.Lines.Add(action_form.action_label.Caption);
      jotter_memo.Lines.Add(action_form.trail_dim_label.Caption);
    end;//with
    EXIT;
  end;

  if (mouse_draw_lines = True) and (mouse_button = mbLeft)
  // we are simply drawing with the mouse - save co-ords and exit.
  then begin
    draw_mouse_down_X := X;      // screen coords for line drawing start point.
    draw_mouse_down_Y := Y;

    temp_mouse_X := X;           // temp screen coords for mouse move drawing.
    temp_mouse_Y := Y;

    mouse_down_x := mouse_x(X);  // and in mm. for shape list
    mouse_down_y := mouse_y(X, Y);

    mouse_drawing_in_progress := True;
    EXIT;
  end;

  if (mouse_draw_lines = True) and (mouse_button = mbRight)
  // cancel mouse drawing on right button.
  then begin
    show_and_redraw(True, False);  // on idle, no rollback.
    EXIT;
  end;

  if (mouse_modify = -1)           // 291a     not if mouse action in force
    and (bgnd_form.Visible = True) and (zoom_rectangle = False) and
    (group_fence_rectangle = False) and (output_boundary_rectangle =
    False)  // 0.93.a  // he clicked shape corners.
    and (drawn_shape_rectangle = False)      // 214a
  then begin
    with pad_form.Canvas do begin
      Pen.Style := psSolid;
      Pen.Mode := pmCopy;
      Pen.Width := 1;
      Pen.Color := shapes_colour;

      MoveTo(X - 8, Y);     // mark the clicked target cross. (8 arbitrary).
      LineTo(X + 8, Y);
      MoveTo(X, Y - 8);
      LineTo(X, Y + 8);
    end;//with

    bgnd_no_update := True;
    // prevent an update to the shapes form on Activate (he might have already set the option boxes for this one).
    bgnd_form.Show;
    // he clicked pad for shape X,Y, so bring form back to the front.
    EXIT;
  end;

  if { 0.91.a (mouse_button=mbMiddle) or ( } shift_state = [ssCtrl, ssLeft] { ) } then begin
    if mouse_modify <> -1     // mouse action in force...
    then begin
      cancel_adjusts(False);
      EXIT;
    end
    else
      pad_form.select_centre_menu_entry.Click;
    // select pad centre on middle button or CTRL key held down.
  end;
  // so now we do...

  if (select_centre = True) and { 0.91.a (} (mouse_button = mbLeft)
  {or (mouse_button=mbMiddle) )}// selecting the pad centre...
  then begin
    select_centre := False;
    if draw_mode <> 2 then
      pad_form.lock_scaling_menu_entry.Click;

    zoom_offsetx := mouse_x(X) - screenx / 2;
    zoom_offsety := mouse_y(X, Y) - screeny / 2;

    cancel_adjusts(False);           // to reset the pad caption.
    do_rollback := False;       // no need to put this in rollback register on redraw.
    redraw(True);
    EXIT;
  end;
  select_centre := False;               // right click cancels select.

  // 0.91.a if mouse_button=mbMiddle then EXIT;       // shouldn't get here!

  if ((zoom_rectangle = True) or (group_fence_rectangle = True) or
    (output_boundary_rectangle = True) or (drawn_shape_rectangle = True)) and
    (mouse_button = mbLeft)
  // 0.93.a    // drawing with the mouse - save co-ords and exit.
  then begin
    draw_mouse_down_X := X;            // screen coords for first point.
    draw_mouse_down_Y := Y;
    rectangle_in_progress := True;
    rectangle_exists := False;         // nothing there yet for erasing.
    EXIT;
  end;

  //---------------------

  if clicks_accepted = True {name_highlighted<>-1}      // over a bgnd template name label?
  then begin
    clicks_accepted := False;                   // only one click.

    clicked_keep_index := hover_keep_index;     // save the list indices.
    //clicked_bgnd_index:=hover_bgnd_index;

    list_position := clicked_keep_index;  // make it current in the box.

    if (classic_templot = False) and (mouse_button = mbLeft) and (click_bgnd_select = False)
    // 0.93.a Quick mode left click on label
    then begin
      bgnd_clicked_in_quick_mode := True;
      pad_form.make_control_popup_entry.Click;
      bgnd_clicked_in_quick_mode := False;
      EXIT;
    end;

    if (click_bgnd_select = True) and (mouse_button = mbLeft)
    // bgnd keep to or from group selection list.
    then begin
      click_bgnd_to_selected;
      EXIT;
    end;


    if (shift_click = True) or (mouse_button = mbRight)
    // right click or either click if shift key was down when highlighted.
    then begin
      if (clicked_keep_index > -1) and (clicked_keep_index < keeps_list.Count) and
        (keeps_list.Count > 0) then begin

        with keeps_list[clicked_keep_index] do begin
          if (template_info.keep_dims.box_dims1.mod_text_x = 0) and
            (template_info.keep_dims.box_dims1.mod_text_y = 0) then
            pad_form.restore_label_popup_entry.Enabled := False
          else
            pad_form.restore_label_popup_entry.Enabled := True;

          pad_form.select_bg_popup_entry.Checked := group_selected;
        end;//with
      end;

      menu_caption_str :=
        UpperCase(Trim(keeps_list[clicked_keep_index].bgnd_keep.full_label_string));
      if Length(menu_caption_str) > 20 then
        menu_caption_str := Copy(menu_caption_str, 1, 18) + '...';  // 20 arbitrary.

      with keeps_list[clicked_keep_index].template_info.keep_dims.box_dims1 do begin

        pad_form.align_current_popup_entry.Enabled :=
          (ABS(proto_info.gauge_pi - g) < minfp);  // 205d disabled for mixed-gauge templates

        if rail_type = 2   // 0.95.a FB rail
        then
          fb_str := 'FB •  '
        else
          fb_str := 'BH •  ';

      end;//with


      pad_form.top_name_info_popup_entry.Caption := 'I    ' + fb_str + menu_caption_str;
      // 0.95.a

      pad_form.selection_popup.PopUp(popup_X, popup_Y);

      cancel_adjusts(False);       // update the pad caption. 13-1-00.
      do_rollback := False;
      redraw(False);
      // remove highlighting (must be False (immediate redraw) in case we want to re-highlight for label moving).
    end;
    EXIT;
  end;// clicks_accepted
  //--------------------------

  if mouse_button = mbRight                       //  right-click :
  then begin
    if popup_if_clicked(True) = False
    // go check if he clicked on a bgnd template and do pop-up.   // 0.93.a
    then begin

      // multiple monitors... 0.91.b

      popup_loc_left.X := pad_form.ClientWidth div 4;
      popup_loc_left.Y := pad_form.ClientHeight div 5;

      popup_loc_right.X := pad_form.ClientWidth div 2;
      popup_loc_right.Y := pad_form.ClientHeight div 5;

      if X < (pad_form.ClientWidth div 2) then
        screen_poploc := pad_form.ClientToScreen(popup_loc_right)
      else
        screen_poploc := pad_form.ClientToScreen(popup_loc_left);

      pad_form.pad_popup_menu.Popup(screen_poploc.X, screen_poploc.Y);
    end;

    mouse_action_release(False);   // (if any)
    EXIT;
  end;

  if mouse_modify = -1               // no mouse action selected.
  then begin
    if (shove_timber_form.Showing = True) and (hide_current_flag = False) then begin
      if shove_number_clicked(pad_click_X, pad_click_Y) = True then
        EXIT; // clicked on a timber number
    end;

    if (check_diffs_form.Showing = True) and (hide_current_flag = False)   // 0.94.a ...
    then begin
      if checkrail_label_clicked(pad_click_X, pad_click_Y) = True then
        EXIT; // clicked on a check-rail label
    end;


    if popup_if_clicked(False) = False
    // go check if he clicked on a bgnd template and do pop-up.
    then begin
      if pad_form.allow_left_drag_panning_menu_entry.Checked = True then begin
        allow_left_button_pan := True;  // 0.91.c
        Screen.Cursor := crSizeAll;     // 0.91.c

        zoff_now_x := X;  // 0.91.c   init pad move
        zoff_now_y := Y;
        zoom_offsetx_now := zoom_offsetx;
        zoom_offsety_now := zoom_offsety;
      end;
    end;
    //                    end;
    EXIT;
  end;

  // MOUSE ACTIONS BEGIN HERE:-

  if ABS(fx) < minfp then
    EXIT;                 // no proper screen calcs done ??
  if ABS(fy) < minfp then
    EXIT;

  with pad_form do begin     // (for the Cursor)

    if X = 0 then
      X := 1;          // prevent divisions by zero later (screen-edge clicked).
    if Y = 0 then
      Y := 1;

    // mods Jan 2000 - for use with button-down mouse actions, we now set the Screen cursor instead of the form cursor (form cursor won't change while the button is down (???) ).

    Screen.Cursor := crDefault;     //  needed in case clicks get out of sync.

    if mouse_modify = 0                          // will be changed.
    then begin
      action_form.action_2_image.Show;
      action_form.image_panel.Color := clMaroon;
      allow_idle := control_room_form.allow_full_idle_menu_entry.Checked;
      // mouse action or always, disallow idle.
    end
    else begin
      action_form.action_2_image.Hide;
      action_form.image_panel.Color := clGray;
      allow_idle := not control_room_form.fast_100_menu_entry.Checked;
      // no mouse action - allow idle again.
    end;


    //if off_screen=True then begin

    mode := 7;
    zoom_mode := 9;

    (* out 0.93.a
                          end
                     else begin
                            { out v:0.68.a  9-3-01/
                            if bgkeeps_form.bgkeeps_listbox.Items.Count<mode_swap

                               then mode:=1      // (might be changed to 3 below.)
                               else}
                            mode:=3;
                            zoom_mode:=5;
                          end;
*)

    if both_mod = 1 then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        if opposite_way = True then
          Screen.Cursor := adjust_corners_cursor_invert     //crSizeNWSE
        else
          Screen.Cursor := adjust_corners_cursor_invert;

        //  Delphi cursor bug - crSize not working (NT only?).

        mouse_modify := 1;
        if draw_mode <> 2 then
          mode := zoom_mode;    // free-scaling - change mode.
      end
      else
        mouse_modify := 0;

      xing_now := X;
      k3n_now := k3n;
      curving_now := Y;

      nomrad_now := max_rad;    // keep compiler happy.

      if spiral = False then
        nomrad_now := nomrad
      else begin                        // transition.
        case adjust_trans_rad of
          1:
            nomrad_now := nomrad1;
          2:
            nomrad_now := nomrad2;
          else
            run_error(198);
        end;//case
      end;

      if ABS(nomrad_now) > minfp then
        curvature_now := 1 / nomrad_now
      else
        curvature_now := 1 / minfp;

      kform_now := kform;
      arm_angle_now := arm_angle;
      pegangle_now := pegangle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;

    if sx_mod = 1 then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;    //crSizeWE;
        mouse_modify := 2;
        if draw_mode <> 2 then
          mode := zoom_mode;      // free-scaling - change mode.
      end
      else
        mouse_modify := 0;

      xing_now := X;
      k3n_now := k3n;

      kform_now := kform;
      arm_angle_now := arm_angle;
      pegangle_now := pegangle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;

    if curving_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_ns_cursor_invert;   // custom_cursor.
        mouse_modify := 3;                          //  toggle the re-draw flag on.
        //no_mouse_move:=0;                       //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                 //  then toggle re-draw off.
      end;

      curving_now := Y;
      nomrad_now := max_rad;    // keep compiler happy.

      if spiral = False               // no transition.
      then begin
        nomrad_now := nomrad;

        if (f6_swing_fixed = True) and (ABS(nomrad) > minfp)
        // 0.91.b      // constant radius only.
        then begin
          if nomrad = max_rad then
            f6_swing_angle := ARCTAN(1 / 7)
          // 1:7 RAM default 0.93.a was Pi/18 10 degs default for a straight starting template
          else
            f6_swing_angle := ABS(turnoutx / nomrad);     // nomrad may be negative.
        end
        else
          f6_swing_angle := 0;                                  // not used.
      end
      else begin                // transition.
        case adjust_trans_rad of
          1:
            nomrad_now := nomrad1;
          2:
            nomrad_now := nomrad2;
          else
            run_error(198);
        end;//case
      end;

      if ABS(nomrad_now) > minfp then
        curvature_now := 1 / nomrad_now
      else
        curvature_now := 1 / minfp;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;

    if length_mod = 1 then begin
      //popup_click:=False;     // mouse action click.

      set_opp;
      if mouse_modify = 0 then begin
        extend_if_zero;  // 0.93.a

        Screen.Cursor := adjust_we_cursor_invert; // crSizeWE;
        mouse_modify := 4;                        // toggle the re-draw flag on.
        //no_mouse_move:=0;                     // permit mouse moves to do adjusts.
        if draw_mode <> 2 then
          mode := zoom_mode;   // free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   // then toggle re-draw off.
      end;
      length_now := X;
      endx_now := turnoutx;

      pegx_now := pegx;
      udpegx_now := udpegx;

      os_now := os;
      slew_s_now := slew_s;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
      if peg_code = 600 then
        dummy1 := aq25offset(pegx, now_peg600);
      // peg on TOLP, save current pegangle for curviform V-crossing. 0.79.a
    end;

    if shift_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_ne_cursor_invert;//crDrag;
        mouse_modify := 5;                 //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shift_now_x := X;
      shift_now_y := Y;
      xshift_now := xshift;
      yshift_now := yshift;
    end;

    if twist_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_ns_cursor_invert;//crSizeNS;
        mouse_modify := 6;                 //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.

        init_rotate(pegx, pegy, False);  // set up transform constants.

        // save clicked position...
        shift_now_y := Y;
        kform_now := kform;          // and current angle.

        if X < pad_pegx then
          twist_dir := -1      // rotation direction depends which side of peg he clicked.
        else
          twist_dir := 1;

      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
    end;

    if zoom_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crHSplit;
        mouse_modify := 7;                 //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      zoom_now := X;                     // save clicked position.
      screenx_zoom_now := screenx;
      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if approach_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        startx := 0;
        // cancel any blanking (we waited until mouse down in case F3 was in error).

        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 8;                            //  toggle the re-draw flag on.
        //no_mouse_move:=0;                        //  permit mouse moves to do adjusts.
        if draw_mode <> 2 then
          mode := zoom_mode;    // free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      approach_now := X;
      xorg_now := xorg;
      turnoutx_now := turnoutx;

      pegx_now := pegx;
      udpegx_now := udpegx;

      os_now := os;
      slew_s_now := slew_s;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;

    if datum_mod = 1                             // move Y datum
    then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crVSplit;
        mouse_modify := 9;                 //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        mode := zoom_mode;              // free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      datum_now := Y;                     // save clicked position.
      y_datum_now := y_datum;
    end;

    if trans_length_mod = 1                  // SHIFT+CTRL-F4 adjust transition length
    then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crHSplit;
        mouse_modify := 10;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      trans_length_now := X;                     // save clicked position.
      tst_now := tst;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.

    end;

    if zoffset_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := cross_size_cursor;//crDrag;
        mouse_modify := 11;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        mode := zoom_mode;              // free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      zoff_now_x := X;
      zoff_now_y := Y;
      zoom_offsetx_now := zoom_offsetx;
      zoom_offsety_now := zoom_offsety;
      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if spot_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crVSplit;
        mouse_modify := 12;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      spot_now := pad_form.ClientHeight - Y;
      // save clicked position. (neg so that up screen zooms in.)
      screenx_spot_now := screenx;
      zoom_offsetx_now := zoom_offsetx;
      zoom_offsety_now := zoom_offsety;

      zoom_now := X;
      // save clicked X position for additional scale zooming if wanted.
      do_rollback := False;       // no need to put this change in rollback register on redraw.
    end;

    if peg_mod = 1 then begin
      //popup_click:=False;           // mouse action click.
      extend_if_zero;  // 0.93.a
      if peg_rail <> 0 then
        set_opp;    //  do opposite way if running peg along rails.
      if mouse_modify = 0 then begin
        if peg_rail = 0 then
          Screen.Cursor := crNone     //  free move.
        else
          Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;  //  along rails.
        mouse_modify := 13;                        //  toggle the re-draw flag on.
        //no_mouse_move:=0;                     //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      peg_now_x := X;
      peg_now_y := Y;
      pegx_now := pegx;
      pegy_now := pegy;

      docurving(False, True, pegx, pegy, dummy1, dummy2, now_peg_k, dummy3);
      // save current peg curving angle.

    end;

    if orbit_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 14;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.

        if spiral = False then begin
          orbit_rad := clrad1;
          init_rotate(xt1, yt1, True);
          // set up transform constants (rad centre).
        end
        else
          case adjust_trans_rad of
            1: begin
              init_rotate(xt1, yt1, True);
              orbit_rad := clrad1;
            end;
            2: begin
              init_rotate(xt2, yt2, True);
              orbit_rad := clrad2;
            end;
            else begin
              init_rotate(xt1, yt1, True);
              orbit_rad := clrad1;
            end;
          end;//case

        shift_now_x := X;            // save clicked position.
        kform_now := kform;          // and current angle.

        if Y > rad_centy then
          orbit_dir := hand_i * SGZ(orbit_rad)        // set orbit direction.
        else
          orbit_dir := 0 - hand_i * SGZ(orbit_rad);
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
    end;

    if notch_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crNone;
        mouse_modify := 15;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        if mode = 1 then
          mode := 3;       // otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      notch_now_x := X;
      notch_now_y := Y;
      notchx_now := notchx;
      notchy_now := notchy;
      do_rollback := False;      // no need to put this change in rollback register on redraw.
    end;

    if trans_start_mod = 1                  // SHIFT+CTRL-F3 adjust transition start
    then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crHSplit;
        mouse_modify := 16;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      trans_start_now := X;                     // save clicked position.
      os_now := os;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.

    end;

    if shift_keeps_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crMultiDrag;
        mouse_modify := 17;              //  toggle the re-draw flag on.
        //no_mouse_move:=0;            //  permit mouse moves to do adjusts.
        if mode = 1 then
          mode := 3;        //  otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shift_now_x := X;
      shift_now_y := Y;
      xshift_now := xshift_keeps;
      yshift_now := yshift_keeps;
    end;

    if twist_keeps_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 18;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        if mode = 1 then
          mode := 3;       //  otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      // save clicked position...
      shift_now_y := Y;
      kform_now := kform_keeps;          // and current angle.

      if X > (notchx * fx + ex - gx) then
        twist_dir := -1      // rotation direction depends which side of the notch he clicked.
      else
        twist_dir := 1;

    end;

    if ring_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crNone;
        mouse_modify := 19;                //  toggle the re-draw flag on.
        if mode = 1 then
          mode := 3;          //  otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      ring_now_x := X;
      ring_now_y := Y;
      xring_now := rings[0, 0];
      yring_now := rings[0, 1];
    end;

    if slide_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 20;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      peg_now_x := X;
      pegx_now := pegx;
      pegangle_now := pegangle;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.

    end;

    if slew_start_mod = 1          // SHIFT+CTRL-F5 adjust slewing start
    then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crHSplit;
        mouse_modify := 21;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      slew_start_now := X;                     // save clicked position.
      slew_s_now := slew_s;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.
    end;

    if slew_length_mod = 1                  // SHIFT+CTRL-F6 adjust slewing length
    then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crHSplit;
        mouse_modify := 22;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      slew_length_now := X;                     // save clicked position.
      slew_l_now := slew_l;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.

    end;

    if slew_amount_mod = 1               // CTRL-F7 adjust amount of slew.
    then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_ns_cursor_invert;//crVSplit;
        mouse_modify := 23;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      slew_amount_now := Y;                     // save clicked position.
      slew_now := slew;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.
    end;

    if out_factor_mod = 1 then begin
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 24;             //  toggle the re-draw flag on.
        mode := zoom_mode;              //  outlines are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;              //  then toggle re-draw off.
      end;

      printsize_now_X := X;
      out_factor_now := out_factor;
    end;

    if shove_along_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 25;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shove_now_x := X;
      shovex_now := shovex;

      shovetimb_now := X;
      shovetimbx_now := shovetimbx;
    end;

    if shove_throw_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 26;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shove_now_y := Y;
      shoveo_now := shoveo;
    end;

    if roam_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        startx := 0;
        // cancel any blanking (we waited until mouse down in case CTRL-F9 was in error).

        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 27;                           //  toggle the re-draw flag on.
        //no_mouse_move:=0;                        //  permit mouse moves to do adjusts.
        if draw_mode <> 2 then
          mode := zoom_mode;    // free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      roam_now := X;
      xorg_now := xorg;

      pegx_now := pegx;
      udpegx_now := udpegx;

    end;

    if slew_factor_mod = 1               // adjust mode 2 slew factor.
    then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crHSplit;
        mouse_modify := 28;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      slew_factor_now := X;                       // save clicked position.
      slew2_kmax_now := slew2_kmax;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.
    end;

    if bunch_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNWSE;
        mouse_modify := 29;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      bunch_now := X;
      bunching_jump_now := bunching_jump;

      shear_now := Y;
      bunching_shear_now := bunching_shear;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if porg_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crMultiDrag;
        mouse_modify := 30;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  outlines are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      porg_now_x := X;
      porg_now_y := Y;
      print_pages_top_origin_now := print_pages_top_origin;
      print_pages_left_origin_now := print_pages_left_origin;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if corner1_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crDrag;
        mouse_modify := 31;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  shapes are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      shapes_now_x := X;
      shapes_now_y := Y;

      shapes_shiftx_now := 0;
      shapes_shifty_now := 0;

      shifted_already_x := 0;
      shifted_already_y := 0;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if corner2_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crDrag;
        mouse_modify := 32;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  shapes are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      shapes_now_x := X;
      shapes_now_y := Y;

      shapes_shiftx_now := 0;
      shapes_shifty_now := 0;

      shifted_already_x := 0;
      shifted_already_y := 0;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if oneshape_shift_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crDrag;
        mouse_modify := 33;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  shapes are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shapes_now_x := X;
      shapes_now_y := Y;

      shapes_shiftx_now := 0;
      shapes_shifty_now := 0;

      shifted_already_x := 0;
      shifted_already_y := 0;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if allshapes_shift_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crMultiDrag;
        mouse_modify := 34;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  shapes are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      shapes_now_x := X;
      shapes_now_y := Y;

      shapes_shiftx_now := 0;
      shapes_shifty_now := 0;

      shifted_already_x := 0;
      shifted_already_y := 0;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if snake_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 35;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      peg_now_x := X;
      pegx_now := pegx;
      pegangle_now := pegangle;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg data for peg_curve calcs.

      if spiral = True then
        os_now := os;                  // need transition and slewing starts.
      if slewing = True then
        slew_s_now := slew_s;
    end;


    if allshapes_scale_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 36;             //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  shapes are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      shapes_now_y := Y;
      //shapes_scalefactor_now:=1.0;
      shapes_scaled_already := 1.0;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if allshapes_rotate_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 37;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  shapes are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      shapes_now_y := Y;
      shapes_rot_now := 0;
      shapes_rotated_already := 0;

      if X < (rings[0, 0] * fx + ex - gx) then
        twist_dir :=
          -1   // rotation direction depends which side of the current spacing ring was clicked.
      else
        twist_dir := 1;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if oneshape_scale_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 38;             //  toggle the re-draw flag on.
        //no_mouse_move:=0;           //  permit mouse moves to do adjusts.
        mode := zoom_mode;              //  shapes are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      shapes_now_x := X;
      shapes_scaled_already := 1.0;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if shove_length_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 39;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shove_now_y := Y;
      shovel_now := shovel;
    end;

    if shove_width_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 40;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shove_now_x := X;
      shovew_now := shovew;
    end;

    if shove_twist_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 41;                //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shove_now_y := Y;
      shovek_now := shovek;
    end;

    if blanking_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 42;                      //  toggle the re-draw flag on.
        //no_mouse_move:=0;                        //  permit mouse moves to do adjusts.
        //if draw_mode<>2 then mode:=zoom_mode;    // free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      blanking_now := X;
      startx_now := startx;
    end;

    if roll_mod = 1 then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 43;                          //  toggle the re-draw flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      roll_now := X;
      tb_roll_percent_now := tb_roll_percent;
    end;

    if ringdia_mod = 1                             // adjust ring dia.
    then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crVSplit;
        mouse_modify := 44;             //  toggle the re-draw flag on.
        if mode = 1 then
          mode := 3;       //  otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      ringdia_now_y := Y;                     // save clicked position.
      ring_dia_now := ring_dia;
    end;

    if ruler1_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crDrag;
        mouse_modify := 45;                //  toggle the re-draw flag on.
        if mode = 1 then
          mode := 3;          //  otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      ruler1_now_x := X;
      ruler1_now_y := Y;
      ruler_startx_now := ruler_startx;
      ruler_starty_now := ruler_starty;
    end;

    if ruler2_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crDrag;
        mouse_modify := 46;                //  toggle the re-draw flag on.
        if mode = 1 then
          mode := 3;          //  otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      ruler2_now_x := X;
      ruler2_now_y := Y;
      ruler_endx_now := ruler_endx;
      ruler_endy_now := ruler_endy;
    end;

    if swell_mod = 1 then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_ns_cursor_invert;   // custom_cursor.
        mouse_modify := 47;                         //  toggle the re-draw flag on.
        init_rotate(0, g / 2, False);
        // set up transform constants (for template datum).
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                 //  then toggle re-draw off.
      end;

      curving_now := Y;            // save clicked position...
      kform_now := kform;          // and current angle.
      turnoutx_now := turnoutx;
      nomrad_now := nomrad;
      if ABS(nomrad_now) > minfp then
        curvature_now := 1 / nomrad_now
      else
        curvature_now := 1 / minfp;

      docurving(True, True, 0, g / 2, xc0, yc0, dummy1, dummy2);
      docurving(True, True, turnoutx, g / 2, xc9, yc9, dummy1, dummy2);
      ends_apart_now := SQRT(SQR(xc9 - xc0) + SQR(yc9 - yc0));           // chord length.
    end;

    if shove_crab_mod = 1 then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 48;               //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      shove_now_x := X;
      shovec_now := shovec;
    end;

    if move_labels_mod = 1    // 0.82.d
    then begin
      //popup_click:=False;     // mouse action click.
      if mouse_modify = 0 then begin
        Screen.Cursor := crMultiDrag;
        mouse_modify := 49;               //  toggle the re-draw flag on.
        //no_mouse_move:=0;             //  permit mouse moves to do adjusts.
        if mode = 1 then
          mode := 3;         //  otherwise doesn't erase on pad.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;
      labels_now_x := X;
      labels_now_y := Y;
      xlabels_now := xshift_labels;
      ylabels_now := yshift_labels;
    end;

    // 0.93.a mouse_modify matches repeat_last_index for 50+ (see 99) ...

    if plat_ts_start_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 50;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ts_start_now_X := X;
      platform_ts_start_mm_now := platform_ts_start_mm;
    end;


    if plat_ts_length_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 51;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ts_length_now_X := X;
      platform_ts_length_mm_now := platform_ts_length_mm;
    end;


    if plat_ts_width1_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 52;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ts_start_width_now_Y := Y;
      platform_ts_start_width_ins_now := platform_ts_start_width_ins;
    end;


    if plat_ts_width2_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 53;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ts_end_width_now_Y := Y;
      platform_ts_end_width_ins_now := platform_ts_end_width_ins;
    end;


    if plat_ms_start_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 54;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ms_start_now_X := X;
      platform_ms_start_mm_now := platform_ms_start_mm;
    end;


    if plat_ms_length_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 55;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ms_length_now_X := X;
      platform_ms_length_mm_now := platform_ms_length_mm;
    end;


    if plat_ms_width1_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 56;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ms_start_width_now_Y := Y;
      platform_ms_start_width_ins_now := platform_ms_start_width_ins;
    end;


    if plat_ms_width2_mod = 1       // 0.93.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 57;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ms_end_width_now_Y := Y;
      platform_ms_end_width_ins_now := platform_ms_end_width_ins;
    end;


    if gaunt_offset_mod = 1  // SHIFT+F12
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 58;               //  toggle the re-draw flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      gaunt_now := Y;
      gaunt_offset_now_mm := gaunt_offset_in * inscale;

      kform_now := kform;
      arm_angle_now := arm_angle;
      pegangle_now := pegangle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;


    if vee_mod = 1      // F9
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;    //crSizeWE;
        mouse_modify := 59;
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      veexing_now := X;
      vee_now := k3n;

      kform_now := kform;
      arm_angle_now := arm_angle;
      pegangle_now := pegangle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;


    if hdk_mod = 1    // F10
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;    //crSizeWE;
        mouse_modify := 60;
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      hdxing_now := X;
      hdkn_now := hdkn;

      kform_now := kform;
      arm_angle_now := arm_angle;
      pegangle_now := pegangle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;


    if rect_left_mod = 1 then begin
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 61;
        mode := zoom_mode;     //  outlines are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      rect_now_X := X;
      output_rectangle_x_now := output_rectangle_x1;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if rect_right_mod = 1 then begin
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 62;
        mode := zoom_mode;     //  outlines are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      rect_now_X := X;
      output_rectangle_x_now := output_rectangle_x2;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if rect_top_mod = 1 then begin
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 63;
        mode := zoom_mode;     //  outlines are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      rect_now_Y := Y;
      output_rectangle_y_now := output_rectangle_y2;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if rect_bottom_mod = 1 then begin
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 64;
        mode := zoom_mode;     //  outlines are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      rect_now_Y := Y;
      output_rectangle_y_now := output_rectangle_y1;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if rect_move_mod = 1 then begin
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeAll;
        mouse_modify := 65;
        mode := zoom_mode;     //  outlines are on the backdrop.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      rect_now_X := X;
      rect_now_Y := Y;
      output_rectangle_x_now := output_rectangle_x1;
      output_rectangle_y_now := output_rectangle_y1;

      do_rollback := False;
      // no need to put this change in rollback register on redraw.
    end;

    if check_diffs_len_mod = 1     // 0.94.a
    then begin
      extend_if_zero;    // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;   // custom_cursor.  crSizeWE;
        mouse_modify := 66;
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      mouse_diffs_now_X := X;
      mouse_diffs_now_Y := Y;

      mouse_check_len_mm_now := mouse_diff.len_diff * inscale;

      case current_diff_code of
        eMC_501_MSWorkingEnd,
        eMC_504_TSWorkingEnd:
          diff_dir := 0 - 1;  // +/-1 mouse diffing direction
        else
          diff_dir := 1;
      end;//case

      min_diff := (current_diffed_fl_len - current_diffed_len) / inscale + mouse_diff.len_diff;
      // minimum negative diff

      if current_diff_code = eMC_504_TSWorkingEnd then
        min_diff := min_diff + cktsmid_offset / inscale;  // TS1 stop at F.P.
    end;

    if check_diffs_flare_mod = 1   // 0.94.a
    then begin
      extend_if_zero;    // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 67;
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      mouse_diffs_now_X := X;
      mouse_diffs_now_Y := Y;

      mouse_check_flare_mm_now := mouse_diff.flr_diff * inscale;

      case current_diff_code of
        eMC_501_MSWorkingEnd,
        eMC_504_TSWorkingEnd:
          diff_dir := 1;  // +/-1 mouse diffing direction
        else
          diff_dir := 0 - 1;
      end;//case

      case current_diff_code of
        // !!!  k_flare_len is f-s ins,   xing_flare_len is model mm     *2.5 arbitrary, max flare angle 1:2.5
        eMC_507_MSKCheckRail,
        eMC_508_DSWingRail: begin
          min_diff := (current_diffed_end_gap - fw) * 2.5 / inscale - k_flare_len;
          // minimum negative diff, K-crossing
          max_diff := current_diffed_len / inscale - k_flare_len;
          // maximum positive diff, K-crossing
        end;

        else begin
          // V-crossing
          min_diff := ((current_diffed_end_gap - fw) * 2.5 - xing_flare_len) / inscale;
          // minimum negative diff
          max_diff := (current_diffed_len - xing_flare_len) / inscale;
          // maximum positive diff

          if current_diff_code = eMC_504_TSWorkingEnd then
            max_diff := max_diff - cktsmid_offset / inscale;  // TS1 stop at F.P.

        end;
      end;//case
    end;

    if check_diffs_gap_mod = 1     // 0.94.a
    then begin
      extend_if_zero;    // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 68;
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;
      end;

      mouse_diffs_now_X := X;
      mouse_diffs_now_Y := Y;

      mouse_check_gap_mm_now := mouse_diff.gap_diff;

      case current_diff_code of
        eMC_501_MSWorkingEnd,
        eMC_502_MSExtensionEnd,
        eMC_506_TSWingRail,
        eMC_507_MSKCheckRail:
          diff_dir := 1 * hand_i;      // +/-1 mouse diffing direction
        else
          diff_dir := 0 - 1 * hand_i;
      end;//case

      min_diff := fw - fw_end;  // bend-out can't go negative.
      max_diff := g / 2 - fw_end; // or more than 1/2 track gauge

      if max_diff > current_diffed_fl_len / 2.5 + fw - fw_end then
        max_diff := current_diffed_fl_len / 2.5 + fw - fw_end;
      // 2.5 arbitrary, max flare angle 1:2.5
    end;

    if dv_mod = 1     // 0.98.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;//crSizeWE;
        mouse_modify := 69;                      //  toggle the re-draw flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      dv_now := X;
      dv_start_now := cdvi.dv_start;

      dv_copy_start_now := dv_start_now;  // 215c
    end;

    if dv_clear_mod = 1     // 0.98.a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 70;                  //  toggle the re-draw flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      dv_clear_now := Y;
      dv_clearance_now := cdvi.dv_clearance;
    end;

    // 207a ...

    if plat_ms_skew1_mod = 1 then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 71;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ms_start_skew_now_X := X;
      platform_ms_start_skew_mm_now := platform_ms_start_skew_mm;
    end;

    if plat_ms_skew2_mod = 1 then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 72;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ms_end_skew_now_X := X;
      platform_ms_end_skew_mm_now := platform_ms_end_skew_mm;
    end;


    if plat_ts_skew1_mod = 1 then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 73;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ts_start_skew_now_X := X;
      platform_ts_start_skew_mm_now := platform_ts_start_skew_mm;
    end;

    if plat_ts_skew2_mod = 1 then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 74;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      platform_ts_end_skew_now_X := X;
      platform_ts_end_skew_mm_now := platform_ts_end_skew_mm;
    end;

    if turnout_road_mod = 1   // 209a  CTRL+F12
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert; //crSizeWE;
        mouse_modify := 75;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then toggle off.
      end;

      turnout_road_now_X := X;
      turnout_road_endx_now := turnout_road_endx;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
      if peg_code = 241 then
        dummy1 := aq25offset(pegx, now_peg600);
      // peg on TEXITP, save current pegangle for curviform V-crossing. 0.79.a

    end;

    if adjacent_ts_mod = 1    // 213a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 76;                  //  toggle the re-draw flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      ts_adj_now := Y;
      trtscent_pi_now := cpi.trtscent_pi;
    end;

    if adjacent_ms_mod = 1    // 213a
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 77;                  //  toggle the re-draw flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      ms_adj_now := Y;
      trmscent_pi_now := cpi.trmscent_pi;
    end;


    if edge_ts_start_mod = 1       // 215a      trackbed edges ...
    then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 78;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      trackbed_ts_start_now_X := X;
      trackbed_ts_start_mm_now := trackbed_ts_start_mm;
    end;


    if edge_ts_length_mod = 1       // 215a
    then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 79;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      trackbed_ts_length_now_X := X;
      trackbed_ts_length_mm_now := trackbed_ts_length_mm;
    end;

    if edge_ms_start_mod = 1       // 215a
    then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 80;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      trackbed_ms_start_now_X := X;
      trackbed_ms_start_mm_now := trackbed_ms_start_mm;
    end;


    if edge_ms_length_mod = 1       // 215a
    then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeWE;
        mouse_modify := 81;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then off.
      end;

      trackbed_ms_length_now_X := X;
      trackbed_ms_length_mm_now := trackbed_ms_length_mm;
    end;

    if main_road_mod = 1   // 217a
    then begin
      extend_if_zero;
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;
        mouse_modify := 82;                       //  toggle flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                        //  then toggle off.
      end;

      main_road_now_X := X;
      main_road_endx_now := main_road_endx;

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
      if peg_code = 241 then
        dummy1 := aq25offset(pegx, now_peg600);
      // peg on TEXITP, save current pegangle for curviform V-crossing. 0.79.a

    end;

    if gaunt_radius_mod = 1  // 217b
    then begin
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := crSizeNS;
        mouse_modify := 83;               //  toggle the re-draw flag on.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      gaunt_rad_now := Y;
      gaunt_curvature_now := gaunt_curvature;

      kform_now := kform;
      arm_angle_now := arm_angle;
      pegangle_now := pegangle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad and curving angle.
    end;


    //----
    // 99 ...

    if entry_straight_mod = 1    // 0.91.b
    then begin
      //popup_click:=False;     // mouse action click.
      extend_if_zero;  // 0.93.a
      set_opp;
      if mouse_modify = 0 then begin
        Screen.Cursor := adjust_we_cursor_invert;    //crSizeWE;
        mouse_modify := 99;
        //  99 0.93.a (was 50) toggle the re-draw flag on.
        //no_mouse_move:=0;                        //  permit mouse moves to do adjusts.
        //if draw_mode<>2 then mode:=zoom_mode;    // free-scaling - change mode.
      end
      else begin
        Screen.Cursor := crDefault;
        mouse_modify := 0;                   //  then toggle re-draw off.
      end;

      entry_straight_now := X;
      fixed_sl_now := fixed_sl;

      //min_sl_offset:=h+scale/4;   // ensure it will fit beyond switch heel.
      // 3" clearance arbitrary.

      min_sl_offset := MAX((g / 5), (h + scale / 4));     // 213a

      min_sl := ABS(fw * k3n);      // 214a  not used            and CESP not beyond knuckle.

      kform_now := kform;
      //arm_angle_now:=arm_angle;
      //pegangle_now:=pegangle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
      // save current peg position on pad.

    end;


    //------------
  end;//with form

  if mouse_modify = 0 then begin
    if mouse_action_button_down = False then
      mouse_action_release(False);   // second click.
  end
  else
    mouse_action_grab(mode, pad_click_X, pad_click_Y);
  // (need actual, not as swapped for opposite way).

end;
//___________________________________________________________________________________________

function ask_impact_matrix(prindex: integer; prstr: string): boolean;
  // ask if printer is dot-matrix impact type.
  // return TRUE if valid answer.
const

  TECHNOLOGY = 2;

  impact_str: string = '     Impact  Printer ?' +
    '||Are you are using an older-pattern dot-matrix or other impact printer (i.e. one using an ink ribbon like a typewriter and capable of printing carbon copies) ?' + '|----------------------------------------------' + '|If you click YES Templot0 will simplify some of the output to reduce wear and tear on the print-head (and also the noise).' + ' This is strongly recommended when calibrating the printer.' + '||All line thicknesses (line widths) will be set to 1 dot, regardless of any other settings you may have made for them.' + '||Also click YES if this is a pen-plotter, but the fact that you are seeing this message implies something amiss in the plotter driver, as Windows has failed' + ' to inform Templot0 that this printer is a plotter.' + '|----------------------------------------------' + '|Click NO or just press ENTER if this printer is an ink-jet or laser-printer, or other modern printer capable of printing filled areas, or a virtual printer such as a Fax sender.' + '||Also click NO if you are not sure.' + '||If you click CANCEL, Templot0 will the assume that the answer is NO for the purpose of printing templates, but you will be unable to calibrate your printer for maximum accuracy.' + '||( Hopefully, the next version of Templot0 will have devised a means of answering this question for itself.)';

var
  impact: integer;
  i: integer;

begin
  { OT-FIRST
  RESULT:=False;                                         // init error returns...
  impact:=-1;

  if GetDeviceCaps(Printer.Handle,TECHNOLOGY)=DT_PLOTTER
     then begin
            impact:=2;                // its a pen plotter.
            RESULT:=True;             // so yes also.
          end
     else begin

            repeat
              i:=alert(4,'      impact  printer  ? ...',
                         'The current printer is  '+prstr
                        +'||Is this printer an old style dot-matix or other impact printer (using an ink ribbon) ?',
                         '','','?  help','yes    -    impact  printer   /   pen - plotter','cancel','no    -    ink - jet   /   laser   /   virtual   printer    ',3);
              case i of
                  3: alert_help(0,impact_str,'');
                  4: begin
                       impact:=1;              // save the yes answer for this printer,
                       RESULT:=True;
                     end;
                  6: begin}
  impact := 0;              // save the no answer for this printer.
  Result := True;
  { OT-FIRST
                     end;
              end;//case
            until i>3;
          end;}

  Tprint_cal(printer_list.Objects[prindex]).cal_data.printer_impact := impact;
end;
//___________________________________________________________________________________________

procedure printer_setup(cal_in_progress, black_white_setup: boolean);

const
  BITSPIXEL = 12;
  PLANES = 14;

  print_col_help_str: string =
    '||Templot0 has determined that this printer is capable of printing in colour, but you are currently'
    + ' printing in black and white.' +
    '||Changing to colour printing here affects only Templot0''s internal settings. To actually print in colour'
    +
    ' you must have the correct ink cartridge installed and make the necessary settings on the printer'
    + ' setup dialog window. Refer to your printer documentation for details of colour printing settings.';
var
  cal: Tcal_data;
  i: integer;
  prindex: integer;
  prstr: string;
  colour_depth_bits: integer;

begin
  if no_printer_available = True then begin
    alert(6, '    no  printer',
      'Templot is unable to locate a printer driver on this system. To install a printer driver, from the Windows taskbar click Start > Settings > Printers > Add Printer.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  repeat

    showing_dialog := True;   // 212a Wine bug

    if pad_form.print_setup_dialog.Execute = False then begin
      showing_dialog := False;   // 212a Wine bug
      EXIT;
    end;

    showing_dialog := False;   // 212a Wine bug

    if get_prindex(prindex) = False      // current selected printer index.
    then begin
      if alert(6, '    no  printer', 'Templot is unable to find the selected printer.' +
        '||Please select another.', '', '', '', '', 'cancel', 'O K', 0) = 5 then
        EXIT;
    end
    else
      BREAK;
  until 0 <> 0;

  prstr := printer_list.Strings[prindex];       // and name.

  if Tprint_cal(printer_list.Objects[prindex]).cal_data.printer_impact = -1 then begin
    if ask_impact_matrix(prindex, prstr) = False then
      EXIT;
  end;

  try
    with pad_form do begin

      cal := Tprint_cal(printer_list.Objects[prindex]).cal_data;

      if Printer.Orientation = poPortrait then
        portrait_menu_entry.Click;
      if Printer.Orientation = poLandscape then
        landscape_menu_entry.Click;

      { OT-FIRST colour_depth_bits:=GetDeviceCaps(Printer.Handle,BITSPIXEL)*GetDeviceCaps(Printer.Handle,PLANES);}
      colour_depth_bits := 24;  // OT-FIRST

      if (colour_depth_bits > 1) and (black_white = True) then begin
        repeat
          i := alert(4, '  ' + prstr, 'The current printer is  ' + prstr +
            '||This is a colour printer.' + '||Change to full-colour or grey-shade printing ?',
            '', '', 'more  information', 'change  to  grey - shade  printing',
            'continue  black && white  printing', 'change  to  full - colour  printing', 3);
          case i of
            3:
              alert_help(0, '   ' + prstr + print_col_help_str, '');
            4:
              grey_shade_printing_menu_entry.Click;
            5:
              if black_white_setup = False then begin
                if set_black_and_white = True then
                  EXIT;     // for the setup warning, (but not if called from there).
                // if True he re-entered this routine, so we can exit.
              end;
            6:
              colour_printing_menu_entry.Click;              // reset colour printer.
          end;//case
        until i <> 3;
      end;

      if (cal.printer_calibrated = False) and (cal_in_progress = False) then begin
        repeat                      // no cal done and not called from calibration function.
          i := alert(2, '    printer  not  calibrated', '||The current printer is  ' +
            prstr + '||Templot0 has no calibration information for this printer.' +
            '||Using the printer uncalibrated will probably be satisfactory for overall track design and printing trial templates.' +
            '||Before printing the final construction templates a printer calibration is recommended to ensure dimensional accuracy.',
            '', 'more  information', 'load  previous  calibration  settings  from  file',
            'calibrate  this  printer  now', '', 'use  printer  uncalibrated', 2);
          case i of
            2:
              alert_help(0, cal_prompt_str, '');
            3:
              calibration_load(prindex);
            4:
              calibrate_printer;                 // do printer calibration.
            6:
              EXIT;
            else
              run_error(135);
          end;//case
        until i <> 2;
      end;
    end;//with
  finally
    printer_setup_done := True;
    // flag that the printer setup has been shown at least once.
    page_info(True, True, False, 0);        // for the page outlines on the pad.
  end;//try
end;
//______________________________________________________________________________________

procedure update_ruler_div;   // 0.93.a

begin
  ruler_div := grid_spacex;             // make ruler divisions the same as the grid X
  if ruler_div < 1 then
    ruler_div := 1;   // 1mm prevent neg or zero.
end;
//______________________________________________________________________________

procedure set_grid_spacings(calling_form: TForm);

var
  i, n: integer;
  od: Toutdim;        // [0..7] array of double;

begin
  //pad_form.set_any_grid_spacing_menu_entry.Checked:=True;  // radio item

  { for putdim
            0: units_str:='';
            1: units_str:=' mm';      // units string.
            2: units_str:=' inches';
            3: units_str:=' degrees';
            4: units_str:=' %';
            5: units_str:=' cm';
            6: units_str:=' feet';
            7: units_str:=' proto-feet';
            8: units_str:=' metres';
}

  i := alert(4, '   grid  line  spacings ...',
    'The grid can be drawn in any of these units. For small scale models it is usually more convenient to work in mm.'
    + '||If PROTO-FEET is selected, the grid units will be in prototype feet at your current model scale.'
    + '||Which do you want to use ?', 'feet', 'inches', 'proto - feet', 'cm', 'cancel', 'mm', 0);
  case i of

    1: begin                          // feet
      n := putdim('', 6, 'X grid spacing on bottom margin (along page)',
        grid_spacex / 304.8, True, False, True, False);     // neg or 0 not allowed.
      n := putdim('', 6, 'Y grid spacing on left margin (across page)',
        grid_spacey / 304.8, True, False, True, False);    // neg or 0 not allowed.
      if n <> 1 then
        EXIT;
      if getdims('grid  line  spacings  in  feet', grid_help_all_str, calling_form, n, od) =
        True then begin
        if od[0] = def_req then
          grid_spacex := 304.8              // 1 foot default
        else
          grid_spacex := ABS(od[0] * 304.8);
        if od[1] = def_req then
          grid_spacey := 304.8
        else
          grid_spacey := ABS(od[1] * 304.8);
      end;
      grid_labels_code_i := 1;
    end;

    2: begin                          // inches
      n := putdim('', 2, 'X grid spacing on bottom margin (along page)',
        grid_spacex / 25.4, True, False, True, False);     // neg or 0 not allowed.
      n := putdim('', 2, 'Y grid spacing on left margin (across page)',
        grid_spacey / 25.4, True, False, True, False);    // neg or 0 not allowed.
      if n <> 1 then
        EXIT;
      if getdims('grid  line  spacings  in  inches', grid_help_all_str, calling_form, n, od) =
        True then begin
        if od[0] = def_req then
          grid_spacex := 25.4              // 1 inch default
        else
          grid_spacex := ABS(od[0] * 25.4);
        if od[1] = def_req then
          grid_spacey := 25.4
        else
          grid_spacey := ABS(od[1] * 25.4);
      end;
      grid_labels_code_i := 2;
    end;

    3: begin                          // proto-feet
      n := putdim('', 7, 'X grid spacing on bottom margin (along page)',
        (grid_spacex / scale), True, False, True, False);     // neg or 0 not allowed.
      n := putdim('', 7, 'Y grid spacing on left margin (across page)',
        (grid_spacey / scale), True, False, True, False);    // neg or 0 not allowed.
      if n <> 1 then
        EXIT;
      if getdims('grid  line  spacings  in  prototype  feet', grid_help_all_str,
        calling_form, n, od) = True then begin
        if od[0] = def_req then
          grid_spacex := scale * 25           // 25ft (100 mm in 4mm scale) default
        else
          grid_spacex := ABS(od[0] * scale);  // negative spacing not allowed.
        if od[1] = def_req then
          grid_spacey := scale * 25
        else
          grid_spacey := ABS(od[1] * scale);
      end;
      grid_labels_code_i := 3;
    end;

    4: begin                          // cm
      n := putdim('', 5, 'X grid spacing on bottom margin (along page)',
        (grid_spacex / 10), True, False, True, False);     // neg or 0 not allowed.
      n := putdim('', 5, 'Y grid spacing on left margin (across page)',
        (grid_spacey / 10), True, False, True, False);    // neg or 0 not allowed.
      if n <> 1 then
        EXIT;
      if getdims('grid  line  spacings  in  cm', grid_help_all_str, calling_form,
        n, od) = True then begin
        if od[0] = def_req then
          grid_spacex := 20               // 2 cm default
        else
          grid_spacex := ABS(od[0] * 10);   // negative spacing not allowed.
        if od[1] = def_req then
          grid_spacey := 20
        else
          grid_spacey := ABS(od[1] * 10);
      end;
      grid_labels_code_i := 4;
    end;

    5:
      EXIT;

    6: begin                          // mm
      n := putdim('', 1, 'X grid spacing on bottom margin (along page)',
        grid_spacex, True, False, True, False);
      // neg or 0 not allowed.
      n := putdim('', 1, 'Y grid spacing on left margin (across page)',
        grid_spacey, True, False, True, False);
      // neg or 0 not allowed.
      if n <> 1 then
        EXIT;
      if getdims('grid  line  spacings  in  mm', grid_help_all_str, calling_form,
        n, od) = True then begin
        if od[0] = def_req then
          grid_spacex := 20            // 20 mm  default.
        else
          grid_spacex := ABS(od[0]);   // negative spacing not allowed.
        if od[1] = def_req then
          grid_spacey := 20
        else
          grid_spacey := ABS(od[1]);
      end;
      grid_labels_code_i := 6;
    end;

    else
      run_error(71);
  end;//case

  if grid_spacex < 0.1 then
    grid_spacex := 0.1;     // minimum 0.1 mm.
  if grid_spacey < 0.1 then
    grid_spacey := 0.1;

  if ruler_units = 0 then
    update_ruler_div;   // 0.93.a ruler as grid option

  do_rollback := False;       // no need to put this change in rollback register on redraw.
  redraw(True);
end;
//______________________________________________________________________________________

procedure toggle_radius_lamp;

begin
  if toggle_1 = 0 then begin
    toggle_1 := 1;
    info_form.min_rad_lamp_panel.Color := clRed;
  end
  else begin
    toggle_1 := 0;
    info_form.min_rad_lamp_panel.Color := clBlack;
  end;
end;
//____________________________________________________________________________________

procedure toggle_ring_lamp;

begin
  if toggle_2 = 0 then begin
    toggle_2 := 1;
    if (cl_only = True) or (warn_centrelines = True) then
      info_form.ring_lamp_panel.Color := clWhite
    else
      info_form.ring_lamp_panel.Color := clRed;
  end
  else begin
    toggle_2 := 0;
    info_form.ring_lamp_panel.Color := clBlack;
  end;
end;
//______________________________________________________________________________

procedure do_hide_current;      // set flags to hide control template.

begin

  pad_form.hide_control_template_menu_entry.Checked := True;   // 209c  radio item
  pad_form.hide_control_template_popup_entry.Checked := True;  // 209c  radio item

  hide_current_flag := True;
  save_hide := True;
  current_is_showing := False;
  redraw_pad(True, False);
end;
//______________________________________________________________________________

procedure extend_template_from_zero;

begin
  turnoutx := 132 * scale;     // arbitrary new length 2 chains.
  turnout_i := 1;            // length locked at turnoutx.
  if plain_track = True then
    xorg := turnoutx
  else
    xorg := 0;
  startx := 0;
  redraw_pad(False, True);     // immediate re-calc
end;
//______________________________________________________________________________

function check_control_template_is_valid(cancel_str: string): boolean;   // 0.93.a

const
  zero_help_str: string = 'php/199    `0Zero-Length Control Template`9' +
    '||The control template can be invalidated by having its length set to zero.' +
    '||The usual reason this is done is to prevent a copy of the control template being automatically stored in the storage box, which would otherwise create duplicate stored templates.' + '||A zero-length control template is shown on the trackpad as a red  `0<B>Z</B>`8  symbol replacing its fixing peg, and in `0red text`8 on the information bar.' + '||When the control template is shown as zero-length, your usual next action will be either to create a new mint template by clicking the <span style="color:#0000ff; font-size:15px;"><B>NEW</B></span> tool-button,' + ' or to click on an existing background template in order to modify or copy that template.' + '||More experienced users can simply extend the length of the control template (`0F4`2 mouse action) and continue working with it.' + ' Selecting any other mouse action will automatically extend the control template to a scale length of 2 chains (132ft).' + '||If desired the control template can be invalidated manually by clicking the Z tool-button or by pressing the `0DELETE`2 key.' + ' If the current control template is already zero-length when this button is clicked, the most recent manually invalidated template will be restored.';

var
  i: integer;

begin
  Result := (turnoutx > 0);

  if (Result = False) and (bgnd_clicked_in_quick_mode = False) then begin
    repeat
      i := alert(2, 'php/199    zero - length  template',
        ' |The length of the control template is zero.' +
        '||A zero-length template can not be stored in the storage box, or saved in a data file, or used as a background template in a track plan, or used to make a crossover, diamond-crossing, branch track, etc.| ', '', '', '?  more  information', 'extend  template  to  2  chains  length  and  continue     ', 'cancel  ' + cancel_str, '', 3);

      if i = 3 then
        alert_help(0, zero_help_str, '');

    until i <> 3;

    if i = 4 then begin
      extend_template_from_zero;
      Result := True;
    end;
  end;
end;
//______________________________________________________________________________

procedure set_y_datum;          // set up default y position.
// set y_datum (in mm.)
// y_datum is positive from left sheet edge to calc origin.

begin
  case hand_i of

    1:
      y_datum := 6 * scale;
    // l.h. turnout y datum default (6ft scale) from left margin.

    -1:
      if (screeny - page_width / 100) > (4 * scale)
      // more than 4ft scale beyond whole page width visible ?
      then
        y_datum := page_width / 100 - 6 *
          scale   // r.h. turnout y datum default 6ft scale from far edge of sheet.

      else
        y_datum := screeny - 10 * scale;         // r.h  10ft scale from visible screen height.

    else
      run_error(17);
  end;//case
end;
//_______________________________________________________________________________________________________________________________

function show_a_line(on_canvas: TCanvas; aq: ERailData; pen_width: integer;
  erasing: boolean): boolean;
  //  draw a rail-line on the screen.

  // (RESULT is never used)

var
  now, now_max: integer;
  move_to, line_to, save_line_to: TPoint;
  pt: TPoint;

begin
  Result := False;    // default init.

  if aqyn[aq] = False then
    EXIT;         //  no valid data to draw.

  //if (aq=16) and (draw_ts_platform_rear_edge=False) and (erasing=False) then EXIT;   // (platform rear edge must be in list for printing infill)
  //if (aq=20) and (draw_ms_platform_rear_edge=False) and (erasing=False) then EXIT;   // (platform rear edge must be in list for printing infill)

  try
    with on_canvas do begin

      Pen.Color := ink_colour;
      Pen.Mode := pmCopy;

      Pen.Width := pen_width;    // 212a

      Brush.Color := paper_colour;  // gaps in dotted lines.
      Brush.Style := bsSolid;

      TextOut(0, 0, '');  // needed for dotted lines - Delphi bug?

      Pen.Style := psSolid;

      if (aq = eRD_AdjTrackTurnoutSideNearGaugeFace) and (adjacent_edges = True) and
        (draw_ts_platform_rear_edge = False) then
        Pen.Style := psDot;    // 0.93.a show dotted on screen if hidden on output.
      if (aq = eRD_AdjTrackMainSideNearGaugeFace) and (adjacent_edges = True) and
        (draw_ms_platform_rear_edge = False) then
        Pen.Style := psDot;

      now_max := nlmax_array[aq];

      pt := outoflist(aq, 0);
      move_to.X := Round(pt.X * sx + ex - gx);
      move_to.Y := Round((pt.Y + yd) * sy + by - gy);
      for now := 1 to now_max do begin
        pt := outoflist(aq, now);
        line_to.X := Round(pt.X * sx + ex - gx);
        line_to.Y := Round((pt.Y + yd) * sy + by - gy);

        save_line_to := line_to;  // in case check_limits modifies it (e.g paper bunching)

        if check_limits(move_to, line_to) = True then begin
          MoveTo(move_to.X, move_to.Y);
          LineTo(line_to.X, line_to.Y);
        end;
        move_to := save_line_to;
      end;//for
    end;//with
    Result := True;
  except
    EXIT;               // abandon if any calc errors
  end;//try
end;
//_______________________________________________________________________________________________________________________________

function calc_peg_dims(code: integer; var pegx, pegy, pegangle: double): Tpeg_indicator_string;

  // called from turnout_dims.
var
  temp_x: double;

begin

  Result := '-';     // default init.

  case code of
    -2: begin
      {on a rail joint} pegy := g / 2;
      pegangle := 0;
      Result := 'J';
    end;
    -1:
      Result := 'S'; // do nothing
    0: begin
      pegx := 0;
      pegy := g / 2;
      pegangle := 0;
      Result := '0';
    end;
    1: begin
      pegx := xorg;
      pegy := g / 2;
      pegangle := 0;
      Result := '1';
    end;
    2: begin
      pegx := toemidx;
      pegy := g / 2;
      pegangle := 0;
      Result := '2';
    end;
    3: begin
      pegx := dpx;
      pegy := g / 2;
      pegangle := 0;
      Result := '3';
    end;
    4: begin
      pegx := fpx;
      pegy := g;
      pegangle := 0;
      Result := '4';
    end;

    5: begin
      pegx := tcpx;
      pegy := tcpy;
      pegangle := k3;
      Result := 'N';
    end;
    6: begin
      pegx := txpx;
      pegy := aq25offset(pegx, pegangle);
      Result := '5';
    end;
    7: begin
      pegx := trpx;
      pegy := trpy;
      pegangle := 0;
      Result := 'N';
    end;

    8: begin
      pegx := mcpx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;
    9: begin
      pegx := mxpx;
      pegy := g / 2;
      pegangle := 0;
      Result := '7';
    end;
    10: begin
      pegx := mrpx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;

    11: {begin
                  if main_road_i=2
                     then begin pegx:=xorg+main_road_endx; pegy:=g/2;  pegangle:=0; RESULT:='9'; end           // 217a  adjustable end
                     else} begin
      pegx := turnoutx;
      pegy := g / 2;
      pegangle := 0;
      Result := '9';
    end;

    //end;

    12: begin
      pegx := 0;
      pegy := g / 2 + trtscent;
      pegangle := 0;
      Result := 'N';
    end;  // adjacent turnout-side track centre.
    13: begin
      pegx := 0;
      pegy := g / 2 - trmscent;
      pegangle := 0;
      Result := 'N';
    end;  // adjacent main-side track centre.
    14: begin
      pegx := torgx;
      pegy := torgy;
      pegangle := k3 + Pi / 2;
      Result := 'N';
    end;  // turnout rad centre.
    15: begin
      pegx := os;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;  // transition start.
    16: begin
      pegx := os + tst;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;  // transition end (length).
    17: begin
      pegx := mvjpx;
      pegy := g / 2;
      pegangle := 0;
      Result := '8';
    end;  // vee joint (point rail end).
    18: begin
      pegx := tvjpx;
      pegy := aq25offset(pegx, pegangle);
      Result := '6';
    end;  // vee joint (splice rail end).

    19: begin
      pegx := (turnoutx + startx) / 2;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;  // mid-length  5-3-01.     startx blanking included 216a

    20: begin
      case peg_rail of
        // pegx set by trail_peg, slide or snake mouse actions...
        0:
          do_nothing;        // free move, pegy set by trail_peg also.
        1: begin
          pegy := 0;                       // straight stock rail       aq=0.
          pegangle := 0;
        end;
        2:
          pegy := aq2offset(pegx, pegangle);  // curved turnout rail       aq=2.
        3: begin
          pegy := g;                       // straight turnout rail     aq=1.
          pegangle := 0;
        end;

        4:
          if plain_track = True then begin
            pegy := g;       // TS running rail plain track.
            pegangle := 0;
          end
          else
            pegy := aq3offset(pegx, pegangle);  // curved stock rail         aq=3.

        5: begin
          pegy := g / 2 - trmscent;            // adjacent main-side centre-line.
          pegangle := 0;
        end;
        6: begin
          pegy := g / 2 + trtscent;
          // adjacent turnout-side centre-line.
          pegangle := 0;
        end;
        7: begin
          pegy := (g + trtscent) / 2;
          // double-track turnout-side centre-line.
          pegangle := 0;
        end;
        8: begin
          pegy := g / 2;                     // main road centre-line     aq=24.
          pegangle := 0;
        end;
        9:
          pegy := aq25offset(pegx, pegangle); // turnout road centre-line  aq=25.
        else begin
          pegy := g / 2;
          pegangle := 0;
        end;
      end;//case
      if mouse_modify > -1 then
        Result := 'M'         // mouse action moving the peg.
      else
        Result := 'F';
    end;

    22: begin
      pegx := toemidx;
      pegy := g / 2;
      pegangle := k1;
      Result := '22';
    end;    // toggle CTRL-2 options.
    33: begin
      pegx := dpx;
      pegy := g / 2;
      pegangle := k3;
      Result := '33';
    end;    // toggle CTRL-3 options.
    44: begin
      pegx := fpx;
      pegy := g;
      pegangle := k3;
      Result := '44';
    end;    // toggle CTRL-4 options.

    100: begin  // peg on end of planing...

      if (half_diamond = True) and (fixed_diamond = True)   // fixed diamond.
      then begin
        pegx := toemidx;
        // no planing - put it on centre instead (menu is disabled).
        pegy := g / 2;
        pegangle := k1;
      end
      else begin
        pegx := (plox + stox) / 2;
        // on nominal radial end mark (not strictly radial).

        if (ABS(pegx - sworgx) < ABS(swrad - g / 2 - minfp)) and (gaunt = False) then begin
          pegy := sworgy - SQRT(SQR(swrad - g / 2) - SQR(pegx - sworgx));
          pegangle := ARCSIN((pegx - sworgx) / (swrad - g / 2));
        end
        else begin          // gaunt or ??? ...
          pegx := 0;
          pegy := g / 2 + h;
          pegangle := 0;
        end;
      end;
      Result := 'N';
    end;


    104: begin                      // peg on switch heel...
      if half_diamond = True then begin
        // fixed-diamond or switch-diamond.
        pegx := toemidx;
        // no heel - put it on centre instead (menu is disabled).
        pegy := g / 2;
        pegangle := k1;
      end
      else begin
        if gaunt = True     // 0.93.a ex 081 ...
        then begin
          pegx := xorg;
          pegy := g / 2 + h;
          pegangle := 0;
        end
        else begin
          pegx := torgx + (tradius - g / 2) * SIN(k2);
          //^^^  // switch curve end / turnout curve start.
          pegy := torgy - (tradius - g / 2) * COS(k2);  //^^^
          pegangle := k2;
        end;
      end;
      Result := 'N';
    end;

    108: begin   // CESP
      if (tradius_is_straight = True) or (xing_type_i <> 0)  // no CESP, return TCP instead
      then begin
        pegx := tcpx;
        pegy := tcpy;
      end
      else begin
        // peg on CESP (crossing entry straight point=end of turnout curve)...
        pegx := torgx + (tradius - g / 2) * SIN(k3);  // turnout curve end.
        pegy := torgy - (tradius - g / 2) * COS(k3);
      end;

      pegangle := k3;
      Result := 'N';
    end;

    200: begin
      pegx := egpx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;      // EGTP
    201: begin
      pegx := egeo_orgx;
      pegy := egeo_orgy;
      pegangle := 0;
      Result := 'N';
    end;      // EGORG
    220: begin
      pegx := igpx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;      // IGTP
    221: begin
      pegx := igeo_orgx;
      pegy := igeo_orgy;
      pegangle := 0;
      Result := 'N';
    end;      // IGORG

    222: begin
      pegx := toemidx;
      pegy := g / 2;
      pegangle := k1 / 2;
      Result := 'SD';
    end;    // split deflection  213a

    240: begin
      pegx := xorg + min_turnout_road_endx;
      pegy := aq25offset(pegx, pegangle);
      Result := 'N';
    end;    // TMINP   213b
    241: begin
      pegx := xorg + turnout_road_endx;
      pegy := aq25offset(pegx, pegangle);
      Result := 'E';
    end;    // TEXITP  213b

    260: begin
      pegx := xorg + min_main_road_endx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;    // MMINP   217a
    261: begin
      pegx := xorg + main_road_endx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'E';
    end;    // MEXITP  217a

    270: begin
      // 217b  mid-point of turnout curve   first get switch heel...
      if half_diamond = True then
        temp_x := toemidx    // no heel - put it on centre instead (menu is disabled).
      else
      if gaunt = True then
        temp_x := xorg
      else
        temp_x := torgx + (tradius - g / 2) * SIN(k2);  // switch curve end / turnout curve start.

      case xing_calc_i of             // turnout curve end...
        -1:
          pegx := (fpx + temp_x) / 2;                          // generic FP
        0:
          pegx := (torgx + (tradius - g / 2) * SIN(k3) + temp_x) / 2;  // regular CESP
        1:
          pegx := (fpx + temp_x) / 2;                          // curviform FP   was TVJP
        else
          pegx := 0;   // ???
      end;//case

      pegy := aq25offset(pegx, pegangle);
      Result := 'N';
    end;

    275: begin
      // 218d  mid-point of return curve     used in radius calcs
      pegx := retrorgx - retr * SIN(tvjpk / 2);
      pegy := retrorgy + retr * COS(tvjpk / 2);
      pegangle := tvjpk / 2;

      Result := 'N';
    end;


    279: begin
      pegx := wingcx_minus - scale / 6;
      pegy := g;
      pegangle := 0;
      Result := 'N';
    end;  // 218a  start of knuckle bend minus 2" arbitrary

    280: begin
      pegx := atx;
      pegy := g;
      pegangle := 0;
      Result := 'N';
    end;     // 218a  peg on "A" timber, gauge face

    285: begin
      pegx := bnox;
      pegy := g + j;
      pegangle := 0;
      Result := 'N';
    end;     // 218a  peg on end of vee splice

    300: begin
      pegx := slew_s;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;     // peg on slewing start.
    301: begin
      pegx := slew_s + slew_l;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;     // peg on slewing end.

    400: begin
      pegx := os - ts1;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;     // peg on trans calcs origin.

    600: begin
      pegx := turnoutx;
      pegy := aq25offset(pegx, pegangle);
      Result := 'N';
    end;  // TOLP peg on turnout road opposite end of main road (for parallel crossings). // 0.79.a
    610: begin
      pegx := startx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;  // blanking length  // 0.82.a

    615: begin
      pegx := ipx;
      pegy := g / 2;
      pegangle := 0;
      Result := 'N';
    end;  // IP Intermediate 208a

    999: begin                    // user-defined peg location and angle.
      if udpeg_valid = True then begin
        pegx := udpegx;
        pegy := udpegy;
        pegangle := udpegangle;
      end
      else begin
        pegx := 0;
        pegy := g / 2;
        pegangle := 0;
      end;
      Result := 'U';
    end;
    else begin
      pegx := 0;
      pegy := g / 2;
      pegangle := 0;
      Result := 'F';
    end; // ??? peg-code wrong.

      // this following is in all versions prior to 0.71.a and will cause a crash
      // if a later file is loaded with an upgrade peg_code.

      //else run_error(248);  // peg_code wrong?
  end;//case

end;
//_____________________________________________________________________________________________

procedure turnout_dims;       // calc and display all the turnout dimensions on the pad.
// called only from gocalc.

var
  temp_k, dummy: double;
  geox, geoy, geok: double;
  tvjy, tvjk: double;

  // 217b ..

  curving_rad, mod_pegangle, shrink_factor, tanx: double;

begin
  reset_defaults;                   //  set up any defaults and distortions.

  if calc_curving = False             //  calc curving radii and transition constants, etc
  then
    abandon_calcs := True;

  if abandon_calcs = False            //  curving calcs error-free ?
  then begin
    init_resize;                //  set up starting switch size for re-sizing upwards.
    done_calcs := calcturnout;  //  calc all turnout dims.
  end;

  if abandon_calcs = False            //  turnout calcs error-free ?
  then begin
    // first get geometrical rads...

    if (spiral = False) and (slewing = False) and (plain_track = False) then begin

      tvjy := aq25offset(tvjpx, tvjk);   // peg calcs for TVJP (Ctrl-6).

      docurving(False, False, tvjpx, tvjy, geox, geoy, geok, dummy);
      if calc_geo_radius(nomrad, geox, geoy - g / 2, geok + tvjk, egeo_rad,
        egeo_k, egeo_swing, egpx) = False then begin
        egeo_rad := max_rad;  // don't leave invalid data.
        egeo_k := 0;
        egeo_swing := 0;
        egpx := 0;
      end;

      docurving(False, False, tcpx, tcpy, geox, geoy, geok, dummy);
      if calc_geo_radius(nomrad, geox, geoy - g / 2, geok + k3, igeo_rad, igeo_k,
        igeo_swing, igpx) = False then begin
        igeo_rad := max_rad;  // don't leave invalid data.
        igeo_k := 0;
        igeo_swing := 0;
        igpx := 0;
      end;
    end
    else begin                 // no geo rads if transition or slewing...
      egeo_rad := max_rad;
      egeo_k := 0;
      egeo_swing := 0;
      egpx := 0;

      igeo_rad := max_rad;  // don't leave invalid data.
      igeo_k := 0;
      igeo_swing := 0;
      igpx := 0;
    end;
    // radial centres...
    egeo_orgx := egpx;
    egeo_orgy := egeo_rad + g / 2;    // adjust rad centres for the datum on the rail.

    igeo_orgx := igpx;
    igeo_orgy := igeo_rad + g / 2;

    // now the peg position calcs...

    pad_form.peg_indicator_panel.Caption := calc_peg_dims(peg_code, pegx, pegy, pegangle);

    normalize_angle(pegangle);

    docurving(True, True, pegx, pegy, pegx_on_pad, pegy_on_pad, temp_k, curving_rad);
    // curve and transform peg to get position (for info) and curving angle.

    // 217b  gradient correction for radial shrink/enlarge ...

    if ABS(pegangle) < minfp then
      mod_pegangle := pegangle
    else begin
      try
        shrink_factor := (curving_rad - (pegy - g / 2)) / curving_rad;
        tanx := 1 / TAN(pegangle);
        tanx := tanx * shrink_factor;
        mod_pegangle := ARCTAN(1 / tanx);
      except
        mod_pegangle := pegangle;
      end;//try
    end;

    arm_angle := mod_pegangle + temp_k + kform;
    // arm angle (actual on pad including curving and transforms).

    //arm_angle:=pegangle+temp_k+kform;         // peg arm angle (actual on pad including curving and transforms).

    normalize_angle(arm_angle);

    docurving(True, True, 0, 0, datumx_on_pad, datumy_on_pad, temp_k, dummy);
    // position of rail-end datum on pad (for info).

    compile_template_data;  // finally compile text of template info, and show it.

    // and the pad size data...

    with info_form do begin
      pad_width_label.Caption :=
        'pad  width   =  ' + round_str(screenx, 2) + ' mm  ( ' +
        round_str(screenx / 25.4, 2) + ' " )';
      pad_height_label.Caption :=
        'pad  height  =  ' + round_str(screeny, 2) + ' mm  ( ' +
        round_str(screeny / 25.4, 2) + ' " )';

      notchx_label.Caption := 'notch  centre  X  =  ' + round_str(notchx, 2) + ' mm';
      notchy_label.Caption := 'notch  centre  Y  =  ' + round_str(notchy, 2) + ' mm';
      notchk_label.Caption :=
        'notch  angle  =  ' + round_str(notch_angle * 180 / Pi, 2) + ' degs' +
        k_ram_str(notch_angle);

      offsetx_label.Caption :=
        'offset  X  =  ' + round_str(zoom_offsetx, 2) + ' mm  ( ' +
        round_str(zoom_offsetx / 25.4, 2) + ' " )';
      offsety_label.Caption :=
        'offset  Y  =  ' + round_str(zoom_offsety, 2) + ' mm  ( ' +
        round_str(zoom_offsety / 25.4, 2) + ' " )';
    end;//with
  end;
end;
//______________________________________________________________________________________

procedure screen_calcs;   //  do the screen zoom calcs. enter with screenx.

begin
  if screenx < minfp then
    run_error(2); //  calcs not done - division by zero, or negative scale.


  xmax := pad_form.ClientWidth - 1;         //  max x value inside borders (screen is 0..1023).
  ymax := pad_form.ClientHeight - 1;        //  ditto y.


  if xmax < 20 then
    xmax := 20;      // 216c sensible safety limits (div 0).             was 10
  if ymax < 10 then
    ymax := 10;

  //ex:=xmax/60;          // left screen margin position = top of sheet. ( 1/60 = 17 pixels for 1024 screen)

  ex := 17;  // 216c  fixed

  fx := (xmax - ex) / screenx;         // x scaling factor for screen in pixels per mm.
  sx := fx / 100;
  // x scaling factor for screen in pixels per 1/100 mm. (rail-data is in 1/100 mm.)

  fy := 0 - fx;
  sy := 0 - sx;                      // y is same but negative - see notes above.

  try
    ffx := 1 / fx;     // x mm per screen pixel.
    ffy := 1 / fy;     // y ditto.
  except
    ffx := 1;        // ?? scale zero?
    ffy := 1;
  end;//try

  by := ymax + pad_form.Font.Height - 4;
  // leave room at bottom for labels (font height is negative).

  screeny := by / ABS(fy);           //  screen y dim in mm.

  gx := zoom_offsetx * fx;           //  pad offset pixels on x
  gy := zoom_offsety * fy;           //  ditto y. (negative).


  try
    bunch_jump_i := Round(bunching_jump * fx);    // for paper bunching.
    bunch_shear_i := Round(bunching_shear * fy);    // for paper bunching.
  except
    bunch_jump_i := Round(50 * scale);            // default 50ft scale.
    bunch_shear_i := 0;
  end;//try
end;
//________________________________________________________________________________________

procedure gocalc(calcs_code, mode: integer);    //  a new turnout wanted - let's do some calcs.

// calcs_code 0 = does the turnout calcs only, no list generation or drawing.
//            1 = also generates a list but no drawing (for storage box, etc, - set the scaling factors first).
//            2 = also does a redraw.

// mode  0 = normal fixed off-screen redraw.

//  modes for mouse actions...

// on-screen modes..

//       1 = zoom fixed. 2 or fewer background templates
//       2 = ditto, first click.

//       3 = zoom fixed. 3 or more background keeps.
//       4 = ditto, first click.

//       5 = zoom or position changing.
//       6 = ditto, first click.

// off-screen modes..

//       7 = zoom fixed.
//       8 = ditto, first click.

//       9 = zoom or position changing.
//      10 = ditto, first click.

var
  hourglass: boolean;
  current_canvas: TCanvas;
  in_mode: integer;
  mps: TPoint;
  //dummy:boolean;

begin

  data_changed := False;
  // don't come here again via endless loop until a flagchange.


  if gocalc_lock = True then
    EXIT;    // no calcs while locked.

  if (mode < 0) or (mode > 10) then
    run_error(19);

  case mode of
    1..6:
      current_canvas := pad_form.Canvas;
    else
      current_canvas := offdraw_bmp.Canvas;
  end;//case

  if (draw_mode <> 0) and (mouse_modify < 0) and (Screen.Cursor = crDefault) then begin
    hourglass := True;
    // out 0.93.a Screen.Cursor:=crHourglass;      // not during adjusts or draw mode 0 (diagnostic/init).
  end
  else
    hourglass := False;

  try

    if in_progress = False then begin
      in_progress := True;                //  prevent any re-entry here.

      abandon_calcs := False;             //  fresh start or re-calc.
      calcs_done_and_valid := False;      //  flag calcs not yet valid (for add keep).

      turnout_dims;                     //  do all the turnout calcs for the pad.

      if abandon_calcs = False            //  turnout calcs error-free ?
      then begin
        if calcs_code = 0 then
          EXIT;  // only the turnout calcs were wanted.

        if calcs_code = 2
        // no screen calcs if calcs are for the keeps box - just calc the lists using the keeps box scaling factors.
        then begin
          if draw_mode < 2 then
            screenx := ABS(turnoutx + scale * 4);   //  add some right margin space (4ft scale).
          //  (can't use xy_max because list not yet filled.)
          if screenx < screenx_min then
            screenx := screenx_min;     // minimum for screen width (max zoom in).
          if screenx > screenx_max then
            screenx := screenx_max;     // maximum zoom out.

          screen_calcs;    // then calc the screen factors from screenx.

          if draw_mode = 0 then
            set_y_datum; // set default y_datum.

          // save the screen factors, might be need in the keeps box (e.g. highlight background).

          save_sx := sx;
          save_sy := sy;
          save_ex := ex;
          save_by := by;
          save_gx := gx;
          save_gy := gy;

          if (mode = 1) or (mode = 2) then begin
            pad_marks_current(pad_form.Canvas, False);
            // erase any existing marks and timbers (ignore return).
            draw_rail_endmarks(pad_form.Canvas, False);
            // and the rail ends.
          end;

          do_background(mode);
          // then draw the grid and add the scale bar.
        end;

        // calcs_code 1 or 2 ..

        done_rails := new_calc_draw(current_canvas, calcs_code, mode);
        // then calc rail lines and marks, erase previous lines and draw new.
      end;

      if (done_calcs = True) and (done_rails = True) and (abandon_calcs = False)
      //  all calcs ok ?
      then begin
        calcs_done_and_valid := True;     // ok for output to printer or keeps box.

        if (calcs_code = 2) and ((mode = 0) or (mode > 6))
        // no screen change if calcs are for the keeps box.
        then begin
          copy_draw_to_pad;
          // copy the draw bitmap to the pad.              do_background(0);   //  draw the complete background.

        end;

        EXIT;            // all done.
      end
      else begin
        calcs_done_and_valid := False;    //  can't print or keep this.
        done_calcs := False;
        done_rails := False;
        abandon_calcs := True;
        if Application.Terminated = False then
          Application.ProcessMessages;     // clear any pending repaints.
        redraw(True);
        // onIdle handles error options and recovery.
      end;

    end;//if not in progress
  finally
    if hourglass = True then begin
      Screen.Cursor := crDefault;
      case mouse_modify of
        -1:
          pad_form.Cursor := crDefault;
        0:
          pad_form.Cursor := mouse_action_cursor;
      end;//case

      if GetCursorPos(mps) = False then begin
        mps.X := 0;
        mps.Y := 0;
      end;
      SetCursorPos(mps.X, mps.Y);
      // need a mouse move event to set the pad cursor after a screen cursor change.

    end;

    in_progress := False;                                 // allow re-entry
  end;//try
end;
//________________________________________________________________________________________

procedure railedges(gf, oe, cl: boolean);    // switch rail edges on/off as requested.

var
  i: ERailData;

begin
  for i in ERailData do
    aqyn[i] := False;      // switch them all off,
  // and then some back on...

  if (cl_only = False) and (rail_section <> 0)     // rails wanted?
  then begin

    if pad_form.stock_rails_menu_entry.Checked = True  // generator switches...
    then begin
      if main_road_stock_rail_flag = True      // rail switches per template.
      then begin
        aqyn[eRD_StraightStockGaugeFace] := gf;    // straight stock rail.
        aqyn[eRD_StraightStockOuterFace] := oe;
      end;

      if turnout_road_stock_rail_flag = True then begin
        aqyn[eRD_CurvedStockGaugeFace] := gf;    // curved stock rail.
        aqyn[eRD_CurvedStockOuterFace] := oe;
      end;
    end;

    if pad_form.crossing_rails_menu_entry.Checked = True then begin
      if main_road_crossing_rail_flag = True then begin
        aqyn[eRD_StraightTurnoutWingGaugeFace] := gf;    // straight turnout/wing rail.
        aqyn[eRD_StraightTurnoutWingOuterFace] := oe;
      end;

      if turnout_road_crossing_rail_flag = True then begin
        aqyn[eRD_CurvedTurnoutWingGaugeFace] := gf;    // curved turnout/wing rail.
        aqyn[eRD_CurvedTurnoutWingOuterFace] := oe;
      end;

      if crossing_vee_flag = True then begin
        aqyn[eRD_VeePointGaugeFace] := gf;    // straight vee rail.
        aqyn[eRD_VeePointOuterFace] := oe;

        aqyn[eRD_VeeSpliceGaugeFace] := gf;    // curved vee rail.
        aqyn[eRD_VeeSpliceOuterFace] := oe;
      end;
    end;

    if pad_form.check_rails_menu_entry.Checked = True then begin
      if main_road_check_rail_flag = True then begin
        aqyn[eRD_MainSideCheckGaugeFace] := gf;    // straight check rail.
        aqyn[eRD_MainSideCheckOuterFace] := oe;

        if (half_diamond = True) and (fixed_diamond = True) then begin
          aqyn[eRD_KCrossingCheckTurnoutSideGaugeFace] := gf;
          // h-d DS check rail. (DS check is in main road.)
          aqyn[eRD_KCrossingCheckTurnoutSideOuterEdge] := oe;
        end;
      end;

      if turnout_road_check_rail_flag = True then begin
        aqyn[eRD_TurnoutSideCheckGaugeFace] := gf;    // curved check rail.
        aqyn[eRD_TurnoutSideCheckOuterFace] := oe;

        if (half_diamond = True) and (fixed_diamond = True) then begin
          aqyn[eRD_KCrossingCheckMainSideGaugeFace] := gf;
          // h-d MS check rail. (MS check is in diamond road.)
          aqyn[eRD_KCrossingCheckMainSideOuterEdge] := oe;
        end;
      end;
    end;
  end;

  //case adjacent_lines_code of   // 0.82.d     trackbed edges option instead of near rails.

  // 0, do nothing.

  if gen_platforms = True     // generator switch
  then begin

    if adjacent_edges = False
    // 0.93.a   False=adjacent tracks,  True=trackbed edges and platform edges.
    then begin
      if (cl_only = False) and (rail_section <> 0) then begin
        // any adjacent tracks...
        //       if gen_tsnr=True
        //          then begin
        aqyn[eRD_AdjTrackTurnoutSideNearGaugeFace] := gf;
        aqyn[eRD_AdjTrackTurnoutSideNearOuterFace] := oe;
        //               end;

        //       if gen_tsfr=True
        //          then begin
        aqyn[eRD_AdjTrackTurnoutSideFarGaugeFace] := gf;
        aqyn[eRD_AdjTrackTurnoutSideFarOuterFace] := oe;
        //               end;

        //       if gen_msnr=True
        //          then begin
        aqyn[eRD_AdjTrackMainSideNearGaugeFace] := gf;
        aqyn[eRD_AdjTrackMainSideNearOuterFace] := oe;
        //               end;

        //       if gen_msfr=True
        //          then begin
        aqyn[eRD_AdjTrackMainSideFarGaugeFace] := gf;
        aqyn[eRD_AdjTrackMainSideFarOuterFace] := oe;
        //               end;

      end;
    end

    else begin     // 0.93.a platforms and trackbed edges...

      aqyn[eRD_AdjTrackTurnoutSideNearGaugeFace] := draw_ts_platform;
      aqyn[eRD_AdjTrackTurnoutSideNearOuterFace] := draw_ts_platform;

      aqyn[eRD_AdjTrackTurnoutSideFarGaugeFace] := draw_ts_trackbed_edge;
      aqyn[eRD_AdjTrackTurnoutSideFarOuterFace] := draw_ts_trackbed_edge;

      aqyn[eRD_AdjTrackMainSideNearGaugeFace] := draw_ms_platform;
      aqyn[eRD_AdjTrackMainSideNearOuterFace] := draw_ms_platform;

      aqyn[eRD_AdjTrackMainSideFarGaugeFace] := draw_ms_trackbed_edge;
      aqyn[eRD_AdjTrackMainSideFarOuterFace] := draw_ms_trackbed_edge;

    end;
  end;//generator switch

  //  end;//case

  if track_centre_lines_flag = True then begin
    aqyn[eRD_MainRoadCentreLine] := cl;          // track centre-lines.

    if plain_track = False then
      aqyn[eRD_TurnoutRoadCentreLine] := cl;    // turnout side centre-line.
  end;
end;
//________________________________________________________________________________________

procedure do_railedges;
// called from rail_options_unit and platform_unit and trackbed_unit and control_room

begin
  railedges(gauge_faces, outer_edges, centre_lines);
end;
//_________________________________________________________________________________________

procedure swap_hand;

var
  dummy1, dummy2: double;
  pc, pf: Tpex;

begin
  arm_angle_now := arm_angle;
  // save current peg arm angle on pad.
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, dummy1, dummy2);
  // and current peg position.

  hand_i := 0 - hand_i;     // swap hand.
  // then calc new peg position on pad...

  docurving(False, True, pegx, pegy, pc.x, pc.y, dummy1, dummy2);  // first curve it.

  dotransform(kform, xform, yform, pc, pf);      // then rotate it (without shifts).

  xshift := now_peg_x - pf.x;
  // maintain peg position constant (now_peg includes the now_shift).
  yshift := (0 - now_peg_y) - pf.y;  // must swap hand of now_peg_y.

  gocalc(0, 0);                   // recalc to update arm_angle.

  rotate_turnout(0 - arm_angle - arm_angle_now, True);
  // re-align to previous angle (opposite hand) and re-draw.
end;
//__________________________________________________________________________________________

procedure select_switch;

var
  old_n, new_n: integer;
  sw_info: Tswitch_info;
  dummy: double;

begin
  if half_diamond = True then begin
    if alert(3, '    switch  settings   -   half - diamond',
      'The control template is a half-diamond.' +
      '||Normally any changes which you make to the switch settings will have no effect until you change to a turnout template'
      + ' by clicking the|`0TEMPLATE > CONVERT HALF-DIAMOND TO TURNOUT`1 menu item.' +
      '|||But you can if you wish use the switch settings for the timber-spacing and rail joint marks on a movable K-crossing.'
      + ' This might apply if you are using a half-diamond template to improvise a split deflection switch, for example to create a symmetrical Y-turnout.' + ' For this to work, you need to click the|`0real > timbering > half-diamond timbering > movable K-crossing: timber-spacing as turnout switch`z menu option.' + ' Remember to de-select this option when you return to creating normal half-diamond templates for diamond-crossings and slips.' + ' Bear in mind that this option applies only to the timber spacings and rail joints, the switch geometry is ignored for a K-crossing.', '', '', '', '', 'cancel', 'continue  -  set  switch ...', 0) = 5 then
      EXIT;
  end;

  if plain_track = True then begin
    if alert(3, '    plain  track', 'The control template is plain track.' +
      '||Any changes which you make to the switch settings will have no effect until you change to a turnout template'
      + ' by clicking the|TEMPLATE > INSERT TURNOUT IN PLAIN TRACK|menu item.',
      '', '', '', '', 'cancel', 'continue  -  set  switch ...', 0) = 5 then
      EXIT;
  end;


  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  old_n := get_switch_list_index(csi.group_code, csi.size_code);  // search for current list index.
  if old_n < 0 then
    old_n := 0;                                    //??? not in list  ???.

  new_n := get_switch(old_n);    // show selector form and get new index.

  sw_info := Tswitch(switch_select_form.switch_selector_listbox.Items.Objects[new_n]).list_switch_info;

  if set_csi_from_switch_info(sw_info) = False then begin
    // ??? data invalid.
    if set_csi_data(2, 2) = False    // set REA B default if copied data invalid.
    then
      run_error(82);        // ?????? no B switch in list?
  end;

  csi.joggled_stock_rail := switch_select_form.joggled_checkbox.Checked;
  // he might have changed it from the default.

  gocalc(0, 0);     // calc new pegx.

  peg_curve;            // adjust shifts and rotates for current peg position.
  redraw_pad(True, True);
end;
//__________________________________________________________________________________________

function check_radius(warn: boolean; var r: double): boolean;
  // return true if curving radius was within limits.
  // otherwise force it there and return false.
begin
  Result := True;         // init return.

  if Abs(r) > max_rad_limit then begin
    if r >= 0 then
      r := max_rad_limit
    else
      r := 0 - max_rad_limit;
    Result := False;
    if warn = True then
      alert(6, '    invalid  radius', '||The maximum valid radius is ' +
        round_str(max_rad_limit, 0) + ' mm.' + '||( That is a radius of one hundred kilometres' +
        ' - more than sixty miles - which is effectively DEAD STRAIGHT in this context.)',
        '', '', '', '', '', 'O K  -  continue', 0);
    EXIT;
  end;

  if Abs(r) < (g * 2) then begin
    if r >= 0 then
      r := g * 2
    else
      r := 0 - g * 2;
    Result := False;
    if warn = True then
      alert(6, '    invalid  radius',
        '||The minimum valid radius for the track centre-line is double the current track gauge.' +
        '||i.e. current minimum valid radius = ' + round_str(g * 2, 2) + ' mm.',
        '', '', '', '', '', 'O K  -  continue', 0);
    EXIT;
  end;
end;
//_____________________________________________________________________________________

procedure xingoffset(aq: ERailData; gauge_mod: double);
// return ys and ks for turnout curve/crossing

// used for timbering, peg, rail-joints, debug, etc.

// !!! switch joggle (if any) is ignored.
// !!! enter with aq=2 or aq=3.
// !!! enter with xe=end of turnout curve.

// N.B. aq 2 or 3 only are valid here.

begin
  //081  with cpi do begin
  ys := 0;      // default init.
  ks := 0;
  if (aq <> eRD_CurvedTurnoutWingGaugeFace) and (aq <> eRD_CurvedStockGaugeFace) then
    EXIT;    // !!!

  if (xs < xe) or (xing_calc_i = 1) then
    ys := radcurve(aq,{0,0,}xs{,1})
  // turnout rad part or curviform V-crossing runs on through.
  else begin
    if (xs > retx {csrendx}) and (retpar_i = 1) and (xs > fpx) then begin
      retrmod := gauge_mod - g / 2;               // retr rad is to centre-line.
      ys := returncurve(xs, retrmod);          // return curve part
    end
    else begin
      if xing_calc_i = -1        // generic crossing  - bug fix 27-5-01.
      then begin
        case aq of
          eRD_CurvedTurnoutWingGaugeFace:
            ys := g + (xs - fpx) / k3n;                // calc along straight crossing at this x.
          eRD_CurvedStockGaugeFace:
            ys := g + g * COS(k3) + (xs - csrfpx) / k3n;
        end;//case
      end
      else begin      // regular crossing
        xb := xe;
        // end of turnout curve = start of
        ys := turnoutst_main(aq, xb, xe, xs);   // straight crossing part.
      end;
      ks := k3;               // gradient angle constant.
    end;
  end;
  //081  end;//with cpi
end;
//______________________________________________________________________________________

function aq2offset(xtb: double; var k: double): double;
  //  general utility - return offset at any xtb
  //  along curved turnout rail (gauge-face, aq=2). Enter with xtb.
  //  also returns gradient angle in k.

  // The only rail edges which use these routines are
  // wing rails and check rails.
  // also used for timbering, peg, rail-joints, debug, chairs, etc.
  // !!! switch joggle (if any) is ignored.

var
  xxs, yys, kks, xxb, xxe: double;
  segment_index: integer;

begin
  // save these globals for caller...
  xxs := xs;
  yys := ys;
  kks := ks;
  xxb := xb;
  xxe := xe;

  xs := xtb;

  if half_diamond = True  // mods 22-09-04 ...
  then begin
    xb := seg_termx[3, eRD_CurvedTurnoutWingGaugeFace];
    // segment_index=3, h-d all on turnout curve.
    xe := seg_termx[4, eRD_CurvedTurnoutWingGaugeFace];
    xingoffset(eRD_CurvedTurnoutWingGaugeFace, 0);      // get ys,ks for aq=2.
  end
  else begin
    segment_index := 1;   // start search for current rail segment at toex.

    repeat
      xb := seg_termx[segment_index, eRD_CurvedTurnoutWingGaugeFace];
      // start x for this segment.
      xe := seg_termx[segment_index + 1, eRD_CurvedTurnoutWingGaugeFace];
      // end x for this segment
      if (xs < xe) or (segment_index = 3) then
        BREAK;
      Inc(segment_index);
    until 0 <> 0;

    case segment_index of
      //0: toe(2);
      1:
        case switch_type of
          -1:
            straight_planing(eRD_CurvedTurnoutWingGaugeFace, False);    // semi-curved switch.
          0:
            swcurve(eRD_CurvedTurnoutWingGaugeFace, False);
          // for straight switch or curved switch, the planing is part of the switch curve.
          1:
            double_curved_planing(eRD_CurvedTurnoutWingGaugeFace);
            // double-curved switch planing.
          else
            run_error(68);
        end;//case
      2:
        swcurve(eRD_CurvedTurnoutWingGaugeFace, False);
      3:
        xingoffset(eRD_CurvedTurnoutWingGaugeFace, 0);      // aq=2.
      else
        run_error(82);
    end;//case
  end;

  Result := ys;
  k := ks;
  // restore these for caller...
  xs := xxs;
  ys := yys;
  ks := kks;
  xb := xxb;
  xe := xxe;
end;
//_______________________________________________________________________________________________________________________________

function aq3offset(xtb: double; var k: double): double;
  //  general utility - return offset at any xtb
  //  along curved stock rail (gauge-face, aq=3). Enter with xtb.
  //  also returns gradient angle in k.

  // The only rail edges which use these routines are
  // wing rails and check rails.
  // also used for timbering, peg, rail-joints, debug, etc.

  // !!! switch joggle (if any) is ignored.
  // !!! switch joggle (if any) is ignored.

var
  xxs, yys, kks, xxb, xxe: double;
  segment_index: integer;

begin
  // save these globals for caller...
  xxs := xs;
  yys := ys;
  kks := ks;
  xxb := xb;
  xxe := xe;

  xs := xtb;

  if half_diamond = True  // mods 22-09-04...
  then begin
    xb := seg_termx[3, eRD_CurvedStockGaugeFace];   // segment_index=3, h-d all on turnout curve.
    xe := seg_termx[4, eRD_CurvedStockGaugeFace];
    xingoffset(eRD_CurvedStockGaugeFace, g);  // get ys,ks for aq=3.
  end
  else begin

    segment_index := 0;     // turnout - start search for current rail segment.

    repeat
      xb := seg_termx[segment_index, eRD_CurvedStockGaugeFace];
      // start x for this segment.
      xe := seg_termx[segment_index + 1, eRD_CurvedStockGaugeFace];
      // end x for this segment.
      if (xs < xe) or (segment_index = 3) then
        BREAK;
      Inc(segment_index);
    until 0 <> 0;

    case segment_index of
      0:
        toe(eRD_CurvedStockGaugeFace);
      1:
        case switch_type of
          -1:
            straight_planing(eRD_CurvedStockGaugeFace, False);      // semi-curved switch.
          0:
            swcurve(eRD_CurvedStockGaugeFace, False);
          // for straight switch or curved switch, the planing is part of the switch curve.
          1:
            double_curved_planing(eRD_CurvedStockGaugeFace);       // double-curved switch planing.
          else
            run_error(68);
        end;//case
      2:
        swcurve(eRD_CurvedStockGaugeFace, False);
      3:
        xingoffset(eRD_CurvedStockGaugeFace, g);     // aq=3
      else
        run_error(83);
    end;//case
  end;

  Result := ys;
  k := ks;

  // restore these for caller...
  xs := xxs;
  ys := yys;
  ks := kks;
  xb := xxb;
  xe := xxe;
end;
//_______________________________________________________________________________________________________________________________

procedure get_cpi;         // copy current prototype info from current list.

// scale not changed - only done via gauge_dims.
begin
  with cpi do begin
    g := gauge_pi;        // mm.
    fw := fw_pi;           // mm flangeway.
    fw_end := fwe_pi;          // mm flangeway end (flangeway+flare).
    xing_flare_len := xing_fl_pi;      // mm length of flares (not h-d).
    railtop := railtop_pi;      // mm width of rail head.
    railbottom := railbottom_pi;   // mm width of rail foot for flatbottom rail.
    trtscent := trtscent_pi;     // mm track centres, turnout side.
    trmscent := trmscent_pi;     // mm ditto, main side.
    retcent := retcent_pi;      // mm ditto, return curve.
    min_radius := min_radius_pi;   // mm minimum radius for check (30" approx).

    rail_height := rail_height_pi;   // full-size inches - height of rail.

    // these are for 3-D in DXF...

    seat_thick := seat_thick_pi;
    // full-size inches - chair seating thickness. (for 3D in DXF).
    rail_inclination := rail_inclination_pi;    // radians (1:20).
    foot_height := foot_height_pi;         // 7/16" inches full-size  edge thickness.

    chair_outlen := chair_outlen_pi;    // 9.25 inches full-size  from rail gauge-face
    chair_inlen := chair_inlen_pi;     // 5.25 inches full-size
    chair_width := chair_width_pi;     // 8 inches full-size
    chair_corner := chair_corner_pi;    // 1 inch full-size  corner rad.

    timber_thick := timber_thick_pi;    // 5 inches full-size timber thickness.

    // wing and check rails...

    wing_reach1 := wing_ms_reach1_pi;
    // full-size inches - size 1 wing rail reach length (forward from "A").
    wing_reach2 := wing_ms_reach2_pi;
    // full-size inches - size 2 wing rail reach length (forward from "A").

    // 0.94.a no longer used, mouse diffs instead.  wing_ts_reach_mod:= wing_ts_reach_mod_pi; // full-size inches - TS wing rail reach length modifier.


    ck_working1 := ck_ms_working1_pi;
    // full-size inches - size 1 check rail working length (back from "A").
    ck_working2 := ck_ms_working2_pi;
    // full-size inches - size 2 check rail working length (back from "A").
    ck_working3 := ck_ms_working3_pi;
    // full-size inches - size 3 check rail working length (back from "A").

    // 0.94.a no longer used, mouse diffs instead.  ck_ts_working_mod:= ck_ts_working_mod_pi; // full-size inches - TS check rail working length modifier.

    ck_ext1 := ck_ms_ext1_pi;
    // full-size inches - size 1 check rail extension length (forward from "A").
    ck_ext2 := ck_ms_ext2_pi;
    // full-size inches - size 2 check rail extension length (forward from "A").

    // 0.94.a no longer used, mouse diffs instead.  ck_ts_ext_mod:=     ck_ts_ext_mod_pi;     // full-size inches - TS check rail extension length modifier.

    // set up old check/wing data for file (no turnout-side mods - aligned with end of wing rail)...

    old_winglongs_pi := wing_reach1;
    // inches full-size length of short wing rail from centre of timber A.
    old_winglongl_pi := wing_reach2;
    // inches full-size length of long wing rail from centre of timber A.

    old_cklongs_pi := ck_working1 + wing_reach1;
    // inches full-size length of short check rails.
    old_cklongm_pi := ck_working2 + wing_reach1;
    // inches full-size length of medium check rails.
    old_cklongl_pi := ck_working2 + wing_reach2;
    // inches full-size length of long check rails.
    old_cklongxl_pi := ck_working3 + wing_reach2;
    // inches full-size length of extra-long check rails.


    tbwide := tbwide_pi;       // inches full-size width of turnout timbers.
    slwide := slwide_pi;       // inches full-size width of plain sleepers.
    jt_slwide := jt_slwide_pi; // joint sleepers 212a

    //xtimbsp:=   xtimbsp_pi;    // !!! disused in 0.75.a 14-10-01. inches full-size timber-spacing at crossing.
    ftimbspmax := ftimbspmax_pi;   // inches full-size max timber-spacing for closure space.

    tb := tb_pi;           // plain sleepers length.

    if Abs(tb - 108 * inscale) < minfp then begin
      nine_foot := True;
      eight_foot_six := False;
      pad_form.sleepers_9ft_menu_entry.Checked := True;    // radio item.
    end
    else begin
      nine_foot := False;                        // non 9ft-standard length.
      if Abs(tb - 102 * inscale) < minfp then begin
        pad_form.sleepers_8ft6in_menu_entry.Checked := True;        // radio item.
        eight_foot_six := True;
      end
      else begin
        pad_form.sleepers_otherlength_menu_entry.Checked := True;   // radio item.
        eight_foot_six := False;
      end;
    end;
    // mods 11-5-01 v:0.71.a...

    ms_ends := mainside_ends_pi;    //  True=main side ends in line, False=ends centralized.

    randend := random_end_pi;       //  amount of timber-end randomising.
    randangle := random_angle_pi;   //  amount of timber_angle randomising.

    if (randend <> 0) or (randangle <> 0) then
      random_flag := True
    else
      random_flag := False;

  end;//with
end;
//___________________________________________________________________________________________

function gauge_dims(from_list, mod_rads, mod_gauge_data: boolean): double;
  // set up gauge and scale from selected item in list.

  // return ratio between old and new scales.

var
  old_cg: Tproto_info;
  mod_scale_ratio, mod_gauge_ratio: double;
  i, n, sz: integer;

begin

  Result := 1.0;     // default init.

  old_cg := cpi;   // !! may not have been initialised.

  if from_list = True         // copy to current from the gauge list
  then begin
    with gauge[gauge_i] do begin
      with cpi do begin

        //list_str_pi:=list_str_glist;                           // full list string.

        name_str_pi := name_str_glist;

        scale_pi := scale_glist;            // mm/ft.
        gauge_pi := gauge_glist;            // mm.
        fw_pi := fw_glist;                  // mm flangeway.
        fwe_pi := fwe_glist;                // mm flangeway end (flangeway+flare).

        trtscent_pi := trtscent_glist;      // mm track centres, turnout side.
        trmscent_pi := trmscent_glist;      // mm ditto, main side.
        min_radius_pi := min_radius_glist;  // mm minimum radius for check.

        // and use defaults for these when changing gauge via the list...

        // new check and wing dimensioning : v:0.71.a 25-5-01...

        ck_ms_working1_pi := def_req;
        // full-size  78 inches - size 1 MS check rail working length (back from "A").
        ck_ms_working2_pi := def_req;
        // full-size 108 inches - size 2 MS check rail working length (back from "A").
        ck_ms_working3_pi := def_req;
        // full-size 138 inches - size 3 MS check rail working length (back from "A").

        ck_ms_ext1_pi := def_req;
        // full-size 48 inches - size 1 MS check rail extension length (forward from "A").
        ck_ms_ext2_pi := def_req;
        // full-size 78 inches - size 2 MS check rail extension length (forward from "A").

        wing_ms_reach1_pi := def_req;
        // short wing rails 48" default from centre of "A" timber.
        wing_ms_reach2_pi := def_req;
        // long wing rails 78" default from centre of "A" timber.

        // old wing and check settings (put in file for compatibility with earlier versions than 0.71.a)...

        old_winglongs_pi := def_req;     // default 4'0" short wing rails.
        old_winglongl_pi := def_req;     //   ditto 6'6" long wing rails.

        old_cklongs_pi := def_req;     // default 10'6" short check rails.
        old_cklongm_pi := def_req;     //  ditto 13'0" medium check rails.
        old_cklongl_pi := def_req;     //  ditto 15'6" long check rails.
        old_cklongxl_pi := def_req;    //  ditto 18'0" extra-long check rails.

        xing_fl_pi := def_req;     // default 3'0" flare on wing/check rails (not h-d).
        railtop_pi := def_req;     // default rail head width, scale 2.75".
        railbottom_pi := def_req;
        // default flatbottom base, scale 5.5" (FB-109, BS-110A, BS-113A). 11-5-01.
        rail_height_pi := def_req; // default railheight.

        // for 3D in DXF...

        seat_thick_pi := def_req;          // 1.750 inches full-size chair seating thickness.
        rail_inclination_pi := def_req;    // radians (1:20).
        foot_height_pi := def_req;         // 7/16" inches full-size  edge thickness.

        chair_outlen_pi := def_req;    // 9.25 inches full-size  from rail gauge-face
        chair_inlen_pi := def_req;     // 5.25 inches full-size
        chair_width_pi := def_req;     // 8 inches full-size
        chair_corner_pi := def_req;    // 1 inch full-size  corner rad.

        timber_thick_pi := def_req;    // 5 inches full-size timber thickness.


        retcent_pi := def_req;     // default return curve track centres 11'2"

        tbwide_pi := def_req;      // 12" wide turnout timbers.
        slwide_pi := def_req;      // 10" wide plain sleepers.

        jt_slwide_pi := def_req_single;  // 10" wide joint sleepers.  212a

        xtimbsp_pi := def_req;
        // !!! disused in 0.75.a 14-10-01. 30" timber spacing at crossing.
        ftimbspmax_pi := def_req;  // 30" ditto for closure space.

        if (nine_foot = False) and (eight_foot_six = False) and (gauge_i <> t_TT3_i) and
          (gauge_i <> t_TTI_i) and (gauge_i <> t_TTF_i) and (gauge_i <> t_TMS_i) and
          (gauge_i <> t_TMF_i) and (gauge_i <> t_00SF_i) and (gauge_i <> t_00BF_i) and
          (gauge_i <> t_00H0_i) and (gauge_i <> t_00DGF_i) and (gauge_i <> t_00DGI_i) and
          (gauge_i <> t_00BRMSB_i)

        // changing from an odd size to one which is not TT or 00...
        then begin
          i := alert(4, '    non-standard  timber  length ?',
            'The existing nominal timber length is ' + round_str(tb / inscale, 2) +
            ' inches, which is non-standard (not 9ft or 8ft 6in, i.e. 108 or 102 inches).' +
            '||Do you want to use this timber length for the new ' + Trim(name_str_glist) +
            ' gauge/scale setting?', '', '', 'yes  -  use  this  length',
            'no  -  change  to  8ft 6ins  nominal  timber length', '',
            'no  -  change  to  9ft  nominal  timber length', 0);
          case i of
            4: begin
              eight_foot_six := True;
              nine_foot := False;
            end;
            6: begin
              eight_foot_six := False;
              nine_foot := True;
            end;
          end;//case
        end;

        tb_pi := def_req;          // default timbering.
        old_tb_pi := tb / inscale;
        // full-size inches - used internally for gauge changes (no meaning in file).

        // mods 11-5-01 v:0.71.a...

        random_end_pi := def_req;             // no timber-end randomising.
        random_angle_pi := def_req;           // no timber_angle randomising.

        mainside_ends_pi := pad_form.timbers_in_line_menu_entry.Checked;
        //  timber ends no change.

      end;//with cpi

    end;//with
  end;

  if ABS(cpi.scale_pi - scale) > minfp then
    print_timber_numbers_font.Assign(set_font('Arial', Round(cpi.scale_pi + 3), [], clBlack));
  // (scale+3 arbitrary) default for this changes with scale (he might change it later).

  scale := cpi.scale_pi;             // mm per ft.
  if scale = 0 then
    run_error(24);
  // no data for this gauge_i (is this startup? otherwise should have been caught by the form).
  inscale := scale / 12.0;             // mm per inch.

  reset_defaults;  //  to use the new settings.

  gauge_str := cpi.name_str_pi;          //  current gauge name.

  if from_list = True                //  change of gauge, so...
  then begin
    if (initdone_flag = True)   // can't test old_cg if not.
    then begin
      if (old_cg.scale_pi > minfp) and (old_cg.gauge_pi > minfp) and (mod_rads = True)
      // not startup (old scale=0)
      then begin
        // re-scale existing radii...

        mod_scale_ratio := scale / old_cg.scale_pi;
        mod_gauge_ratio := g / old_cg.gauge_pi;

        mod_gauge_ratio := mod_scale_ratio;
        //!!!! experiments with separate ratios cancelled 21-1-01. Results not encouraging.

        Result := mod_gauge_ratio;
        // return ratio for pegging calcs onto notch on gauge change.

        if grid_labels_code_i = 3
        // proto-feet on pad grid.  0.79.a  23-05-06
        then begin
          grid_spacex := grid_spacex * mod_gauge_ratio;
          grid_spacey := grid_spacey * mod_gauge_ratio;
        end;

        // scale rads unless straight...

        if ABS(nomrad) < max_rad_test then
          nomrad := nomrad * mod_gauge_ratio;
        if ABS(nomrad1) < max_rad_test then
          nomrad1 := nomrad1 * mod_gauge_ratio;
        if ABS(nomrad2) < max_rad_test then
          nomrad2 := nomrad2 * mod_gauge_ratio;

        check_radius(False, nomrad);  // don't need function return value.
        check_radius(False, nomrad1); // don't need function return value.
        check_radius(False, nomrad2); // don't need function return value.

        os := os * mod_gauge_ratio;
        tst := tst * mod_gauge_ratio;
        slew_s := slew_s * mod_gauge_ratio;
        slew_l := slew_l * mod_gauge_ratio;
        slew := slew * mod_gauge_ratio;

        xorg := xorg * mod_gauge_ratio;
        turnoutx := turnoutx * mod_gauge_ratio;
        // (max checked in reset_defaults for new incx).

        pegx := pegx * mod_gauge_ratio;
        if (peg_code = -1) or (peg_code = -2) then
          pegy := pegy * mod_gauge_ratio;

        startx := startx * mod_gauge_ratio;       // blanking.

        screenx_max := 100000 * scale;
        // 100000ft scale max zoom-out.             215a  was 10000ft  (increase for large tiled maps)

        if mod_gauge_data = True
        // we are not not minting, so overwrite list data for these...

        //!!! scale ratio, not gauge, otherwise converting to say 00/H0 would produce much underscale centres.
        then begin
          // don't change the names, gauge, scale, flangeways, etc...
          // 0.82.a don't change min_rad for warning.

          with cpi do begin

            if old_cg.xing_fl_pi <> def_req then
              xing_fl_pi := old_cg.xing_fl_pi * mod_scale_ratio;
            // mm length of flares.

            if old_cg.railtop_pi <> def_req then
              railtop_pi := old_cg.railtop_pi * mod_scale_ratio;
            // mm width of rail top (and bottom if bullhead).
            if old_cg.railbottom_pi <> def_req then
              railbottom_pi := old_cg.railbottom_pi * mod_scale_ratio;
            // mm width of railfoot (FB).

            if old_cg.trtscent_pi <> def_req then
              trtscent_pi := old_cg.trtscent_pi * mod_scale_ratio;
            // mm track centres, turnout side.
            if old_cg.trmscent_pi <> def_req then
              trmscent_pi := old_cg.trmscent_pi * mod_scale_ratio;    // mm ditto, main side.
            if old_cg.retcent_pi <> def_req then
              retcent_pi := old_cg.retcent_pi * mod_scale_ratio;     // mm ditto, return curve.

            // out 0.82.a  if old_cg.min_radius_pi  <>def_req then   min_radius_pi:=old_cg.min_radius_pi*mod_scale_ratio;  // mm minimum radius for check.

            // then these are in full-size inches, or angles, so no need to use the scale ratio...

            if old_cg.rail_height_pi <> def_req then
              rail_height_pi := old_cg.rail_height_pi;
            // full-size inches - rail height (for 3D in DXF).
            if old_cg.seat_thick_pi <> def_req then
              seat_thick_pi := old_cg.seat_thick_pi;
            // full-size inches - chair seating thickness (for 3D in DXF).

            if old_cg.rail_inclination_pi <> def_req then
              rail_inclination_pi := old_cg.rail_inclination_pi;   // radians.
            if old_cg.foot_height_pi <> def_req then
              foot_height_pi := old_cg.foot_height_pi;        // inches full-size  edge thickness.

            if old_cg.chair_outlen_pi <> def_req then
              chair_outlen_pi := old_cg.chair_outlen_pi;
            // inches full-size  from rail centre-line
            if old_cg.chair_inlen_pi <> def_req then
              chair_inlen_pi := old_cg.chair_inlen_pi;     // inches full-size
            if old_cg.chair_width_pi <> def_req then
              chair_width_pi := old_cg.chair_width_pi;     // inches full-size
            if old_cg.chair_corner_pi <> def_req then
              chair_corner_pi := old_cg.chair_corner_pi;    // inches full-size  corner rad.

            if old_cg.timber_thick_pi <> def_req then
              timber_thick_pi := old_cg.timber_thick_pi;    // inches full-size timber thickness.


            if old_cg.ck_ms_working1_pi <> def_req then
              ck_ms_working1_pi := old_cg.ck_ms_working1_pi;
            // full-size inches - size 1 MS check rail working length (back from "A").
            if old_cg.ck_ms_working2_pi <> def_req then
              ck_ms_working2_pi := old_cg.ck_ms_working2_pi;
            // full-size inches - size 2 MS check rail working length (back from "A").
            if old_cg.ck_ms_working3_pi <> def_req then
              ck_ms_working3_pi := old_cg.ck_ms_working3_pi;
            // full-size inches - size 3 MS check rail working length (back from "A").

            if old_cg.ck_ms_ext1_pi <> def_req then
              ck_ms_ext1_pi := old_cg.ck_ms_ext1_pi;
            // full-size inches - size 1 MS check rail extension length (forward from "A").
            if old_cg.ck_ms_ext2_pi <> def_req then
              ck_ms_ext2_pi := old_cg.ck_ms_ext2_pi;
            // full-size inches - size 2 MS check rail extension length (forward from "A").

            if old_cg.wing_ms_reach1_pi <> def_req then
              wing_ms_reach1_pi := old_cg.wing_ms_reach1_pi;
            // full-size inches - size 1 MS wing rail reach length (forward from "A").
            if old_cg.wing_ms_reach2_pi <> def_req then
              wing_ms_reach2_pi := old_cg.wing_ms_reach2_pi;
            // full-size inches - size 2 MS wing rail reach length (forward from "A").


            if old_cg.tbwide_pi <> def_req then
              tbwide_pi := old_cg.tbwide_pi;      // inches full-size width of turnout timbers.
            if old_cg.slwide_pi <> def_req then
              slwide_pi := old_cg.slwide_pi;      // inches full-size width of plain sleepers.

            if old_cg.jt_slwide_pi <> def_req_single then
              jt_slwide_pi := old_cg.jt_slwide_pi;
            // inches full-size width of joint sleepers. 212a

            if old_cg.xtimbsp_pi <> def_req then
              xtimbsp_pi := old_cg.xtimbsp_pi;
            //  !!! disused in 0.75.a 14-10-01.inches full-size timber-spacing at crossing.
            if old_cg.ftimbspmax_pi <> def_req then
              ftimbspmax_pi := old_cg.ftimbspmax_pi;
            // inches full-size max timber-spacing for closure space.

            if old_cg.random_end_pi <> def_req then
              random_end_pi := old_cg.random_end_pi;
            // inches full-size amount of timber-end randomising.

            if old_cg.random_angle_pi <> def_req then
              random_angle_pi := old_cg.random_angle_pi;   // amount of timber_angle randomising.

            // timber length not modified - done via old_tb_pi in reset_defaults if necessary.

          end;//with

          get_cpi;      // use these modified values.

          for n := 0 to current_shove_list.Count - 1 do begin
            // rescale (!!! scale ratio, not gauge) the timber shove dims ...
            current_shove_list[n].rescale(mod_scale_ratio);
          end;//for


          with ccd do begin
            // 0.94.a check-rail end-gap modifiers (mm)

            // (length modifiers are in full-size inches and don't need changing )

            end_diff_mw.gap_diff :=
              end_diff_mw.gap_diff * mod_scale_ratio;
            end_diff_me.gap_diff :=
              end_diff_me.gap_diff * mod_scale_ratio;
            end_diff_mr.gap_diff :=
              end_diff_mr.gap_diff * mod_scale_ratio;

            end_diff_tw.gap_diff :=
              end_diff_tw.gap_diff * mod_scale_ratio;
            end_diff_te.gap_diff :=
              end_diff_te.gap_diff * mod_scale_ratio;
            end_diff_tr.gap_diff :=
              end_diff_tr.gap_diff * mod_scale_ratio;

            end_diff_mk.gap_diff :=
              end_diff_mk.gap_diff * mod_scale_ratio;
            end_diff_dk.gap_diff :=
              end_diff_dk.gap_diff * mod_scale_ratio;

          end;//with

        end;// if mod data.
      end;// if mod rads
    end;// if initdone

    incx := def_req;              // x increment.

    ring_dia := def_req;

    peg_arm_length := def_req;

    if (g <> def_req) and (g < 47.9 * inscale) and (csi.group_code = 2)
    // n.g. now selected with current REA switch
    then begin
      sz := csi.size_code;
      if sz > 1 then
        sz := sz - 1;       // use next shorter size,
      if set_csi_data(1, sz) = False
      // change to straight switch and set new switch data from listbox entries.
      then
        run_error(77);
    end;
  end;

end;
//________________________________________________________________________________________

procedure rescale_notch(ratio: double);

begin
  notchx := notchx * ratio;
  notchy := notchy * ratio;
end;
//________________________________________________________________________________________

procedure quick_gauge_click(i: integer);   // quick change of gauge and scale.

var
  mod_ratio: double;
  not_mint: boolean;

begin
  not_mint := not gauge_form.mint_new_radio_button.Checked;

  if not_mint = True then
    new_notch(get_peg_for_notch, False); // so can put the new template back on it.

  gauge_i := i;                                 //  set new gauge index,
  mod_ratio := gauge_dims(True, True, not_mint);  //  and get new dimensions.

  set_y_datum;                 //  need to change the pad datum.
  redraw(False);               //  force immediate redraw.

  if not_mint = True then begin
    rescale_notch(mod_ratio);
    shift_onto_notch(False, False);
  end
  else begin
    if gauge_form.retain_length_checkbox.Checked = True   // 208d test added, was (0)
    then
      mint_new_current(1)
    else
      mint_new_current(0);
  end;

  redraw(True);
end;
//________________________________________________________________________________________

function get_spiral_length(k_rads: double): double;      // 0.71.a  13-4-01.

  // return length of transition curve template for given k_rads angular swing.
  // !! length is from template datum, not transition origin.

begin
  Result := turnoutx;     // default init.

  if (spiral = False) and (slewing = False)      // shouldn't be here by rights!
  then begin
    Result := k_rads * nomrad;
    EXIT;
  end;

  length_in_degs := k_rads;      // init for calc.

  wait_cancel_clicked := False;
  wait_form.cancel_button.Show;
  wait_form.waiting_label.Caption := 'calculating ...';

  wait_form.waiting_label.Width := wait_form.Canvas.TextWidth(wait_form.waiting_label.Caption);
  // 205b bug fix for Wine

  pad_form.trans_calc_timer.Tag := 15;       // do the calcs while the wait message shows modal.
  pad_form.trans_calc_timer.Enabled := True; // one-shot only to start the process.

  do_show_modal(wait_form);  // 212a   ShowModal

  if Application.Terminated = False then
    Application.ProcessMessages;

  // returns here when the wait form closes...

  case pad_form.trans_calc_timer.Tag of
    -1:
      EXIT;  // he cancelled  - leave template as it is.

    0: begin
      alert(5, '    calculation  failed',
        'Sorry, the angular swing calculations have failed to produce a result.' +
        '||The most likely reason is that you entered a swing angle in the wrong direction.' +
        '||For negative curving or a negative slew (in the opposite direction to the hand of the template), the swing angle is also negative.' + '||Alternatively, your specified swing angle may be invalid for the current transition curve and/or slewing settings.',
        '', '', '', '', '', 'continue', 0);
      EXIT;
    end;

    1:
      Result := length_in_mm;
  end;//case
end;
//________________________________________________________________________________________

function do_degs_length_adjust(length_in_degs: double; var length_in_mm: double): integer;

  // this code moves the template overall length to and fro in reducing steps
  // until the total angular swing matches length_in_degs.

  // Return 1 if valid result, 0 if calc error, or -1 if he clicks cancel.

var
  dir, len_step: double;
  saved_turnoutx, saved_xorg: double;
  swing_start, swing_dir: double;
  diff_swing_start: double;

begin
  Result := 0;                   // default init..
  saved_turnoutx := turnoutx;
  saved_xorg := xorg;
  length_in_mm := turnoutx;
  turnout_i := 1;      // length locked at new turnoutx.

  try
    do_rollback := False;
    gocalc(0, 0);
    swing_start := total_swing;

    if ABS(length_in_degs - total_swing) < minfp   // already there.
    then begin
      Result := 1;
      EXIT;
    end;

    // trial start to set direction...

    turnoutx := turnoutx + scale;   // step along 1ft scale (arbitrary).
    if turnoutx < 0 then
      EXIT;                        // calc failed.
    if turnoutx > turnoutx_max then
      EXIT;             // calc failed.
    if xorg > turnoutx then
      xorg := turnoutx;

    do_rollback := False;
    gocalc(0, 0);                   // fresh calc sets new total swing.

    diff_swing_start := total_swing - swing_start;

    if ABS(diff_swing_start) < minfp then
      EXIT;  // calc failed - swing not changing with length changes.

    swing_dir := 1;                              // swing increases with increasing length.
    if diff_swing_start < 0 then
      swing_dir := -1;  // or swing reduces with increasing length.

    // reset and start again...

    turnoutx := saved_turnoutx;
    xorg := saved_xorg;

    dir := 1;                // start by going forward.
    len_step := 10 * scale;    // 10ft scale arbitrary  initial step-size.
    if len_step > (saved_turnoutx / 4) then
      len_step := saved_turnoutx / 4;   // 1/4 arbitrary.

    if ((length_in_degs < swing_start) and (swing_dir = 1))   // or start by going backwards.
    then begin
      dir := -1;
      len_step := 0 - len_step;
    end;

    repeat

      do_rollback := False;
      turnoutx := turnoutx + len_step * swing_dir;           // step along.
      if turnoutx < 0 then
        BREAK;                        // calc failed.
      if turnoutx > turnoutx_max then
        BREAK;             // calc failed.
      if xorg > turnoutx then
        xorg := turnoutx;

      gocalc(0, 0);                   // fresh calc sets new total swing.

      if ABS(total_swing - length_in_degs) < 0.00001   // arbitrary tolerance.
      then begin
        length_in_mm := turnoutx;
        Result := 1;
        EXIT;
      end;

      if ((dir = 1) and (total_swing > length_in_degs))   // gone too far..
        or ((dir = -1) and (total_swing < length_in_degs)) then begin
        len_step := 0 - len_step / 10;     // change direction and use smaller steps.
        dir := 0 - dir;
      end;
      // try again..

      if Application.Terminated = False then
        Application.ProcessMessages;  // allow him to click.

      if wait_cancel_clicked = True   // he cancelled.
      then begin
        Result := -1;
        EXIT;
      end;

    until (((dir * swing_dir) = 1) and (turnoutx > turnoutx_max)) or
      (((dir * swing_dir) = -1) and (turnoutx < 0));
    // will take forever, but we must have a limit of some sort.

    if Result = 0         // reset and start again with oppopsite sign of required swing...
    // (this is his most likely error).
    then begin
      length_in_degs := 0 - length_in_degs;  // required swing

      turnoutx := saved_turnoutx;
      xorg := saved_xorg;

      dir := 1;                // start by going forward.
      len_step := 10 * scale;    // 10ft scale arbitrary  initial step-size.
      if len_step > (saved_turnoutx / 4) then
        len_step := saved_turnoutx / 4;   // 1/4 arbitrary.

      if ((length_in_degs < swing_start) and (swing_dir = 1))   // or start by going backwards.
      then begin
        dir := -1;
        len_step := 0 - len_step;
      end;

      repeat

        do_rollback := False;
        turnoutx := turnoutx + len_step * swing_dir;
        // step along in direction to get increasing swing.
        if turnoutx < 0 then
          EXIT;                        // calc entirely failed.
        if turnoutx > turnoutx_max then
          EXIT;             // calc entirely failed.
        if xorg > turnoutx then
          xorg := turnoutx;

        gocalc(0, 0);                   // fresh calc sets new total swing.

        if ABS(total_swing - length_in_degs) < 0.00001   // arbitrary tolerance.
        then begin
          length_in_mm := turnoutx;
          Result := 1;
          EXIT;
        end;

        if ((dir = 1) and (total_swing > length_in_degs))   // gone too far..
          or ((dir = -1) and (total_swing < length_in_degs)) then begin
          len_step := 0 - len_step / 10;     // change direction and use smaller steps.
          dir := 0 - dir;
        end;
        // try again..

        if Application.Terminated = False then
          Application.ProcessMessages;  // allow him to click.

        if wait_cancel_clicked = True   // he cancelled.
        then begin
          Result := -1;
          EXIT;
        end;

      until (((dir * swing_dir) = 1) and (turnoutx > turnoutx_max)) or
        (((dir * swing_dir) = -1) and (turnoutx < 0));
      // will take forever, but we must have a limit of some sort.

    end;

  finally
    turnoutx := saved_turnoutx;     // restore original control template.
    xorg := saved_xorg;
  end;//try
end;
//_______________________________________________________________________________________

procedure lengths_click(degs: boolean);

// get xorg, startx and turnoutx lengths ...
const
  startx_help_str: string =
    '||The blanking length is measured from the template datum (the fixing peg RESET position, CTRL-0), towards the crossing and includes the approach track length, if any.' + '||Blanking part of the turnout is useful when superimposing two templates. For example you may want to omit the first two sleepers between the rail-joint and toe (blade tips)' + ' when creating a tandem turnout, or fitting two turnouts close together. Likewise by blanking up to the crossing you can use it as a separate component in a complex formation.' + '||The pre-set dimension is zero, i.e. no blanking.' + '||Note that setting a blanking length does not change the underlying overall length of the turnout, and any blanking is automatically cancelled by some Templot0 functions to avoid confusion.' + '||(e.g. the CONVERT TO PLAIN TRACK function, the SWAP CONTROL END-FOR-END and MAKE DOUBLE TRACK tools, and the ADJUST PLAIN TRACK LENGTH (F4), ADJUST APPROACH LENGTH (F3) and ROAM ALONG LENGTH (CTRL-F9) mouse actions.)' + '||Blanking is not available when drawing plain track. The same effect is obtained more conveniently by simply changing the plain track length (F4 mouse action),' + ' having first set the fixing peg at the opposite end (CTRL-0 or CTRL-1 peg positions).' + '||Blanking is not available when the V-crossing has been isolated.' + '||Handy Hints :' + '|It is easier to set the blanked length by mouse action (ACTION > MOUSE ACTIONS: GEOMETRY > ADJUST BLANKING LENGTH menu item) or by moving the peg to the desired position (with mouse action CTRL-F8)' + ' and then selecting the DO > BLANK UP TO PEG menu item. The blanked length can be increased or reduced this way.' + '||To blank out the part of a turnout beyond the peg (i.e towards the crossing end), select the DO > SNAP TO PEG menu item, or simply reduce the overall length (mouse action F4).' + '||To use the switch as a separate component (as a set of catch points, for example) select the DO > SNAP TO CATCH POINTS menu item.' + '||To cancel blanking, set a blanking length of zero, or select the DO > CANCEL BLANKING menu item.' + '||It is possible to set a negative blanking length. This permits a timber to be shoved out beyond the CTRL-0 datum position, if necessary, but otherwise it has no effect.' + ' Note that if you subsequently cancel blanking, such a shoved timber will become inaccessible.' + '||( Caution: If you blank to beyond the nose of the vee at the crossing, select the PRINT > PRINTED DRAWING OPTIONS > RAIL INFILL STYLE > NONE menu item before printing the template.' + ' Otherwise a risk exists with some printers that the rail colour infill function might fail, possibly wasting coloured ink across a large area of the paper.)';

  xorg_help_str: string =
    '||The approach length is the distance from the CTRL-0 datum position to the CTRL-1 rail-joint position at the toe of the turnout.' + '||The approach length is part of the overall turnout length. If you change the approach length, you will probably want to make a similar amount of change to the overall length.' + '||N.B. For a half-diamond template, there is no approach length, and any dimension entered will be ignored.';

  turnoutx_help_str: string =
    '||If you have made a change to the approach length you will probably want to make a similar amount of change to the overall length to maintain the full length of the turnout.' + '||To add a length of exit track to the turnout, increase the overall length accordingly.';

  turnout_road_help_str: string =
    'Turnout-Road Exit Length' +
    '||This dimension applies only when the turnout-road exit length setting is `0GEOMETRY > TURNOUT-ROAD EXIT LENGTH > ADJUSTABLE`1. For other settings this dimension is ignored.' + '||It is usually easier to change this setting by mouse action `0CTRL+F12`2.';  // 209a

  main_road_help_str: string = 'Main-Road Exit Length' +
    '||This dimension applies only when the main-road exit length setting is `0GEOMETRY > MAIN-ROAD EXIT LENGTH > ADJUSTABLE`1. For other settings this dimension is ignored.';

  deg_explain_str: string =
    '||The actual length which this represents will be determined by the current track centre-line radius.'
    + '||To enter the length directly in mm, cancel this and click the GEOMETRY > TEMPLATE LENGTHS (IN MM)... menu item instead.'
    + '||If desired the angle can be entered as a RAM unit value by prefixing the figure with the input conversion letter "n". For example an angular swing of 1:6 can be entered as "n6".' + ' Be aware that unit angles are an inverse measure, a larger unit angle will produce a shorter length.' + ' For more information about about input conversion factors click the ? HELP button.';

  mm_explain_str: string =
    '||For curved templates this length can also be entered as an angular swing in degrees or unit angles. To do so cancel this and click the GEOMETRY > SWING ANGLES (IN DEGREES)... menu item instead.';

  rails_explain_str: string =
    '||For plain track templates the length can also be entered as a number of scale rail lengths. To do so cancel this and click the REAL > PLAIN TRACK OPTIONS > TEMPLATE LENGTH (IN RAILS)... menu item instead.';

var
  n, i: integer;
  od: Toutdim;
  dummy: double;
  deg_factor: double;
  code: integer;
  deg_str: string;
  approach_help_str, overall_help_str, blank_help_str, pt_help_str: string;

  old_xorg: double;

begin
  if degs = True then begin
    deg_str := 'angular  swing';

    approach_help_str := '     Approach  Length' +
      '||Enter a dimension in degrees of angular swing which represents the required length of plain approach track for the current turnout template.' + deg_explain_str + xorg_help_str;

    overall_help_str := '     Overall  Length' +
      '||Enter a dimension in degrees of angular swing which represents the required overall length of the current turnout template including any approach track.' + deg_explain_str + turnoutx_help_str;

    blank_help_str := '     Blanking  Length' +
      '||Enter a dimension in degrees of angular swing which represents the length of your turnout which is required to be blanked out and not appear in the drawing.' + deg_explain_str + startx_help_str;

    pt_help_str := '     Plain Track  Overall  Length' +
      '||Enter a dimension in degrees of angular swing which represents the required overall length of the current plain track template.' + deg_explain_str + rails_explain_str;
  end;


  if ((ABS(nomrad) < max_rad_test) and (spiral = False) and (slewing = False)) or (degs = False)
  // fixed curve degs, or mm...
  then begin
    if (degs = True) and (ABS(nomrad) > minfp)    // fixed curve degs...
    then begin
      code := 3;
      deg_factor := 180 / (Pi * ABS(nomrad));
    end
    else begin
      code := 1;
      deg_factor := 1.0;
      deg_str := 'mm';

      approach_help_str :=
        '     Approach  Length' +
        '||Enter a dimension in mm which represents the required length of plain approach track for the current turnout template, measured along the track centre-line.' + mm_explain_str + xorg_help_str;


      overall_help_str :=
        '     Overall  Length' +
        '||Enter a dimension in mm which represents the required overall length of the current turnout template including any approach track.' + mm_explain_str + turnoutx_help_str;

      blank_help_str :=
        '     Blanking  Length' +
        '||Enter a dimension in mm which represents the length of your turnout which is required to be blanked out and not appear in the drawing.' + mm_explain_str + startx_help_str;

      pt_help_str :=
        '     Plain Track  Overall  Length' +
        '||Enter a dimension in mm which represents the required overall length of the current plain track template, measured along the track centre-line.' + mm_explain_str + rails_explain_str;
    end;

    old_xorg := xorg;

    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
    // save current peg data for peg_curve calcs.

    if plain_track = False then
      repeat
        putdim(approach_help_str, code, 'approach  track  length',
          xorg * deg_factor, True, False, False, False);
        // start offset, no neg, preset ok, 0 mm is valid, don't terminate on zero.
        putdim(overall_help_str, code,
          'overall  length  of  turnout  including  approach', turnoutx *
          deg_factor, True, True, True, False);
        // no neg, no preset, no zero, don't terminate on zero.
        putdim(blank_help_str, code, 'blanking  length', startx * deg_factor,
          False, False, False, False);
        // neg ok, preset ok, zero ok, don't terminate on zero.
        putdim(turnout_road_help_str, code,
          'length  to  turnout-road  exit  including  approach',
          (xorg + turnout_road_endx) * deg_factor, True, True, True, False);
        // 209a no neg, no preset, no zero, don't terminate on zero.
        n := putdim(main_road_help_str, code, 'length  to  main-road  exit  including  approach',
          (xorg + main_road_endx) * deg_factor, True, True, True, False);
        // 217a no neg, no preset, no zero, don't terminate on zero.

        if n <> 4 then
          EXIT;
        if getdims('turnout  lengths  in  ' + deg_str, '', pad_form, n, od) = True then begin
          if od[0] = def_req then
            od[0] := 0;     // zero presets..
          if od[2] = def_req then
            od[2] := 0;

          if (od[0] < 0) or (od[1] < 0) or (od[0] > od[1]) or (od[2] > od[1]) or
            ((od[0] / deg_factor) > turnoutx_max) or ((od[1] / deg_factor) > turnoutx_max) or
            ((od[2] / deg_factor) > turnoutx_max) or ((od[3] / deg_factor) > turnoutx_max) or
            ((od[4] / deg_factor) > turnoutx_max) then begin
            i :=
              alert(6, '     one  or  more  invalid  lengths',
              'One or more of the entered dimensions is invalid:' +
              '||The approach length cannot be more than the overall length.' +
              '||The blanking length cannot be more than the overall length.' +
              '||None of the lengths can be more than ' + round_str(turnoutx_max, 2) +
              ' mm.' + '||Only the blanking length can be negative.', '', '',
              '', '', 'cancel', 'O K  -  retry', 0);
            if i = 5 then
              EXIT;
            CONTINUE;
          end;
          if half_diamond = False then
            xorg := ABS(od[0]) / deg_factor
          else
            xorg := 0;
          turnoutx := ABS(od[1]) / deg_factor;
          startx := od[2] / deg_factor;

          turnout_road_endx := (od[3] - xorg) / deg_factor;
          // 209a  stored dim is from CTRL-1

          main_road_endx := (od[4] - xorg) / deg_factor;
          // 217a  stored dim is from CTRL-1

          BREAK;
        end
        else
          EXIT;
      until 0 <> 0
    else begin
      n := putdim(pt_help_str, code, 'overall  length  of  plain  track', xorg *
        deg_factor, True, True, True, False);
      // no neg, no preset, no zero, don't terminate on zero.
      if n <> 0 then
        EXIT;
      if getdims('plain  track  length  in  ' + deg_str, '', pad_form, n, od) = True then begin
        xorg := ABS(od[0]) / deg_factor;
        turnoutx := xorg;

        if turnoutx > turnoutx_max then begin
          turnoutx := turnoutx_max;
          xorg := turnoutx;
        end;
      end;
    end;
  end
  else begin     // transition or slewing in degrees...

    old_xorg := xorg;

    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
    // save current peg data for peg_curve calcs.

    if plain_track = False then begin
      n := putdim(overall_help_str, 3, 'overall  length  of  turnout  including  approach',
        total_swing * 180 / Pi, False, True, False, False);
      // neg ok (s-curve), no preset, zero ok (s-curve), don't terminate on zero.
      if n <> 0 then
        EXIT;
      if getdims('turnout  length  in  ' + deg_str, '', pad_form, n, od) = True then begin
        turnoutx := get_spiral_length(od[0] * Pi / 180);
        if turnoutx < 0 then
          turnoutx := 0;
        if turnoutx > turnoutx_max then
          turnoutx := turnoutx_max;
        if xorg > turnoutx then
          xorg := turnoutx;
      end
      else
        EXIT;
    end
    else begin
      n := putdim(pt_help_str, 3, 'overall  length  of  plain  track',
        total_swing * 180 / Pi, False, True, False, False);
      // neg ok (s-curve), no preset, zero ok (s-curve), don't terminate on zero.
      if n <> 0 then
        EXIT;
      if getdims('plain  track  length  in  ' + deg_str, '', pad_form, n, od) = True then begin
        xorg := get_spiral_length(od[0] * Pi / 180);
        if xorg < 0 then
          xorg := 0;
        turnoutx := xorg;
        if turnoutx > turnoutx_max then begin
          turnoutx := turnoutx_max;
          xorg := turnoutx;
        end;
      end
      else
        EXIT;
    end;
  end;


  if peg_code <> 0 then begin
    if spiral = True then
      os := os + xorg - old_xorg;           //  os transition start changes with xorg ditto.
    if slewing = True then
      slew_s := slew_s + xorg - old_xorg;  //  slewing ditto
  end;

  pegx := pegx - old_xorg + xorg;         // update the peg if free...
  udpegx := udpegx - old_xorg + xorg;

  turnout_i := 1;      // overall length locked at new turnoutx.

  gocalc(0, 0);       //  to calc new pegx.
  peg_curve;         //  adjust shifts and rotates for current peg position.

  do_rollback := True;
  show_and_redraw(True, True);
end;
//_________________________________________________________________________________________

function check_black_white: boolean;
  // return True if he cancels (called from change printer colours).

var
  i, colour_depth_bits: integer;

begin
  Result := False;    // default init.
  try
    { OT-FIRST colour_depth_bits:=GetDeviceCaps(Printer.Handle,BITSPIXEL)*GetDeviceCaps(Printer.Handle,PLANES);}
    colour_depth_bits := 24;  // OT-FIRST

    if colour_depth_bits = 1 then begin
      i := alert(2, '    monochrome  printer',
        'Your current printer is not a colour printer, or has not been set to print in colour.' +
        '||Changes which you make to the printing colours will have no effect until you change to a colour printer.',
        '', '', 'ignore  this  message', 'printer  setup ...', 'cancel', 'O K', 0);
      case i of
        4:
          printer_setup(False, False);
        5:
          Result := True;
      end;//case

      EXIT;
    end;

    if black_white = True then begin
      i := alert(3, '    black & white  printing',
        'You are currently set to print in black and white only.' +
        '||Changes which you make to the printing colours will have no effect until you change to full-colour or grey-shade printing.',
        '', '', 'change  to  grey - shade  printing', 'change  to  full - colour  printing',
        'cancel', 'O K', 0);
      case i of
        3:
          pad_form.grey_shade_printing_menu_entry.Click;
        4:
          pad_form.colour_printing_menu_entry.Click;
        5:
          Result := True;
      end;//case
      EXIT;
    end;

    if grey_shade = True then begin
      i := alert(3, '    grey - shade  printing',
        'You are currently set to print in grey shades.' +
        '||Changes which you make to the printing colours will be converted to shades of grey until you change to full-colour printing.', '', '', '', 'change  to  full - colour  printing', 'cancel', 'O K', 0);
      case i of
        4:
          pad_form.colour_printing_menu_entry.Click;
        5:
          Result := True;
      end;//case
    end;
  finally
    if Result = False then
      print_form.reset_button.Click;
    // reset intensity so that the new print colour can be seen properly.
  end;//try
end;
//_____________________________________________________________________________________________

function clrad_at_x(x: double): double;
  // return the main-road track centre-line radius at this xs.

var
  dummy1, dummy2, dummy3: double;

begin
  Result := max_rad;      // default init for straight track.

  if spiral = True    // currently a transition, so get rad at peg position..
  then begin
    if x > os then begin                         // peg is not in r1.
      if x >= (os + tst)                     // 214a bug fix was x>(
      then
        Result := nomrad2{+ycurv}    // peg is in r2.
      else begin                      // peg is in the transition zone.
        if transcalcs(False, False, trans_k, (x - os + ts1), dummy1, dummy2,
          dummy3, Result) = False then
          Result := nomrad1;  // no change if trans error.
      end;
    end
    else
      Result := nomrad1{+ycurv};             // peg is in r1.
  end
  else
    Result := nomrad{+ycurv};    // fixed curve.

  if ABS(Result) > max_rad then
    Result := max_rad * SGZ(Result);  // in case we just picked up a straight.  212a SGZ added

  if ABS(Result) < (g * 2) then
    Result := g * 2 * SGZ(Result);        // min rad (arbitrary).

end;
//_________________________________________________________________________________________

procedure fix_radius(rad: double; click: boolean);     // set up fixed-radius curving.

var
  dummy: double;

begin
  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  nomrad := rad;

  spiral := False;

  if (peg_code = 200) or (peg_code = 220) then
    gocalc(0, 0);    // to keep peg on geometrical tangent points.

  peg_curve;            // fixed curve turnout on peg.

  gocalc(0, 0);

  if click = True then
    redraw_pad(True, True);
end;
//_______________________________________________________________________________________

procedure transition_clicked(trans_code: integer);

var
  temp, temp_ktrans, existing_rad: double;

begin
  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, temp);
  // save current peg data for peg_curve calcs.

  case trans_code of

    //      0: do nothing, use previous radii and lengths, or startup defaults.


    1: begin    // ease from new straight to existing radius...

      if (spiral = False) and (ABS(nomrad) > (max_rad / 2)) then
        nomrad := 660 * scale;  // change existing straight to 10 chains.
      if (spiral = True) and (ABS(nomrad2) > (max_rad / 2)) then
        nomrad2 := 660 * scale; // change existing straight to 10 chains.

      {                   then begin
                          alert(6,'    both  radii  straight',
                                  'It is not possible to create a transition easement from a straight initial radius because currently the final radius is also straight.',
                                  '','','','','cancel    ','',0);
                          EXIT;
                        end;
}

      nomrad1 := max_rad;                             // first transition radius (straight).
      if spiral = False then
        nomrad2 := nomrad{+ycurv};
      // second transition radius (as current fixed curve centre-line),
      // (but don't change if currently a transition).

      tst := 132 * scale;
      // arbitrary transition length 2 chains (132ft).
      if tst > (turnoutx * 0.95) then
        tst := turnoutx * 0.95;  // arbitrary max 95% template length.

      os := 0;                // length of first radius (straight) (zero)
      //ycurv:=0;             // curving line offset
      //ycurv_def:=0;         // cancel default ycurv.
    end;


    2: begin    // ease to new straight from existing radius...

      if (spiral = False) and (ABS(nomrad) > (max_rad / 2)) then
        nomrad := 660 * scale;  // change existing straight to 10 chains.
      if (spiral = True) and (ABS(nomrad1) > (max_rad / 2)) then
        nomrad1 := 660 * scale; // change existing straight to 10 chains.

      nomrad2 := max_rad;                             // second transition radius (straight).
      if spiral = False then
        nomrad1 := nomrad{+ycurv}; // first transition radius (as current fixed curve centre-line),
      // (but don't change if currently a transition).

      tst := 132 * scale;
      // arbitrary transition length 2 chains (132ft).
      if tst > (turnoutx * 0.95) then
        tst := turnoutx * 0.95; // arbitrary max 95% template length.

      os := turnoutx - tst;
      // length of first radius to give zero length of second(straight).
      //ycurv:=0;             // curving line offset
      //ycurv_def:=0;         // cancel default ycurv.
    end;

    3: begin    // C-curve transition shrinking from existing radius...

      existing_rad := clrad_at_x(pegx);     // set rads from existing radius at peg.

      if peg_code = 0    // CTRL-0, use existing 1st radius.
      then begin
        nomrad1 := existing_rad;

        if ABS(nomrad1) > (max_rad / 2)                // arbitrary (is straight).
        then
          nomrad2 := (660 * scale) * SGZ(nomrad1)  // so transition down to 10 chains.
        else
          nomrad2 := nomrad1 / 2;                // or down to half of 1st radius.
      end
      else begin
        nomrad2 := existing_rad;

        if ABS(nomrad2) > (max_rad / 2)                // arbitrary (is straight).
        then
          nomrad1 := (660 * scale) * SGZ(nomrad2)  // so transition down to 10 chains.
        else
          nomrad1 := nomrad2 / 2;                // or down to half of 2nd radius.
      end;

      tst := turnoutx * 0.6;     // arbitrary transition length 60% of template.
      os := turnoutx * 0.2;      // arbitrary length of first radius 20% of template.
    end;

    4: begin    // C-curve transition expanding from existing radius...

      existing_rad := clrad_at_x(pegx);     // set rads from existing radius at peg.

      if peg_code = 0    // CTRL-0, use existing 1st radius.
      then begin
        nomrad1 := existing_rad;

        if ABS(nomrad1) > (max_rad / 2)                // arbitrary (is straight).
        then
          nomrad2 := (660 * scale) * SGZ(nomrad1)  // so transition down to 10 chains.
        else
          nomrad2 := nomrad1 * 2;                // or up to double 1st radius.
      end
      else begin
        nomrad2 := existing_rad;

        if ABS(nomrad2) > (max_rad / 2)                // arbitrary (is straight).
        then
          nomrad1 := (660 * scale) * SGZ(nomrad2)  // so transition down to 10 chains.
        else
          nomrad1 := nomrad2 * 2;                // or up to double 2nd radius.
      end;

      tst := turnoutx * 0.6;     // arbitrary transition length 60% of template.
      os := turnoutx * 0.2;      // arbitrary length of first radius 20% of template.
    end;

    5: begin    // S-curve reverse transition at existing radius...

      existing_rad := clrad_at_x(pegx);     // set rads from existing radius at peg.

      if peg_code = 0    // CTRL-0, use existing 1st radius.
      then begin
        nomrad1 := existing_rad;

        if ABS(nomrad1) > (max_rad / 2)  // arbitrary (is straight).
        then
          nomrad1 := 660 * scale;  // so use 10 chains.

        nomrad2 := 0 - nomrad1;
        // to opposite direction same size as 1st radius.
      end
      else begin
        nomrad2 := existing_rad;

        if ABS(nomrad2) > (max_rad / 2)  // arbitrary (is straight).
        then
          nomrad2 := 660 * scale;  // so use 10 chains.

        nomrad1 := 0 - nomrad2;
        // to opposite direction same size as 2nd radius.
      end;

      tst := turnoutx * 0.6;     // arbitrary transition length 60% of template.
      os := turnoutx * 0.2;      // arbitrary length of first radius 20% of template.
    end;

  end;//case

  if ABS(nomrad1) < (g * 2) then
    nomrad1 := g * 2 * SGZ(nomrad1);     // min rad (arbitrary).
  if ABS(nomrad2) < (g * 2) then
    nomrad2 := g * 2 * SGZ(nomrad2);     // min rad (arbitrary).

  temp := nomrad1 - nomrad2;

  while ABS(temp) < minfp do begin   // no good if rads equal.
    nomrad1 := nomrad1 * 1.05;         // increase r1 by 5%
    nomrad2 := nomrad2 / 1.05;         // reduce r2 by 5%
    temp := nomrad1 - nomrad2;
  end;//while

  temp_ktrans := nomrad1 * nomrad2 * tst / temp;     // new spiral constant

  if ABS(temp_ktrans) > max_spiral_constant then begin
    tst := max_spiral_constant * SGZ(temp_ktrans) * temp / nomrad1 / nomrad2;
    //  no good, limit zone length.
    if tst < minfp then
      tst := 0;
  end;

  with pad_form do begin

    adjust_trans_length_menu_entry.Enabled := True;  // mouse actions...
    adjust_trans_start_menu_entry.Enabled := True;

    zone_normal_menu_entry.Checked := True;          // radio item - normal length adjust action.
    transition_template_menu_entry.Checked := True;  // radio item.
  end;

  spiral := True;

  peg_curve;            // transition curve onto peg.
  redraw_pad(True, True);
end;
//______________________________________________________________________________

function do_auto_trans_swing_adjust(old_rad2_orgx, old_rad2_orgy: double): integer;

  // this code swings the transition curve on rad1 to and fro in reducing steps
  // until the new position of the 2nd rad centre co-incides with the old.
  // The 1st rad centres must be co-incident.
  // The transition zone length must also have been adjusted so that the separation distance
  // between the two centres (ignoring slewing) is the same as before.

  // The rad centres are calculated ON THE PAD, i.e. including slewing.

  // Return 1 if valid result, 0 if calc error, or -1 if he clicks cancel.

var
  xdiff2, ydiff2: double;
  prev_diff2_sq, next_diff2_sq: double;

  dir, k_step, start_kform: double;

begin
  try
    Result := 0;   // default init

    do_rollback := False;
    gocalc(0, 0);     // get new calcs.

    xdiff2 := rad2_orgx - old_rad2_orgx;
    ydiff2 := rad2_orgy - old_rad2_orgy;

    prev_diff2_sq := SQR(xdiff2) + SQR(ydiff2);
    // square of distance apart of new and old r2 centres.

    k_step := Pi / 18;     // initial stepping at 10 degrees.

    init_rotate(xt1, yt1, True);

    start_kform := kform;

    dir := 1;                // start by going forward (arbitrary direction).

    repeat

      do_rollback := False;
      kform := kform + k_step;
      gocalc(0, 0);              // fresh calc sets new rad2 radial centre.

      xdiff2 := rad2_orgx - old_rad2_orgx;
      // how far is the rad2 centre off the original position?
      ydiff2 := rad2_orgy - old_rad2_orgy;

      next_diff2_sq := SQR(xdiff2) + SQR(ydiff2);

      if next_diff2_sq < 0.0001 then begin
        Result := 1;
        // r2 centre now within a radius of .01mm of the original centre (dim is squared).
        EXIT;
      end;

      if next_diff2_sq > prev_diff2_sq     // gone too far (difference more than last time)?
      then begin
        k_step := 0 - k_step / 10;     // change direction and use smaller steps.
        dir := 0 - dir;
      end;
      // try again..

      prev_diff2_sq := next_diff2_sq;

      if Application.Terminated = False then
        Application.ProcessMessages;  // allow him to click.

      if wait_cancel_clicked = True   // exit calcs but leave kform where we are.
      then begin
        Result := -1;
        EXIT;
      end;

    until ((dir = 1) and (kform > (start_kform + 2 * Pi))) or
      ((dir = -1) and (kform < (start_kform - 2 * Pi)))
      // will take forever, but we must have a limit of some sort.
      or (ABS(k_step) < minfp);

  finally
    normalize_kform;
  end;//try
end;
//_______________________________________________________________________________________

function make_transition_from_current(control_loc, bgnd_loc, trans_hand: integer): boolean;

  // 17-9-15 control_loc,bgnd_loc;  // 0=match at peg, 15=at 1st radius, 16=at 2nd radius.  212a

  // 20-4-01  trans_hand: 1= r1 is LH, -1= r1 is RH .

var
  temp, dummy, dummy1, dummy2: double;
  saved_current: Ttemplate_info;
  saved_notch: Tnotch;
  saved_name_str: string;
  saved_memo_str: string;

  got_transition: boolean;

  error_allow: double;


  ///////////////////////////////////////////////////////////////////

  procedure error_restore;

  begin

    if keeps_list.Count > 0 then begin
      list_position := keeps_list.Count - 1;
      // last one in box we just stored.
      delete_keep(False, False);          // delete it.
    end;

    copy_keep(saved_current);                    // retrieve saved current.
    current_name_str := saved_name_str;
    current_memo_str := saved_memo_str;

    info_form.ref_name_label.Caption := current_name_str;
  end;
  ////////////////////////////////////////////////////////////////////

begin
  Result := False;  // default init.

  do_rollback := False;
  store_and_background(False, False);  // keep it (does a recalc) and copy to background.
  if keep_added = False then
    EXIT;      // he cancelled.

  // -------- ready to go...

  try
    saved_current.keep_shove_list := Tshoved_timber_list.Create;
    fill_kd(saved_current);
    // save control template in case of error...
    saved_name_str := current_name_str;
    saved_memo_str := current_memo_str;

    //----------------

    if spiral = True      // 19-09-2015  212a this is a kludge bug-fix...
    then begin
      if ABS(nomrad1) > max_rad_test    // straight?
      then begin
        kform_now := kform;
        docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
        // save current peg data for peg_curve calcs.

        nomrad1 := (max_rad_test - 1) * SGZ(nomrad1);
        // kludge - ensure treated as curved, not straight.
        // until I can find bug when it's straight 19-09-2015

        peg_curve;      //  keep it on peg..
        gocalc(0, 0);
      end;

      if ABS(nomrad2) > max_rad_test    // straight?
      then begin
        kform_now := kform;
        docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
        // save current peg data for peg_curve calcs.

        nomrad2 := (max_rad_test - 1) * SGZ(nomrad2);
        // kludge - ensure treated as curved, not straight.
        // until I can find bug when it's straight 19-09-2015

        peg_curve;      //  keep it on peg..
        gocalc(0, 0);
      end;

    end
    else begin                            // fixed curve
      if ABS(nomrad) > max_rad_test    // straight?
      then begin
        kform_now := kform;
        docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
        // save current peg data for peg_curve calcs.

        nomrad := (max_rad_test - 1) * SGZ(nomrad);
        // kludge - ensure treated as curved, not straight.
        // until I can find bug when it's straight 19-09-2015

        peg_curve;      //  keep it on peg..
        gocalc(0, 0);
      end;
    end;

    //----------------

    if peg_rail <> 8   // bug fix 212a  (needed before putting notch under)
    then begin
      peg_rail := 8;    // peg must be on main-road centre-line.
      peg_code := 20;   // flag gocalc to use peg_rail.
      gocalc(0, 0);
    end;

    if (spiral = True) and ((control_loc = 15) or (control_loc = 16))
    // move peg to trans start or length  212a
    then begin
      peg_code := control_loc;
      gocalc(0, 0);
    end;

    unlink_group;
    // we want to use the notch, cancel any linking..
    pad_form.notch_unlinked_from_current_menu_entry.Click;
    // cancel any moving the notch in mouse actions.

    saved_notch := get_current_notch;         // save his current notch position.
    new_notch(get_peg_for_notch, False);
    // first put the notch under the control template, for later pegging.

    // first convert it to fixed curve (so can get rad centre at instantaneous radius if peg in a transition zone or template straight).

    if spiral = True then begin
      fix_radius(clrad_at_x(pegx), False);
      // set nomrad from centre-line radius at peg.
      gocalc(0, 0);
    end;


    with make_trans_data do begin

      old_rad1_orgx := rad1_orgx;       // 1st rad and centres on pad..
      old_rad1_orgy := rad1_orgy;
      rad_1st := nomrad;

      peg1x := pegx_on_pad;                     // and 1st peg position on pad..
      peg1y := pegy_on_pad * hand_i + y_datum;


      // now get the background template, and repeat...

      list_position := clicked_keep_index;              // make it current in the keeps box.
      copy_keep_to_current(False, False, True, False);   // copy to pad.
      gocalc(0, 0);

      //------------------

      if spiral = True      // 19-09-2015  212a this is a kludge bug-fix...
      then begin
        if ABS(nomrad1) > max_rad_test    // straight?
        then begin
          kform_now := kform;
          docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
          // save current peg data for peg_curve calcs.

          nomrad1 := (max_rad_test - 1) * SGZ(nomrad1);
          // kludge - ensure treated as curved, not straight.
          // until I can find bug when it's straight 19-09-2015

          peg_curve;      //  keep it on peg..
          gocalc(0, 0);
        end;

        if ABS(nomrad2) > max_rad_test    // straight?
        then begin
          kform_now := kform;
          docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
          // save current peg data for peg_curve calcs.

          nomrad2 := (max_rad_test - 1) * SGZ(nomrad2);
          // kludge - ensure treated as curved, not straight.
          // until I can find bug when it's straight 19-09-2015

          peg_curve;      //  keep it on peg..
          gocalc(0, 0);
        end;

      end
      else begin                            // fixed curve
        if ABS(nomrad) > max_rad_test    // straight?
        then begin
          kform_now := kform;
          docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
          // save current peg data for peg_curve calcs.

          nomrad := (max_rad_test - 1) * SGZ(nomrad);
          // kludge - ensure treated as curved, not straight.
          // until I can find bug when it's straight 19-09-2015

          peg_curve;      //  keep it on peg..
          gocalc(0, 0);
        end;
      end;

      //--------------------

      if spiral = True then begin
        if (bgnd_loc = 15) or (bgnd_loc = 16) // move peg to trans start or length  212a
        then begin
          peg_code := bgnd_loc;
          gocalc(0, 0);
        end;

        fix_radius(clrad_at_x(pegx), False);
        // set nomrad from centre-line radius at peg.
        gocalc(0, 0);
      end;

      old_rad2_orgx := rad1_orgx;       // 2nd rad and centres on pad..
      old_rad2_orgy := rad1_orgy;
      rad_2nd := nomrad;

      peg2x := pegx_on_pad;                     // and 2nd peg position on pad..
      peg2y := pegy_on_pad * hand_i + y_datum;

      cen_apart := SQRT(SQR(old_rad2_orgx - old_rad1_orgx) + SQR(old_rad2_orgy - old_rad1_orgy));
      // distance between rad centres.

      // now change to plain track, no slewing, transition curve...

      plain_track := True;
      set_plain_track(True, True);

      with pad_form do begin

        adjust_trans_length_menu_entry.Enabled := True;  // mouse actions...
        adjust_trans_start_menu_entry.Enabled := True;

        zone_normal_menu_entry.Checked := True;
        // radio item - normal length adjust action.
        transition_template_menu_entry.Checked := True;  // radio item.

        disable_slewing_menu_entry.Checked := True;     // radio item.
        slew_nudge_menu_entry.Checked := False;

        adjust_slew_start_menu_entry.Enabled := False;
        adjust_slew_length_menu_entry.Enabled := False;
        adjust_slew_amount_menu_entry.Enabled := False;
        adjust_slew2_factor_menu_entry.Enabled := False;

        slewing_panel.Hide;
      end;//with

      with info_form do begin
        slew_warn_panel.Hide;           // cover min rad box.
        min_rad_box.Show;               // restore rad change button...
        limit_rad_box.Show;
      end;//with

      if (ABS(rad_1st - rad_2nd) < minfp)      // 214a mod ...
      then begin
        alert(6, '    invalid  transition',
          'The selected templates both have the same radius curving in the same direction.' +
          '||A transition curve can only be created where there is a change in radius or direction.',
          '', '', '', '', '', 'continue', 0);
        error_restore;
        EXIT;
      end;

      got_transition := False;     // init.
      // init for a new control template...
      spiral := True;
      slewing := False;
      hand_i := trans_hand;     // set hand of his choice (rad1 is +ve).

      turnoutx := SQRT(SQR(peg2x - peg1x) + SQR(peg2y - peg1y)) * 1.5;
      // arbitrary template length is 1.5 * distance between the pegs.
      xorg := turnoutx;

      tst := 0;            // arbitrary start zero transition length.
      os := 66 * scale;      // arbitrary start 1 chain (scale) initial length.

      nomrad1 := ABS(rad_1st);      // set +ve for first rad.
      nomrad2 := 0 - ABS(rad_2nd);    // set S curve for starters.

      if (ABS(nomrad1) > (g * 2)) and (ABS(nomrad2) > (g * 2))  // min rads (arbitrary).
        and (cen_apart > (ABS(nomrad1) + ABS(nomrad2) - minfp))   // ok to try S-curve
      then begin
        wait_cancel_clicked := False;
        wait_form.cancel_button.Show;
        wait_form.waiting_label.Caption := 'calculating ...';

        wait_form.waiting_label.Width :=
          wait_form.Canvas.TextWidth(wait_form.waiting_label.Caption);  // 205b bug fix for Wine

        pad_form.trans_calc_timer.Tag := 0;
        // do the calcs while the wait message shows modal.
        pad_form.trans_calc_timer.Enabled := True; // one-shot only to start the process.

        do_show_modal(wait_form);  // 212a   ShowModal

        if Application.Terminated = False then
          Application.ProcessMessages;

        // returns here when the wait form closes...

        case pad_form.trans_calc_timer.Tag of
          -1:
            EXIT;  // he cancelled  - leave transition as is.
          // 0: failed - try C-curve instead, below.
          1:
            got_transition := True;
        end;//case
      end;

      if got_transition = False      // now try C-curve instead...
      then begin
        nomrad2 := ABS(nomrad2);     // set C curve.

        temp := nomrad1 - nomrad2;

        if (ABS(temp) > minfp) and (cen_apart < (ABS(ABS(nomrad1) - ABS(nomrad2)) + minfp))
        // ok to try C-curve
        then begin
          wait_cancel_clicked := False;
          wait_form.cancel_button.Show;
          wait_form.waiting_label.Caption := 'calculating ...';

          wait_form.waiting_label.Width :=
            wait_form.Canvas.TextWidth(wait_form.waiting_label.Caption);  // 205b bug fix for Wine

          pad_form.trans_calc_timer.Tag := 0;
          // do the calcs while the wait message shows modal.
          pad_form.trans_calc_timer.Enabled := True;
          // one-shot only to start the process.

          do_show_modal(wait_form);  // 212a   ShowModal

          if Application.Terminated = False then
            Application.ProcessMessages;

          // returns here when the wait form closes...

          case pad_form.trans_calc_timer.Tag of
            -1:
              EXIT;  // he cancelled - leave transition as is.
            0: begin
              alert(5, '    calculation  failed',
                'Sorry, the transition calculations have failed to produce a result.' +
                '||The most likely reason is that the required transition zone length would exceed '
                + round_str(screenx_max, 2) + ' mm,' +
                ' or that the transition curve would be more gentle than the current MAX SPIRAL limit permits.'
                + '||Try increasing the difference between the two radii.',
                '', '', '', '', '', 'continue', 0);
              error_restore;
              EXIT;
            end;
            1:
              got_transition := True;
          end;//case
        end
        else begin
          if alert(6, '    impossible  transition',
            'Sorry, it is not possible to create a transition curve alignment between these two templates.',
            '', '', '', 'more  information', 'cancel', '', 4) = 4 then begin
            if help(0, make_trans_help_str, 'about  transition  curves') = 1 then
              pad_form.transition_help_menu_entry.Click;
          end;
          error_restore;
          EXIT;
        end;
      end;


      turnoutx := os + tst + 66 * scale;
      // got the transition, set overall length to 1 chain (scale) of final radius (arbitrary).
      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;
      xorg := turnoutx;

      startx := 0;         // cancel any blanking.

      retain_on_make;     // 213a  retain for inserted turnout later

      do_rollback := False;
      gocalc(0, 0);
      // got the template, now align it...

      pad_form.reset_peg_menu_entry.Click;  // peg on CTRL-0.

      do_rollback := False;
      gocalc(0, 0);

      shift_onto_notch(False, False);
      // we set the notch earlier on the previous control template.

      do_rollback := False;
      gocalc(0, 0);
      // now check the rad1 centres are co-incident...

      error_allow := 0.000001;
      // r1 centre not within a radius of .001mm of the original centre (dim is squared).

      if (SQR(old_rad1_orgx - rad1_orgx) + SQR(old_rad1_orgy - rad1_orgy)) > error_allow then begin
        // try rotating once

        rotate_turnout(Pi, False);
        // rotate template 180 degrees anti-clockwise around peg.
        do_rollback := False;
        gocalc(0, 0);                    // fresh calc sets new radial centres.

        // check r1 is now on centre...

        if (SQR(old_rad1_orgx - rad1_orgx) + SQR(old_rad1_orgy - rad1_orgy)) >
          error_allow  // r1 centre is still not within a radius of .001mm of the original centre (dim is squared).
        then begin
          alert(5, '    transition  calculation  failed',
            'Sorry, the transition calculations have failed to produce a result.',
            '', '', '', '', '', 'continue', 0);
          error_restore;
          EXIT;
        end;
      end;

    end;//with make_trans_data

    // finally swing it on rad1 until rad2 centres co-incide..

    wait_cancel_clicked := False;
    wait_form.cancel_button.Show;
    wait_form.waiting_label.Caption := 'calculating ...';

    wait_form.waiting_label.Width := wait_form.Canvas.TextWidth(wait_form.waiting_label.Caption);
    // 205b bug fix for Wine

    pad_form.trans_calc_timer.Tag := 9;        // do the calcs while the wait message shows modal.
    pad_form.trans_calc_timer.Enabled := True; // one-shot only to start the process.

    do_show_modal(wait_form);  // 212a   ShowModal

    if Application.Terminated = False then
      Application.ProcessMessages;

    // returns here when the wait form closes...

    case pad_form.trans_calc_timer.Tag of
      -1:
        EXIT;  // he cancelled - leave transition as is.

      0: begin
        alert(5, '    calculation  failed',
          'Sorry, the transition calculations have failed to produce a result.',
          '', '', '', '', '', 'continue', 0);
        error_restore;
        EXIT;
      end;

      // 1: ok
    end;//case

    clear_current_name;     // finally we have a new control template.
    Result := True;

  finally
    set_current_notch(saved_notch);  // restore his notch.

    wait_form.Close;
    clicked_keep_index := -1;          // so can popup again.
    do_rollback := True;

    saved_current.keep_shove_list.Free;
    show_and_redraw(True, True);                       // in case copy caused a current hide.
  end;//try
end;
//___________________________________________________________________________________________

function make_transition_from_current_calcs: integer;

  // return  1= ok,   0= error,   -1= he cancelled.

begin
  Result := 0;  // default init.

  do_rollback := False;
  gocalc(0, 0);              // first stab at the new transition.

  Result := do_auto_trans_length_adjust(make_trans_data.cen_apart);
  // adjust transition length to match required rad centre-to-centre distance
end;
//__________________________________________________________________________________________

procedure make_transition_click(trans_hand: integer);

var
  i: integer;
  save_index: integer;

  control_loc: integer;  // 0=at peg, 15=at 1st radius, 16=at 2nd radius.  212a
  bgnd_loc: integer;

  dummy: double;

begin
  if (clicked_keep_index < 0) or (clicked_keep_index > (keeps_list.Count - 1)) or
    (keeps_list.Count < 1) then
    EXIT;

  if check_control_template_is_valid('transition') = False then
    EXIT;  // zero length

  if keeps_list[clicked_keep_index].template_info.keep_dims.box_dims1.align_info.slewing_flag =
    True then begin
    alert(6, 'php/201    make  transition',
      'The selected background template contains a slew.' +
      '||It is not possible to make a transition curve from a slewed template.' +
      '||If a slew is needed, it should be applied after creating the transition curve.',
      '', '', '', '', 'cancel  transition', '', 0);
    EXIT;
  end;

  if slewing = True then begin
    alert(6, 'php/201    make  transition',
      'The control template contains a slew.' +
      '||It is not possible to make a transition curve from a slewed template.' +
      '||If a slew is needed, it should be applied after creating the transition curve.' +
      '||To cancel the slewing, click the GEOMETRY > SLEW (NUDGE) > CANCEL SLEW menu item.',
      '', '', '', '', 'cancel  transition', '', 0);
    EXIT;
  end;

  control_loc := 0;   // init for fixed curve..  212a
  bgnd_loc := 0;

  if keeps_list[clicked_keep_index].template_info.keep_dims.box_dims1.align_info.trans_flag =
    True then begin
    repeat
      i := alert(4, 'php/201    make  transition',
        'The selected background template contains a transition curve.' +
        '||Where on the background template do you want the new transition curve to be aligned?',
        'more  information', 'background  template :    on  the  1st  radius',
        'background  template :    on  the  2nd  radius',
        'background  template :   at  the  current  peg  location',
        'cancel  making  new  transition', '', 1);
      case i of

        1:
          if alert_help(0, make_trans_help_str, 'about  transition  curves') = 1 then
            pad_form.transition_help_menu_entry.Click;

        2:
          bgnd_loc := 15;     // peg code for trans start

        3:
          bgnd_loc := 16;     // peg code for trans length

        4: begin
          bgnd_loc := 0;

          with keeps_list[clicked_keep_index].template_info.keep_dims.box_dims1 do begin

            if (transform_info.peg_pos.x > align_info.trans_start) and
              (transform_info.peg_pos.x < (align_info.trans_start + align_info.trans_length)) then
            begin
              if alert(3, 'php/201    make  transition',
                'tree.gif||The peg on the background template is currently located within the transition zone.'
                +
                '||You will need to shorten the original template to this location' +
                ' in order to make a correct boundary with the new control template. Use the `0DO > SNAP TO PEG`1 menu item'
                +
                ' (possibly preceded by `0TEMPLATE > SWAP END-FOR-END`1 menu item).',
                '', '', '', '', 'cancel  making  new  transition', 'continue', 0) = 5 then
                EXIT;
            end;
          end;//with
        end;

        else
          EXIT;

      end;//case

    until i <> 1;
  end;


  if spiral = True   // 212a
  then begin
    repeat
      i := alert(4, 'php/201    make  transition',
        'The control template contains a transition curve.' +
        '||Where on the control template do you want the new transition curve to be aligned?',
        'more  information', 'control  template :    on  the  1st  radius',
        'control  template :    on  the  2nd  radius',
        'control  template :    at  the  current  peg  location',
        'cancel  making  new  transition', '', 1);
      case i of

        1:
          if alert_help(0, make_trans_help_str, 'about  transition  curves') = 1 then
            pad_form.transition_help_menu_entry.Click;

        2:
          control_loc := 15;   // peg code for trans start

        3:
          control_loc := 16;   // peg code for trans length

        4: begin
          control_loc := 0;

          if (pegx > os) and (pegx < (os + tst)) then begin
            if alert(3, 'php/201    make  transition',
              'tree.gif||The peg is currently located within the transition zone on the control template.'
              + '||You will need to shorten the original template to this location' +
              ' in order to make a correct boundary with the new control template. Use the `0DO > SNAP TO PEG`1 menu item'
              +
              ' (possibly preceded by `0TEMPLATE > SWAP END-FOR-END`1 menu item).',
              '', '', '', '', 'cancel  making  new  transition', 'continue', 0) = 5 then
              EXIT;
          end;
        end;

        else
          EXIT;

      end;//case

    until i <> 1;
  end;

  //-----------

  save_index := clicked_keep_index;

  if make_transition_from_current(control_loc, bgnd_loc, trans_hand) =
    True    // first try one hand.
  then begin
    show_and_redraw(False, False);                 // force a draw.
    pad_form.fit_current_only_menu_entry.Click;   // see all of it.

    repeat

      with alert_box do begin          // 205d
        left_panbutton.Visible := True;
        right_panbutton.Visible := True;
        down_panbutton.Visible := True;
        up_panbutton.Visible := True;
      end;//with

      alert_option2a_click_code := 1;    // zoom in   205d
      alert_option2b_click_code := 2;    // zoom out

      i := alert(4, 'php/202    make  transition', 'Is this the required transition curve?',
        '_1anotick_delete the original templates', '_2a_+  zoom in_2b_-  zoom out',
        'more  information', 'no  -  try  opposite  hand  instead',
        'cancel  transition', 'yes  -  continue', 3);
      case i of
        3:
          if alert_help(0, make_trans_help_str, 'about  transition  curves') = 1 then
            pad_form.transition_help_menu_entry.Click;

        4: begin
          list_position := keeps_list.Count - 1;
          // make one just added current in the keeps box.
          copy_keep_to_current(False, False, False, False);   // copy it back to pad.
          delete_keep(False, False);                        // remove it.

          gocalc(0, 0);
          trans_hand := 0 - trans_hand;
          clicked_keep_index := save_index;
          if make_transition_from_current(control_loc, bgnd_loc, trans_hand) = False then
            EXIT;

          redraw_pad(False, False);                      // force a draw.
          pad_form.fit_current_only_menu_entry.Click;   // see all of it.
          i := 3;                                         // ask again
        end;

        5: begin
          list_position := keeps_list.Count - 1;
          // make one just added current in the keeps box.
          copy_keep_to_current(False, False, False, False);   // copy it back to pad.
          delete_keep(False, False);                        // remove it.
          redraw_pad(True, False);
        end;

        6: begin
          if alert_box.option1a_checkbox.Checked = True
          // 205d  delete underlying templates
          then begin
            list_position := keeps_list.Count - 1;
            // make one just added current in the keeps box.
            delete_keep(False, False);              // remove it.

            list_position := save_index;     // and the clicked one
            delete_keep(False, False);      // remove it

          end;

          // 212a kludge. restore easement straights...

          if ABS(nomrad1) > (max_rad_test - 2) then begin
            kform_now := kform;
            docurving(True, True, pegx, pegy, now_peg_x,
              now_peg_y, now_peg_k, dummy);    // save current peg data for peg_curve calcs.

            nomrad1 := (max_rad) * SGZ(nomrad1);
            // kludge - ensure now treated as straight again.

            peg_curve;      //  keep it on peg..
            gocalc(0, 0);
          end;

          if ABS(nomrad2) > (max_rad_test - 2) then begin
            kform_now := kform;
            docurving(True, True, pegx, pegy, now_peg_x,
              now_peg_y, now_peg_k, dummy);    // save current peg data for peg_curve calcs.

            nomrad2 := (max_rad) * SGZ(nomrad2);
            // kludge - ensure now treated as straight again.

            peg_curve;      //  keep it on peg..
            gocalc(0, 0);
          end;

          redraw_pad(True, True);
        end;

      end;//case
    until i > 3;

  end;
end;
//________________________________________________________________________________________

function do_auto_trans_length_adjust(apart_len_wanted: double): integer;

  // adjust transition zone length until the distance between the rad centres is apart_len_wanted.
  // return 1 if achieved, 0 if calc error, -1 if he cancels.

  // !!! N.B. apart_len_wanted and transition calcs are based on transition datum, not template datum, and ignore any slewing.

var
  dummy1, dummy2, dummy3, dummy4, dummy5: double;

  now_apart: double;
  new_zone_len, zone_step: double;
  dir: integer;

  temp, temp_ktrans: double;

begin
  Screen.Cursor := crHourglass;
  Result := 0;  // default init.
  try
    new_zone_len := 0;        // start with a transition length of zero.
    zone_step := scale;       // and step size 1ft (scale) (arbitrary).

    // first find which way the centres-apart distance is moving...
    // (now_apart ignores any slewing).

    if calc_transition(nomrad1, nomrad2, new_zone_len, dummy1, dummy2, dummy3,
      dummy4, now_apart, dummy5) = False then begin
      EXIT;
    end;

    if ABS(now_apart - apart_len_wanted) < sep_limit    // already matches, do nothing.
    then begin
      tst := new_zone_len;     // new transition zone length = 0.
      Result := 1;
      EXIT;
    end;

    if now_apart > apart_len_wanted then
      dir := -1
    else
      dir := 1;
    repeat
      if calc_transition(nomrad1, nomrad2, new_zone_len, dummy1, dummy2, dummy3,
        dummy4, now_apart, dummy5) = False then begin
        EXIT;
      end;

      if ABS(now_apart - apart_len_wanted) < sep_limit     // matching centre-to-centre dim?
      then begin
        tst := new_zone_len;
        // set new transition zone length to give wanted rad centre-to-centre distance.
        Result := 1;
        EXIT;
      end;

      if ((dir = 1) and (now_apart > apart_len_wanted)) or ((dir = -1) and
        (now_apart < apart_len_wanted)) then begin
        new_zone_len := new_zone_len - zone_step;       // back track on previous step.
        if new_zone_len < 0 then
          new_zone_len := 0;     // can't be negative.
        zone_step := zone_step / 10;                    // and reduce step size.
      end;

      new_zone_len := new_zone_len + zone_step;                 // step forward again

      if Application.Terminated = False then
        Application.ProcessMessages;  // allow him to click.

      if wait_cancel_clicked = True then begin
        Result := -1;       // he clicked cancel.
        EXIT;
      end;

    until new_zone_len > screenx_max;   // we need a limit of some sort.

  finally
    temp := nomrad1 - nomrad2;      // 29-7-01 check any transition returned is not too gentle.
    if ABS(temp) < minfp then
      Result := 0
    else begin
      temp_ktrans := nomrad1 * nomrad2 * tst / temp;     // new spiral constant
      if ABS(temp_ktrans) > max_spiral_constant then begin
        tst := 0;       // no good.
        Result := 0;
      end;
    end;

    Screen.Cursor := crDefault;
  end;//try
end;
//________________________________________________________________________________________

function do_auto_trans_start_adjust(old_rad1_orgx, old_rad1_orgy, old_rad2_orgx,
  old_rad2_orgy: double): integer;

  // this code moves the transition start (initial length os) to and fro in reducing steps
  // until the new position of the 2nd rad centre co-incides with the old.
  // The 1st rad centres must be co-incident, and the peg must be in the initial length,
  // so that re-pegging after each calc keeps the 1st rad centres co-incident.
  // The transition zone length must also have been adjusted so that the separation distance
  // between the two centres (ignoring slewing) is the same as before.

  // The rad centres are calculated ON THE PAD, i.e. including slewing.

  // Return 1 if valid result, 0 if calc error, or -1 if he clicks cancel.

var
  xdiff2, ydiff2: double;
  prev_diff2_sq, next_diff2_sq: double;

  xdiff1, ydiff1: double;
  diff1_sq: double;

  dir, os_step, dummy: double;

begin

  Result := 0;   // default init

  do_rollback := False;
  gocalc(0, 0);     // get new peg calcs.

  xdiff2 := rad2_orgx - old_rad2_orgx;
  ydiff2 := rad2_orgy - old_rad2_orgy;

  prev_diff2_sq := SQR(xdiff2) + SQR(ydiff2);
  // square of distance apart of new and old r2 centres.


  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.


  dir := 1;                // start by going forward (arbitrary direction).
  os_step := 10 * scale;     // 10ft scale arbitrary  initial step-size.

  repeat

    do_rollback := False;
    os := os + os_step;   // step along...
    peg_curve;        // calls calc_curving and maintains peg position for new os.
    gocalc(0, 0);      // fresh calc sets new radial centres.

    // check r1 is still on centre...

    xdiff1 := rad1_orgx - old_rad1_orgx;
    // how far is the rad1 centre off the original position?
    ydiff1 := rad1_orgy - old_rad1_orgy;

    diff1_sq := SQR(xdiff1) + SQR(ydiff1);

    if diff1_sq > 0.000001
    // r1 centre not within a radius of .001mm of the original centre (dim is squared).
    then begin
      // so try rotating once (shift onto notch may have failed)..
      rotate_turnout(Pi, False);   // rotate template 180 degrees anti-clockwise around peg.
      do_rollback := False;
      gocalc(0, 0);                // fresh calc sets new radial centres.

      // check r1 is now on centre...

      xdiff1 := rad1_orgx - old_rad1_orgx;
      // how far is the rad1 centre now off the original position?
      ydiff1 := rad1_orgy - old_rad1_orgy;

      diff1_sq := SQR(xdiff1) + SQR(ydiff1);

      if diff1_sq > 0.000001 then
        EXIT;  // r1 centre is still not within a radius of .001mm of the original centre (dim is squared).
    end;

    xdiff2 := rad2_orgx - old_rad2_orgx;
    // how far is the rad2 centre off the original position?
    ydiff2 := rad2_orgy - old_rad2_orgy;

    next_diff2_sq := SQR(xdiff2) + SQR(ydiff2);

    if next_diff2_sq < 0.0001 then begin
      Result := 1;
      // r2 centre now within a radius of .01mm of the original centre (dim is squared).
      EXIT;
    end;

    if next_diff2_sq > prev_diff2_sq       // gone too far (difference more than last time)?
    then begin
      os_step := 0 - os_step / 10;     // change direction and use smaller steps.
      dir := 0 - dir;
    end;
    // try again..

    prev_diff2_sq := next_diff2_sq;

    if Application.Terminated = False then
      Application.ProcessMessages;  // allow him to click.

    if wait_cancel_clicked = True   // exit calcs but leave os where we are.
    then begin
      Result := -1;
      EXIT;
    end;

  until ((dir = 1) and (os > screenx_max)) or ((dir = -1) and (os < (0 - screenx_max)));
  // will take forever, but we must have a limit of some sort.
end;
//_______________________________________________________________________________________

procedure unlock_both;

begin
  pad_form.unlock_both_popup_entry.Checked := True;  // radio item
  switch_free := True;
  xing_free := True;
end;
//_________________________________________________________________________________________

function set_black_and_white: boolean;

  // return True if he clicks printer setup... , otherwise False.

var
  i, colour_depth_bits: integer;

begin
  Result := False;    // init.

  { OT-FIRST colour_depth_bits:=GetDeviceCaps(Printer.Handle,BITSPIXEL)*GetDeviceCaps(Printer.Handle,PLANES);}
  colour_depth_bits := 24;  // OT-FIRST

  if colour_depth_bits > 1 then begin
    i := alert(3, '    black & white  on  colour  printer',
      'You have selected the black & white only option for your template printing. Your current printer is a colour printer, you may get better black & white results with grey-shades printing.' + '||To print in black & white on some models of colour printer, you may also need to change a switch or setting on the printer itself, or in the printer setup dialog.' + '||Single-cartridge printers may also need to have the ink cartridge changed.' + '||Templot0 cannot make these changes for you.' + '||If the printed templates are unsatisfactory, please refer to the documentation for your printer.', '', '', '', 'printer  setup ...', 'cancel', 'O K  -  black && white  printing', 0);
    case i of
      4: begin
        printer_setup(False, True);
        Result := True;
      end;

      5:
        EXIT;
    end;//case
  end;

  black_white := True;
  pad_form.printed_grid_dotted_menu_entry.Click;

  grey_shade := False;

  print_form.reset_button.Click;


  pad_form.black_and_white_printing_menu_entry.Checked := True;   //  radio item
  //graph_outline_menu_entry.Click;
end;
//_________________________________________________________________________________________

procedure pt_convert;   // convert turnout to plain track on same alignment.

begin

  // out 211c (may be using offset=0 set-track, need to re-insert gaunt turnout)     if gaunt=True then convert_to_or_from_gaunt(False);  // 0.93.a cancel any gaunt

  plain_track := True;
  set_plain_track(True, True);       // cancels any blanking.

  xorg := turnoutx;                   // use existing length.

  isolated_crossing := False;     // 217a

  with pad_form do begin
    if peg_code = 0 then
      reset_peg_menu_entry.Click
    else begin
      peg_code := 20;
      // not on reset, so keep peg wherever it is.
      set_peg_menu_entry.Checked := True;         // radio item.
      peg_indicator_panel.Caption := 'F';         // show him its free.
    end;

    show_and_redraw(True, True);         // in case hidden.
  end;//with
end;
//___________________________________________________________________________________________

procedure invert_curving;

var
  clrad, clrad1, clrad2, dummy: double;

begin
  //if (curved=False) and (slewing=False) then EXIT;         // straight template.

  cancel_adjusts(False);  // 0.93.a may be from toolbutton

  if spiral = False then begin
    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
    // save current peg data for peg_curve calcs.

    {if curved=True
               then begin}
    clrad := nomrad;      // change sign of centre-line radius..
    clrad := 0 - clrad;
    nomrad := clrad;      // set the new radius.
    {end;}
  end
  else begin                   // transition template...
    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
    // save current peg data for peg_curve calcs.

    clrad1 := nomrad1;      // change sign of centre-line 1st radius.
    clrad1 := 0 - clrad1;

    clrad2 := nomrad2;      // change sign of centre-line 2nd radius.
    clrad2 := 0 - clrad2;

    nomrad1 := clrad1;      // set the new radii.
    nomrad2 := clrad2;
  end;

  if slewing = True then
    slew := 0 - slew;   // need to swap the hand of any slewing also.
  peg_curve;                           // do curving calcs for the current peg position.
end;
//_____________________________________________________________________________________

procedure invert_handing;

begin
  invert_curving;
  gocalc(0, 0);                              // for peg calcs.
  swap_hand;
end;
//________________________________________________________________________________________

procedure error_b6_lh_reset;

begin
  plain_track := False;                               //  False = turnouts,   True = plain track
  set_plain_track(False, True);                      //  False = turnout. Set up menu options.

  xorg := 0;                                          // origin to rail-joint (turnouts)    *

  half_diamond := False;                              // 0.77.a 19-8-02  normal switch calcs.

  hand_i := 1;                                        //  default left-hand turnout.

  spiral := False;       // no transition.
  slewing := False;      // no slew
  reset_trans;         // set transition defaults.

  incx := def_req;       // increment for x mm.

  if set_csi_data(2, 2) = False  // set REA size B (group 2, size 2).
  then
    run_error(82);

  k3n := 6;              // 1:6 crossing             *
  xing_k_i := 7;         // 1:6 crossing list index  *
  xing_type_i := 0;      // straight crossing         *
  wing_tbcount := 3;     // 3 crossing timbers in front of A timber.
  retpar_i := 0;         // no return curve          *
  xing_list_i := 0;      // straight crossing type list index *
  xing_ret_i := 0;       // return curve centres as adjacent track. *

  entry_straight_code := 0;        // sl radio buttons default *
  fixed_sl := def_req;             // init fixed sl dim.

  pt_i := 3;             // 0.93.a default now 60ft rails / 25 sleepers

  turnoutx := scale * 132; // default overall length of turnout 2 chains
  startx := 0;           // no blanking. default starting point. (f28000 list entry limit) 1-11-99.
  turnout_i := 0;        // length free.

  turnout_road_i := 0;
  // normal turnout road exit length.
  pad_form.snap_exit_to_return_curve_menu_entry.Enabled := False;   // no return curve.

  xform := 0;                            // zero transform data.
  yform := 0;
  kform := 0;
  xshift := 0;
  yshift := 0;

  pad_form.reset_peg_menu_entry.Checked := True;       // radio item.
  peg_code := 0;
  pegx := 0;
  pegy := g / 2;

  exittb_i := 2;          // exit is sleepering       *

  calcs_done_and_valid := False;    // no calcs done yet.

  adjacent_edges := True;
  // 0.93.a   False=adjacent tracks,  True=trackbed edges and platform edges.

  // trackbed ...

  trackbed_ms_width_ins := 90;       // 180 inches total full-size 15ft.      215a
  trackbed_ts_width_ins := 90;

  draw_ms_trackbed_edge := False;
  draw_ts_trackbed_edge := False;

  cess_ms_width_ins := 27;            // 215a
  cess_ts_width_ins := 27;            // 215a

  draw_ms_trackbed_cess_edge := False;    // 215a
  draw_ts_trackbed_cess_edge := False;    // 215a


  // platforms ...

  platform_ms_front_edge_ins := 57;        // 4ft-9in default
  platform_ts_front_edge_ins := 57;

  platform_ms_start_width_ins := 144;      // 12ft default
  platform_ms_end_width_ins := 144;        // 12ft default

  platform_ts_start_width_ins := 144;      // 12ft default
  platform_ts_end_width_ins := 144;        // 12ft default

  platform_ms_start_mm := 0;
  platform_ms_length_mm := def_req;

  platform_ts_start_mm := 0;
  platform_ts_length_mm := def_req;

  platform_ms_start_skew_mm := 0;      // 207a
  platform_ms_end_skew_mm := 0;        // 207a

  platform_ts_start_skew_mm := 0;      // 207a
  platform_ts_end_skew_mm := 0;        // 207a


  draw_ms_platform := False;

  draw_ms_platform_rear_edge := True;
  draw_ms_platform_start_edge := True;
  draw_ms_platform_end_edge := True;

  draw_ts_platform := False;

  draw_ts_platform_rear_edge := True;
  draw_ts_platform_start_edge := True;
  draw_ts_platform_end_edge := True;

  gauge_faces := True;                               // gauge-faces wanted
  outer_edges := True;                               // and outer-edges
  midline := False;                                  // but not rail-centrelines.

  railedges(gauge_faces, outer_edges, centre_lines); // set up these flags.
  reset_defaults;     // do resettable defaults ( on def_req input )

  show_and_redraw(False, True);

end;
//_______________________________________________________________________________________

procedure fill_mark(p1, p2: TPoint; code: EMarkCode; num_str: string);
// enter this mark in list.

var
  ptr: ^Tmark;          // pointer to a Tmark record.
  markmax: integer;

begin
  //###

  if marks_list_ptr = nil then
    EXIT;        // pointer to marks list not valid.
  markmax := High(marks_list_ptr);  // max index for the present list.

  if mark_index > markmax{_c} then
    mark_index := markmax{_c};

  ptr := @marks_list_ptr[mark_index];  // pointer to the next Tmark record.

  if ptr = nil then
    EXIT;

  ptr^.code := code;                     // code for this entry :

  ptr^.p1.X := p1.X;             // fill the MoveTo data.
  ptr^.p1.Y := p1.Y;

  ptr^.p2.X := p2.X;             // fill the LineTo data or other info.
  ptr^.p2.Y := p2.Y;

  if code = eMC_99_TimberNumber then begin
    //ptr^.str:=text;             // TextOut data.

    timb_numbers_str := timb_numbers_str + num_str + Chr($1B);
    // add number string and separator to the accumulator string.
  end;

  Inc(mark_index);                                    // bump index for next.
  if mark_index > markmax{_c} then
    mark_index := markmax{_c};

end;
//_______________________________________________________________________________________

function curve_point(p: Tpex): Tpex;

var
  x, y, t, r: double;

begin                                     // return point p curved onto rad and transformed.
  docurving(True, True, p.x, p.y, x, y, t, r);   // t, r not used here.
  Result.x := x;
  Result.y := y;
end;
//_________________________________________________________________________________________

function convert_point(p: Tpex): Tpoint;     // input in mm f.p. , convert to 1/100ths mm. integer.

begin
  //  go convert to scale/hand, ensure all inputs are within range for 32-bits,
  //  do re-origination and distortions, round off and convert to integer.

  Result := xy_to_list(p);
end;
//_______________________________________________________________________________________________________________________________

procedure enter_mark(track: boolean; p1, p2: Tpex; code: EMarkCode; num_str: string);
//  main mark entry point. dims in mm (floats)

//  enter with points p1 and p2 in mm floats.
//  first curve it, then enter it in list.
//  if track=False, this is part of background drawing etc (not actually used).

//  if code negative, single point mark and p2 contains other info.
//  if code= -1 this is the fixing peg (but not the arms which are code= 8)
//  if code= -2,-3 this is the rad centre marks.
//  {if code= -4, this is the timber selector mark.!!! removed 5-6-00}
//  if code= 7, this is transition mark.

//code 493   chair outline                      // 213b
//code -493  chair block insert location (DXF)  // 213b

// code 501..508 = check rail labels  // 0.94.a

// code 601  toe tips label       // 206b
// code 602  set mark label       // 206b
// code 603  planing end label    // 206b
// code 604  stock gauge          // 206b
// code 605  joggle return        // 206b

// code 701  FP mark label        // 211b
// code 702  blunt nose label     // 211b
// code 703  half-diamond tips label     // 211b

// code 600  long toe mark          // 206b
//           long set mark          // 206b
//           long planing           // 206b
//           long stock gauge mark  // 206b

// code 700  long FP mark           // 211b
//           long blunt nose mark   // 211b


// !!! timbering outlines and centres are no longer done here, but numbering is (0.76.a 24-10-01).

var
  info: TPoint;   //  (use a TPoint for the info for convenience - not actually a point).
  dummy_i: integer;

begin

  if code < eMC_0_Ignore then begin
    info.X := Round(limits(minint, maxint, p2.x, dummy_i));
    // p2 contains other info or none.
    info.Y := Round(limits(minint, maxint, p2.y, dummy_i));
    // info must be integer to go in marks list.

    fill_mark(convert_point(curve_point(p1)),      // single-point mark on p1.
      info, code, '');                       // and info in p2.
  end

  else begin

    // first do any blanking...

    if (plain_track = False)
      and (code = eMC_99_TimberNumber)
      and (track = True) then begin
      if (Copy(num_str, 1, 1) <> 'B') and (Copy(num_str, 1, 1) <> 'R') and
        (p1.x < (startx - 6 * inscale)) then
        EXIT;  // blank timber numbering (not plain track or bonus timbers 0.76.a) .
      if (Copy(num_str, 1, 1) = 'R') and (p1.x < (startx - 30 * inscale)) then
        EXIT;
    end;

    if (p1.x < (startx - minfp_big)) and (p2.x < (startx - minfp_big)) and (track = True)
    // not timbering, these are joint marks, etc.
    then begin
      case code of
        eMC_1_GuideMark,
        eMC_2_RadialEnd,
        eMC_3_TimberOutline,
        eMC_4_TimberCL,
        eMC_5_TimberReducedEnd,
        eMC_6_RailJoint,
        eMC_14_TimberCLSolid,
        eMC_33_ShovingTimberOutline,
        eMC_44_ShovingTimberCL_1,
        eMC_54_ShovingTimberCL_2,
        eMC_55_ReducedEnd,
        eMC_93_ShovedTimberInfill,
        eMC_95_ReducedEndInfill,
        eMC_203_TimberInfill,
        eMC_233_ShovedTimberInfill,
        eMC_293_ShovedTimberInfill,
        eMC_493_Chair,
        eMC_501_MSWorkingEnd .. eMC_508_DSWingRail,
        eMC_600_LongMark .. eMC_605_JoggleLabel,
        eMC_700_XingLongMark .. eMC_703_XingLabelEnd:

          EXIT;    // blank nearly everything.
      end;//case
    end;

    // and no unnecessary marks beyond end of template (0,3,4 = timbers, etc, checked elsewhere)...
    // (allow 1ft beyond railends for angled joint marks, etc.)

    if ((p1.x > (turnoutx + scale)) or (p2.x > (turnoutx + scale))) and (track = True) then begin
      case code of
        eMC_1_GuideMark,
        eMC_2_RadialEnd,
        eMC_6_RailJoint,
        eMC_501_MSWorkingEnd .. eMC_508_DSWingRail,
        eMC_600_LongMark .. eMC_605_JoggleLabel,
        eMC_700_XingLongMark .. eMC_703_XingLabelEnd:
          EXIT;    // no guide marks or joints.
      end;//case
    end;


    case code of    // 99 timber numbers
      eMC_99_TimberNumber: begin

        // 208a mods...

        //info.X:=0;
        //info.Y:=0;

        fill_mark(convert_point(curve_point(p1)),
          // screen number string location in p1,
          convert_point(curve_point(p2)),
          // output number string location in p2  // 208a
          code, num_str);
      end;

      eMC_501_MSWorkingEnd .. eMC_508_DSWingRail,
      eMC_601_TipsLabel .. eMC_605_JoggleLabel: begin
        // 0.94.a  501..508 check labels added.   601-605 added 206b switch labels.  !!! 701,702,703 crossing labels entered directly  211b
        info.X := 0;
        info.Y := 0;

        fill_mark(convert_point(curve_point(p1)),
          info, code, '');                   // zero in p2.
      end;

      else
        fill_mark(convert_point(curve_point(p1)),   // normal mark with p1,p2 end points.
          convert_point(curve_point(p2)),
          code, '');
    end;//case

  end;
end;
//__________________________________________________________________________________________

procedure add_check_labels;          // 0.94.a   enter check-rail end labels

var
  p1, p2: Tpex;
  dummy_k: double;

begin
  p2.x := 0;    // not used.
  p2.y := 0;

  if main_road_check_rail_flag = True then begin
    p1.x := ckx_ms;
    p1.y := g / 3;
    enter_mark(True, p1, p2, eMC_501_MSWorkingEnd, '');  // main-side working end

    p1.x := ckendx;
    p1.y := g / 3;
    enter_mark(True, p1, p2, eMC_502_MSExtensionEnd, '');  // main-side extension end
  end;

  if turnout_road_crossing_rail_flag = True then begin
    p1.x := wingendox;
    p1.y := g * 2 / 3;
    enter_mark(True, p1, p2, eMC_503_MSWingRail, '');  // main-side wing rail
  end;

  if turnout_road_check_rail_flag = True then begin
    p1.x := cuckx;
    p1.y := aq3offset(p1.x, dummy_k) - g / 3;  // curved stock rail offset
    enter_mark(True, p1, p2, eMC_504_TSWorkingEnd, '');      // turnout-side working end

    p1.x := cuckendx;
    p1.y := aq3offset(p1.x, dummy_k) - g / 3;
    enter_mark(True, p1, p2, eMC_505_TSExtensionEnd, '');      // turnout-side extension end
  end;

  if main_road_crossing_rail_flag = True then begin
    p1.x := flcendox;
    p1.y := aq2offset(p1.x, dummy_k) + g / 3;
    enter_mark(True, p1, p2, eMC_506_TSWingRail, '');      // turnout-side wing rail
  end;

  if (half_diamond = True) and (fixed_diamond = True) then begin
    if k_main_side_check_rail_flag = True then begin
      p1.x := kckmsflendox;
      p1.y := aq2offset(p1.x, dummy_k) - g / 8;
      enter_mark(True, p1, p2, eMC_507_MSKCheckRail, '');      // main-side K check rail
    end;

    if k_diagonal_side_check_rail_flag = True then begin
      p1.x := kckdsflendox;
      p1.y := g * 9 / 8;
      enter_mark(True, p1, p2, eMC_508_DSWingRail, '');     // diagonal-side wing rail
    end;
  end;
end;
//______________________________________________________________________________

procedure guidemarks;     // calculate all the guide marks.

var
  p1, p2, dummy_p: Tpex;

  joggle_labels_p1, joggle_labels_p2: Tpex;    // 206b

  temp, tempx, tempy, tempcos, tempsin, tempk: double;
  gmi, gmo, gm, k, arm_long: double;

  gm_swlabels_ms, gm_swlabels_ts: double;  // 206b

  gm_xinglabels_ms, gm_xinglabels_ts: double;  // 211b

  gm_hdlabels_ms, gm_hdlabels_ts: double;  // 211b

  k_irreg: double; // 211b

  xtb: double;
  sw2, tbe, tbw, kwl: double;

  pin, pout: Tpex;

  ms_loop: double;    // 216b

begin
  if fb_kludge <> 0 then
    EXIT;   // 208a guide marks not wanted on FB foot templates

  dummy_p.x := 0;    // 206b init
  dummy_p.y := 0;    // 206b init

  p1.x := pegx;          // first do the fixing peg...
  p1.y := pegy;

  p2.x := 0;    // not used for peg.
  p2.y := 0;

  enter_mark(True, p1, p2, eMC__1_PegCentre, '');      // fixing peg - goes on the pad only.

  // calculate peg arm marks...

  docurving(True, True, pegx, pegy, p1.x, p1.y, tempk, temp);
  // curve and transform peg to get position.

  arm_long := peg_arm_length;

  p2.x := p1.x - arm_long * COS(arm_angle);
  p2.y := p1.y - arm_long * SIN(arm_angle);

  fill_mark(convert_point(p1), convert_point(p2), eMC_8_PegArm_1, '');   // first arm.

  p2.x := p1.x + arm_long * COS(arm_angle);
  p2.y := p1.y + arm_long * SIN(arm_angle);

  fill_mark(convert_point(p1), convert_point(p2), eMC_9_PegArm_2, '');   // second arm.

  // next comes the label position...

  if plain_track = False then begin
    if half_diamond = True then
      p1.x := (dpx + fpx * 2) / 3   // half-diamond label top-left. (dpx+ 2/3 of lead to fpx).
    else
      p1.x := dpx;            // turnout label top-left at deflection point.
    p1.y := g / 2;
  end
  else begin
    p1.x := xorg / 2;     // for plain track label at mid point.
    p1.y := g / 2;
  end;

  if p1.x > (turnoutx * 3 / 4) then
    p1.x := turnoutx * 3 / 4;   // 0.82.a   not more than 3/4 of template length.

  p2.x := 0;   // not used.
  p2.y := 0;

  enter_mark(True, p1, p2, eMC__5_Label, '');

  // now do other marks...

  gm := 4 * inscale;       // 8" overall size of centre-line guide-marks.

  gmi := 5 * inscale;      // 5" scale length of mark inside gauge-face.
  gmo := gmi;            // 5" scale ditto beyond outer-edge.

  gm_swlabels_ms := g / 2 + 42 * inscale;
  // long toe and planing marks (to clear fixed timbers and numbers) 206b
  gm_swlabels_ts := g / 2 + 42 * inscale;
  // long set and stock gauge marks (to clear fixed timbers) 206b

  gm_xinglabels_ms := g + 66 * inscale;
  // long FP and blunt nose mark (to clear fixed timbers and numbers) 211b
  gm_xinglabels_ts := g + 75 * inscale;
  // long FP and blunt nose mark (to clear fixed timbers) 211b

  gm_hdlabels_ms := g / 2 + 36 * inscale;
  // long HD blunt tips mark (to clear fixed timbers and numbers) 211b
  gm_hdlabels_ts := g / 2 + 54 * inscale;  // long HD blunt tips mark (to clear fixed timbers) 211b


  if (guide_marks = True) and ((ABS(nomrad) < max_rad_test) or (spiral = True)) and
    (turnoutx <> 0)  // 0.93.a  (turnoutx<>0) added
  then begin            // rad centre markers. don't call enter_mark - no curving wanted.

    if ((spiral = True) and (ABS(nomrad1) < 1.0E6))
      // 1E6 arbitrary max radius for marking centres (mm).
      or ((spiral = False) and (ABS(nomrad) < 1.0E6)) then begin
      // rad 1 centre marker...    (p2=0)
      pin.x := xt1;
      pin.y := yt1;
      dotransform(kform, xform, yform, pin, pout);

      pout.x := pout.x + xshift;
      pout.y := pout.y + yshift;

      p1 := pout;

      p2.x := 0;              // not used.
      p2.y := 0;

      fill_mark(convert_point(p1), convert_point(p2), eMC__2_CurvingRadiusCentre_1, '');
      // rad 1 mark location

      if slewing = True     // centre(s) of slewed over portion ...
      then begin
        // slewed rad 1 centre marker...    (p2=0)
        pin.x := xt1 - slew * SIN(slew_t);
        pin.y := yt1 + slew * COS(slew_t);

        dotransform(kform, xform, yform, pin, pout);

        pout.x := pout.x + xshift;
        pout.y := pout.y + yshift;

        p1 := pout;

        p2.x := 0;              // not used.
        p2.y := 0;

        fill_mark(convert_point(p1), convert_point(p2), eMC__2_CurvingRadiusCentre_1, '');
        // rad 1 slewed mark location

      end;
    end;//rad 1

    if (spiral = True) and (ABS(nomrad2) < 1.0E6)      // rad 2 centre marker ...
    then begin
      pin.x := xt2;
      pin.y := yt2;
      dotransform(kform, xform, yform, pin, pout);

      pout.x := pout.x + xshift;
      pout.y := pout.y + yshift;

      p1 := pout;

      p2.x := 0;    // not used.
      p2.y := 0;

      fill_mark(convert_point(p1), convert_point(p2), eMC__3_CurvingRadiusCentre_2, '');
      // rad 2 mark location.


      if slewing = True      // slewed rad 2 centre marker ...
      then begin
        pin.x := xt2 - slew * SIN(slew_t);
        pin.y := yt2 + slew * COS(slew_t);

        dotransform(kform, xform, yform, pin, pout);

        pout.x := pout.x + xshift;
        pout.y := pout.y + yshift;

        p1 := pout;

        p2.x := 0;    // not used.
        p2.y := 0;

        fill_mark(convert_point(p1), convert_point(p2), eMC__3_CurvingRadiusCentre_2, '');
        // rad 2 slewed mark location.
      end;
    end;//rad 2
  end;

  // transition curve,  also for plain track....

  if (rad_ends = True) and (spiral = True) and (turnoutx <> 0)  // 0.93.a  (turnoutx<>0) added
  then begin
    p1.x := os;
    p1.y := 0 - g;                          // mark start of transition zone.
    p2.x := os;
    p2.y := g * 2;                          // wide mark across g beyond gauge face each side.
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := os;
    p1.y := g * 2;                          // mark start of transition zone.
    p2.x := os + g * 2;
    p2.y := g / 2;                          // put an arrow on the start marker.
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := os;
    p1.y := 0 - g;                          // mark start of transition zone.
    p2.x := os + g * 2;
    p2.y := g / 2;                          // put an arrow on the start marker.
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := os + tst;
    p1.y := 0 - g;                          // mark end of transition zone.
    p2.x := os + tst;
    p2.y := g * 2;                          // wide mark across g beyond gauge face each side.
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := os + tst;
    p1.y := g * 2;                          // mark end of transition zone.
    p2.x := os + tst - scale * 4;
    p2.y := g * 2;                          // put a 4ft scale top on the end marker.
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := os + tst;
    p1.y := 0 - g;                          // mark end of transition zone.
    p2.x := os + tst - scale * 4;
    p2.y := 0 - g;                          // put a 4ft tail on the end marker.
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

  end;

  // slewing zone...

  if (rad_ends = True) and (slewing = True) and (turnoutx <> 0)  // 0.93.a  (turnoutx<>0) added
  then begin
    p1.x := slew_s;
    p1.y := 0 - g * 3 / 2;                        // mark start of slewing zone.
    p2.x := slew_s;
    p2.y := g * 5 / 2;                          // mark across beyond gauge face each side.
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s;                         // then 2 arrows on start mark...
    p1.y := g * 3 / 2;
    p2.x := slew_s + g;
    p2.y := g * 2;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s + g;
    p1.y := g * 2;
    p2.x := slew_s;
    p2.y := g * 5 / 2;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s;
    p1.y := 0 - g / 2;
    p2.x := slew_s + g;
    p2.y := 0 - g;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s + g;
    p1.y := 0 - g;
    p2.x := slew_s;
    p2.y := 0 - g * 3 / 2;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s + slew_l;
    p1.y := g * 3 / 4;                            // 2 marks at end of slewing zone...
    p2.x := slew_s + slew_l;
    p2.y := g * 3;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s + slew_l;
    p1.y := g / 4;
    p2.x := slew_s + slew_l;
    p2.y := 0 - g * 2;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s + slew_l;
    p1.y := g / 4;                            // add arms to end mark.
    p2.x := slew_s + slew_l - g;
    p2.y := g / 4;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

    p1.x := slew_s + slew_l;
    p1.y := g * 3 / 4;
    p2.x := slew_s + slew_l - g;
    p2.y := g * 3 / 4;
    enter_mark(True, p1, p2, eMC_7_TransitionAndSlewing, '');

  end;

  if cl_only = True then
    EXIT;     // only peg, rad centres and transition/slewing marks wanted.

  // turnouts or plain track marks...

  if (guide_marks = True) and (centre_lines = True) and (track_centre_lines_flag = True) and
    (turnoutx <> 0)  // 0.93.a  (turnoutx<>0) added
  then begin
    // rail-end mark...
    p1.x := 0;
    p1.y := g / 2 - gm;
    p2.x := 0;
    p2.y := g / 2 + gm;
    enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.

    // rail-joint centre mark (or plain track end mark)...

    if plain_track = False then begin
      p1.x := xorg;
      p1.y := g / 2 - gm;
      p2.x := xorg;
      p2.y := g / 2 + gm;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.
    end
    else begin
      // prominent marks for plain track CTRL-1 rail joint (start) end...
      // use 3 marks to avoid overwriting the rail joints (already drawn by the plain track prog.)
      p1.x := xorg;
      p1.y := g - gmi;
      p2.x := xorg;
      p2.y := gmi;
      enter_mark(True, p1, p2, eMC_10_PlainTrackStart, '');      // mark vertical.

      p1.x := xorg;
      p1.y := g + railtop + gmo;
      p2.x := xorg;
      p2.y := g + railtop + gmo + g;
      enter_mark(True, p1, p2, eMC_10_PlainTrackStart, '');      // mark vertical.

      p1.x := xorg;
      p1.y := 0 - railtop - gmo;
      p2.x := xorg;
      p2.y := 0 - railtop - gmo - g;
      enter_mark(True, p1, p2, eMC_10_PlainTrackStart, '');      // mark vertical.

      ms_loop := 18 * inscale;    // 216b  size of maker loop  18"

      p1.x := xorg;
      p1.y := 0 - railtop - gmo - g;
      p2.x := xorg - ms_loop;
      p2.y := 0 - railtop - gmo - g;
      enter_mark(True, p1, p2, eMC_10_PlainTrackStart, '');
      // mark horizontal MS indicator loop 216a.

      p1.x := xorg - ms_loop;
      p1.y := 0 - railtop - gmo - g;
      p2.x := xorg - ms_loop;
      p2.y := 0 - railtop - gmo - g + ms_loop;     // loop
      enter_mark(True, p1, p2, eMC_10_PlainTrackStart, '');
      // mark vertical MS indicator loop 216a.

      p1.x := xorg - ms_loop;
      p1.y := 0 - railtop - gmo - g + ms_loop;
      p2.x := xorg;
      p2.y := 0 - railtop - gmo - g + ms_loop;     // loop
      enter_mark(True, p1, p2, eMC_10_PlainTrackStart, '');
      // mark horizontal MS indicator loop 216a.

    end;
  end;

  if (guide_marks = True) and (plain_track = False)    // turnouts only guide marks...
  then begin

    // joggle marks ...

    if (joggled = True) and (gaunt = False) and (half_diamond = False)   // h_d added 208a
    then begin

      if (turnout_road_crossing_rail_flag = True) and (main_road_stock_rail_flag = True)
      // not if there is no switch blade or stock rail.
      then begin
        p1.x := toex - joggle_long;
        p1.y := gmi;

        p2.x := toex - joggle_long;
        p2.y := 0 - railtop - gmo;

        joggle_labels_p1 := p1;    // 206b

        enter_mark(True, p1, p2, eMC_1_GuideMark, '');
        // main-side joggle mark. scale 6" each side of rail.
      end;

      if (main_road_crossing_rail_flag = True) and (turnout_road_stock_rail_flag = True)
      // not if there is no switch blade or stock rail.
      then begin
        p1.x := setx - joggle_long;
        p1.y := g - gmi;
        p2.x := setx - joggle_long;
        p2.y := g + railtop + gmo;

        joggle_labels_p2 := p1;   // 206b

        enter_mark(True, p1, p2, eMC_1_GuideMark, '');
        // turnout-side joggle mark. scale 6" each side of rail.
      end;

      // 206b  joggle label...

      if (turnout_road_crossing_rail_flag = True) and (main_road_stock_rail_flag = True) and
        (main_road_crossing_rail_flag = True) and (turnout_road_stock_rail_flag = True) then begin
        enter_mark(True, joggle_labels_p1, joggle_labels_p2, eMC_600_LongMark, '');
        // long joggle mark across track linking first marks

        joggle_labels_p2.y := g / 2;

        enter_mark(True, joggle_labels_p2, dummy_p, eMC_605_JoggleLabel, '');
        // joggle label on centre of joggle mark

      end;

    end;


    // toe marks ...   206b changes...

    if gaunt = False    // 215a  flags ignored (for slip switches)
    then begin
      p1.x := toex;
      p1.y := gmi;

      p2.x := toex;                            // 206b *TAN(k1/2);
      p2.y := 0 - railtop - gmo;

      enter_mark(True, p1, p2, eMC_1_GuideMark, '');
      // normal toe mark (trackpad). each side of rail.

      if half_diamond = False   // 208a
      then begin

        p2.y := 0 - gm_swlabels_ms;
        // 206b longer mark to clear timbers after fixing on template

        enter_mark(True, p1, p2, eMC_600_LongMark, '');
        // long toe mark (overwrite on output). each side of rail.

        enter_mark(True, p2, dummy_p, eMC_601_TipsLabel, '');    // 206b toe tips label
      end;
    end;

    if gaunt = False       // 215a
    then begin
      p1.x := setx;
      p1.y := g - gmi;

      p2.x := setx;
      p2.y := g + railtop + gmo;

      enter_mark(True, p1, p2, eMC_1_GuideMark, '');
      // normal set mark (trackpad). each side of rail.

      if half_diamond = False   // 208a
      then begin
        p2.y := g + gm_swlabels_ts;
        // 206b longer mark to clear timbers after fixing on template

        enter_mark(True, p1, p2, eMC_600_LongMark, '');
        // long set mark (overwrite on output). each side of rail.

        enter_mark(True, p2, dummy_p, eMC_602_SetLabel, '');    // 206b set label
      end;
    end;

    if (midline = False) and ((half_diamond = False) or (fixed_diamond = False)) and
      (gaunt = False)    // no planing end marks if drawing rail centreline only or this is a fixed-diamond.
    then begin

      {if turnout_road_crossing_rail_flag=True // not if no switch blade.
                         then begin}
      p1.x := plox;
      p1.y := railtop + gmi;

      p2.x := plox;
      p2.y := 0 - railtop - gmo;

      enter_mark(True, p1, p2, eMC_1_GuideMark, '');
      // normal planing end mark (trackpad). each side of rail.

      if half_diamond = False   // 208a
      then begin

        p2.y := 0 - gm_swlabels_ms;

        enter_mark(True, p1, p2, eMC_600_LongMark, '');
        // long planing end mark (overwrite on output). each side of rail.

        enter_mark(True, p2, dummy_p, eMC_603_PlaningLabel, '');
        // planing end label  206b
      end;
      //end;

      {if main_road_crossing_rail_flag=True  // not if no switch blade.
                         then begin}
      p1.x := stox;
      p1.y := g - gmi;

      p2.x := stox;
      p2.y := g + railtop + railtop + gmo;

      enter_mark(True, p1, p2, eMC_1_GuideMark, '');
      // normal stock gauge mark (trackpad). each side of rail.

      if half_diamond = False   // 208a
      then begin

        p2.y := g + railtop + gm_swlabels_ts;

        enter_mark(True, p1, p2, eMC_600_LongMark, '');
        // long stock gauge mark (overwrite on output). each side of rail.

        enter_mark(True, p2, dummy_p, eMC_604_StockGaugeLabel, '');
        // stock gauge label  206b
      end;
      //end;
    end;

    // 211b half-diamond...

    if (midline = False) and (half_diamond = True) and (fixed_diamond = True) and (gaunt = False)
    // no diamond points mark if rail centreline only or this is a fixed-diamond.
    then begin

      if (turnout_road_crossing_rail_flag = True) or (main_road_crossing_rail_flag = True)
      // either rail, mark across both
      then begin

        if tradius_is_straight = True    // regular diamond

        then
          p1 := draw_xing_label(hdk / 2, seg_termx[3, eRD_CurvedTurnoutWingGaugeFace],
            0 - gm_hdlabels_ms, g + gm_hdlabels_ts, fw, 0, 0)
        // 211b do blunt nose marks, and get BN note position
        else begin
          // irregular diamond

          k_irreg := hdk + seg_termx[3, eRD_CurvedTurnoutWingGaugeFace] / tradius;
          // angle at tips

          p1 :=
            draw_xing_label(k_irreg / 2, seg_termx[3, eRD_CurvedTurnoutWingGaugeFace],
            0 - gm_hdlabels_ms, g + gm_hdlabels_ts, fw, 0, 0);
        end;

        if (p1.x <> 0) and (p1.y <> 0) then
          fill_mark(convert_point(p1), convert_point(dummy_p), eMC_703_XingLabelEnd, 'bt');
        // label note into marks list ('bt' string ignored, label added for 703 code in print_unit, pdf_unit).

      end;

    end;

    // knuckle marks  214a ...

    if ((turnout_road_crossing_rail_flag = True) and
      (main_road_crossing_rail_flag = True))   // both rails
      and (knuckle_code <> -1)
    // no marks if sharp bend
    then begin

      p1.x := wingcx_minus;
      p1.y := g;

      p2.x := wingx_minus;
      p2.y := g - fw - wing_bend_offset;

      enter_mark(True, p1, p2, eMC_1_GuideMark, '');    // start of knuckle bend


      p1.x := wingcx;
      p1.y := g;

      p2.x := wingx;
      p2.y := g - fw;

      enter_mark(True, p1, p2, eMC_1_GuideMark, '');    // knuckle - middle of knuckle bend


      p1.x := wingcx_plus;
      p1.y := g + wing_bend_offset;

      p2.x := wingx_plus;
      p2.y := g - fw;

      enter_mark(True, p1, p2, eMC_1_GuideMark, '');    // end of knuckle bend

    end;


    // f.p. cross mark

    if ((turnout_road_crossing_rail_flag = True) and
      (main_road_crossing_rail_flag = True))   // both rails
      or (crossing_vee_flag = True)
    // or vee
    then begin

      p1.x := fpx - 1.5 * inscale;
      // fine point target horizontal 3 scale inches overall size.
      p1.y := g;
      p2.x := fpx + 1.5 * inscale;
      p2.y := g;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark f.p. target horizontal.

      p1.x := fpx;
      p1.y := g - inscale;           // and 2 scale inches overall vertical.
      p2.x := fpx;
      p2.y := g + inscale;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark f.p. target vertical.

      // crosing label mods 211b...

      // for equalized label marker lines, must do curving and transforms and fill_mark directly ...

      p1 := draw_xing_label(k3 / 2, fpx, g / 2, g - 3 * inscale, g, 0, 0);
      // 211b do short FP mark

      p1 := draw_xing_label(k3 / 2, fpx, g + 3 * inscale, g + gm_xinglabels_ts +
        6 * inscale, g, 0 - scale, 15 * inscale);
      // 211b do long FP marks, and get FP note position

      if (p1.x <> 0) and (p1.y <> 0) then
        fill_mark(convert_point(p1), convert_point(dummy_p), eMC_701_XingFPLabel, 'fp');
      // label note into marks list ('fp' string ignored, label added for 701 code in print_unit, pdf_unit).

    end;

    if (midline = False) and (crossing_vee_flag = True)     // blunt nose label  211b...
    then begin
      // for equalized label marker lines, must do curving and transforms and fill_mark directly ...

      p1 := draw_xing_label(k3 / 2, bnx, g - gm_xinglabels_ms, g + gm_xinglabels_ts,
        g, scale, 18 * inscale);
      // 211b do blunt nose marks, and get BN note position

      if (p1.x <> 0) and (p1.y <> 0) then
        fill_mark(convert_point(p1), convert_point(dummy_p), eMC_702_XingBluntNoseLabel, 'bn');
      // label note into marks list ('bn' string ignored, label added for 702 code in print_unit, pdf_unit).

    end;


    if (centre_lines = True) and (track_centre_lines_flag = True) then begin
      // toe centre-line mark...
      p1.x := toemidx;
      p1.y := g / 2 - gm;
      p2.x := toemidx;
      p2.y := g / 2 + gm;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.

      // d.p. mark...
      p1.x := dpx;
      p1.y := g / 2 - gm;
      p2.x := dpx;
      p2.y := g / 2 + gm;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.

      // turnout side crossover mid-point mark...
      p1.x := txpx;
      p1.y := txpy - gm;
      p2.x := txpx;
      p2.y := txpy + gm;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.

      // main side crossover mid-point mark...
      p1.x := mxpx;
      p1.y := g / 2 - gm;
      p2.x := mxpx;
      p2.y := g / 2 + gm;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.


      // turnout side vee joint (splice rail end) centre mark...

      temp := aq25offset(tvjpx, tempk);
      p1.x := tvjpx;
      p1.y := temp - gm;
      p2.x := tvjpx;
      p2.y := temp + gm;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.

      // main side vee joint (point rail end) centre mark...
      p1.x := mvjpx;
      p1.y := g / 2 - gm;
      p2.x := mvjpx;
      p2.y := g / 2 + gm;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.


      if retpar_i = 1
      // main side return-point mark...  (turnout-side mark is a rad-end mark instead).
      then begin
        p1.x := mrpx;
        p1.y := g / 2 - gm;
        p2.x := mrpx;
        p2.y := g / 2 + gm;
        enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // mark vertical.
      end;

    end;
  end;

  // tie-bar centre mark...

  if (switch_drive_markx = True) and (switch_drive_flag = True) and
    (plain_track = False) and (half_diamond = False) and (gaunt = False) then begin
    tbe := scale;         // tie-bar ends 1ft scale beyond gauge.
    tbw := 2 * inscale;     // tie-bar half-width 2" scale.

    xtb := toex + 18 * inscale;
    // now fixed at 18" from toe to tie-bar. (mod mainly for slip switches) // 0.82.a  13-10-06

    if (turnout_road_crossing_rail_flag = True) or (main_road_crossing_rail_flag = True)
    // not if no switch blades.
    then begin
      p1.x := xtb - tbw;
      p1.y := g + tbe;
      p2.x := xtb + tbw;
      p2.y := g + tbe;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // top end of tie-bar.

      p1.x := xtb - tbw;
      p1.y := 0 - tbe;
      p2.x := xtb + tbw;
      p2.y := 0 - tbe;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // bottom end of tie-bar.

      p1.x := xtb - tbw;
      p1.y := g + tbe;
      p2.x := xtb - tbw;
      p2.y := 0 - tbe;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // left side of tie-bar.

      p1.x := xtb + tbw;
      p1.y := g + tbe;
      p2.x := xtb + tbw;
      p2.y := 0 - tbe;
      enter_mark(True, p1, p2, eMC_1_GuideMark, '');      // right side of tie-bar.
    end;
  end;

  if (joint_marks = True) and (plain_track = False) then begin
    // switch front joints (we may be overwriting approach track joints already done)...

    if (omit_swfj_marks = False) and (csi.stock_rail > minfp) and (half_diamond = False)
    // ignore if stock rail length is zero (custom switch).
    then begin
      if turnout_road_stock_rail_flag = True then begin
        p1.x := xorg;
        p1.y := g - gmi;
        p2.x := xorg;
        p2.y := g + gmo + railtop;
        enter_mark(True, p1, p2, eMC_6_RailJoint, '');  // curved stock rail end joint mark.
      end;

      if main_road_stock_rail_flag = True then begin
        p1.x := xorg;
        p1.y := gmi;
        p2.x := xorg;
        p2.y := 0 - (gmo + railtop);
        enter_mark(True, p1, p2, eMC_6_RailJoint, '');
        // straight stock rail end joint mark.
      end;
    end;

    // switch rail joints...

    if ((half_diamond = False) and (gaunt = False)) or ((half_diamond = True) and
      (fixed_diamond = False) and (hd_switch_timbering = True))  // 213a
    then begin
      if (omit_swrj_marks = False) and (csi.switch_rail > minfp)
      // ignore if switch rail length is zero (custom switch).
      then begin
        tempx := toex + csi.switch_rail * inscale;
        // switch rail length (from TOE).
        tempy := aq3offset(tempx, k);
        // offset to aq=3 (curved stock rail). also returns k angle.
        tempcos := COS(k);
        tempsin := SIN(k);
        if ABS(tempcos) > minfp then
          tempy := tempy - g / tempcos   // back to curved switch rail (aq=1).
        else
          tempy := tempy - g;

        if turnout_road_crossing_rail_flag = True then begin
          p1.x := tempx + gmo * tempsin;
          // ignore rail-width - so mark is offset to the gauge side.
          p1.y := tempy - gmo * tempcos;
          p2.x := tempx - gmi * tempsin;
          p2.y := tempy + gmi * tempcos;
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // curved switch rail joint mark.
        end;

        if main_road_crossing_rail_flag = True then begin
          p1.x := tempx;
          // ignore rail-width - so mark is offset to the gauge side.
          p1.y := g + gmo;
          p2.x := tempx;
          p2.y := g - gmi;
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // straight switch rail joint mark.
        end;
      end;
      // stock rail joints...

      if (omit_skj_marks = False) and (csi.stock_rail > minfp)
      // ignore if stock rail length is zero (custom switch).
      then begin

        if half_diamond = True
        // 213a timbering movable K-crossing as a switch..

        then
          tempx := toex + (csi.stock_rail - csi.switch_front_inches) * inscale   // K-crossing
        else
          tempx := xorg + csi.stock_rail * inscale;   // turnout stock rail length (from JOINT).

        tempy := aq3offset(tempx, k);
        // offset to aq=3 (curved stock rail). also returns k angle.
        tempcos := COS(k);
        tempsin := SIN(k);

        if turnout_road_stock_rail_flag = True then begin
          p1.x := tempx - (gmo + railtop) * tempsin;
          p1.y := tempy + (gmo + railtop) * tempcos;
          p2.x := tempx + (gmi - railtop) * tempsin;
          // offset mark to outer edge.
          p2.y := tempy - (gmi - railtop) * tempcos;
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // curved stock rail joint mark.
        end;

        if main_road_stock_rail_flag = True then begin
          p1.x := tempx;
          p1.y := gmi - railtop;
          p2.x := tempx;
          p2.y := 0 - (gmo + railtop);
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // straight stock rail joint mark.
        end;
      end;
    end
    else begin    // normal half_diamond (wing rail joints, not point rails NYI) ...

      if (omit_kx_marks = False) and ((hd_proto_timbering = True) or (fixed_diamond = False)) and
        (gaunt = False)
      // no joints if non prototypical fixed-crossing spacings.
      then begin

        if use_k_custom_wing_rails = True      // // 0.95.a
        then
          kwl := k_custom_wing_long / 2
        else begin
          if fixed_diamond = True then begin
            if hdkn <= 6.375       // 0.94.a bug fix was k3n
            then begin
              if rail_section <> 2   // BH or none.
              then
                kwl := 173 / 2   //  14'5" BH k-wing rails overall.
              else
                kwl := 168 / 2;  //  14'0" FB.
            end
            else begin
              if rail_section <> 2   // BH or none.
              then
                kwl := 185 / 2   //  15'5" BH k-wing rails overall.
              else
                kwl := 220 / 2;  //  18'4" FB.
            end;
          end
          else begin
            if rail_section <> 2 then
              kwl := 216      // BH 18'0"
            else
              kwl := 193;     // FB 16'1" half-switch-diamond wing rail.
          end;
        end;

        tempx := setx + (kwl * inscale * COS(hdk / 2)); // 0.95.a  was k3
        tempy := aq3offset(tempx, k);
        // offset to aq=3 (curved stock rail). also returns k angle.
        tempcos := COS(k);
        tempsin := SIN(k);

        if turnout_road_stock_rail_flag = True then begin
          p1.x := tempx - (gmo + railtop) * tempsin;
          p1.y := tempy + (gmo + railtop) * tempcos;
          p2.x := tempx + gmi * tempsin;
          // offset mark to outer edge.
          p2.y := tempy - gmi * tempcos;
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // curved stock rail joint mark.
        end;

        if main_road_stock_rail_flag = True then begin

          tempx := toex + (kwl * inscale / COS(hdk / 2));  // 0.95.a  was k3

          p1.x := tempx;
          p1.y := gmi;
          p2.x := tempx;
          p2.y := 0 - railtop - gmo;
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // straight stock rail joint mark.
        end;
      end;
    end;

    // crossing (wing rail front) joints...

    if (half_diamond = False) or (hd_vcheck_rails = 0) or (k3n > 7.99)
    // 205a  remove joint marks if slip and shorter than 1:8
    then begin

      if (omit_wj_marks = False) and (no_timbering = False)
      // need the timbering calcs for these.
      then begin
        tempx := (xtbzz + xtbz) / 2;

        if main_road_crossing_rail_flag = True then begin
          p1.x := tempx;
          // crossing joint timber centres.
          p1.y := g + gmo + railtop;
          p2.x := tempx;
          p2.y := g - gmi;
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // straight turnout rail crossing joint mark.
        end;

        tempx := fpx - (fpx - tempx) * COS(k3);
        //  move crossing joint in turnout rail (ignores turnout rad).

        tempy := aq2offset(tempx, k);
        tempcos := COS(k);
        tempsin := SIN(k);

        if turnout_road_crossing_rail_flag = True then begin
          p1.x := tempx - gmi * tempsin;
          p1.y := tempy + gmi * tempcos;
          p2.x := tempx + (gmo + railtop) * tempsin;
          p2.y := tempy - (gmo + railtop) * tempcos;
          enter_mark(True, p1, p2, eMC_6_RailJoint, '');
          // curved turnout rail crossing joint mark.
        end;
      end;
    end;

    //  vee point and splice rail joints ...

    if (omit_vj_marks = False) and (crossing_vee_flag = True) then begin

      if xing_calc_i = 1     // joint position and angles for curviform V-crossing...
      then begin
        if Abs(tradius) < minfp then
          tempk := k4_limit
        else
          tempk := ARCSIN((bnx - fpx) / tradius) + veelong / tradius + k3;
        // angle to joint for curviform V-crossing.

        if Abs(tempk) > k4_limit then
          tempk := SGZ(tempk) * k4_limit;   // can't exceed swing limit. (90 degs approx).

        tempx := torgx + tradius * SIN(tempk);   // x to joint
        tempcos := COS(tempk);
        tempsin := SIN(tempk);
      end
      else begin
        tempx := bnx + veelong * COS(k3);
        // x to splice rail joint, straight crossing.
        // also for parallel crossing, even if on return curve - slight error?
        tempcos := COS(k3);              // straight crossing.
        tempsin := SIN(k3);
      end;

      tempy := aq2offset(tempx, k);

      p1.x := tempx - gmi * tempsin;
      p1.y := tempy + gmi * tempcos;
      p2.x := tempx + (gmo + railtop) * tempsin;
      p2.y := tempy - (gmo + railtop) * tempcos;
      enter_mark(True, p1, p2, eMC_6_RailJoint, '');             // splice rail joint mark.

      tempx := mvjpx;

      p1.x := tempx;
      p1.y := g - gmi;
      p2.x := tempx;
      p2.y := g + gmo + railtop;
      enter_mark(True, p1, p2, eMC_6_RailJoint, '');    // point rail joint mark.
    end;
  end;
  // radial end marks...

  if (rad_ends = True) and (plain_track = False)
    // mark across gauge-faces at each end of curves.
    and ((turnout_road_stock_rail_flag = True) or (turnout_road_crossing_rail_flag = True))
  // only if there is some rail to mark.
  then begin
    // start of switch curve (end of planing)...

    if (Abs(k1 - k2) > minfp) and (swrad < max_rad_test) and (half_diamond = False)
    // (do nothing for straight switch.)
    then begin
      if switch_type = 0
      // curved planing, switch curve starts at toe (mark across between tips instead of strictly radial).
      then begin
        p1.x := setx;
        p1.y := g;
        p2.x := toex;
        p2.y := 0;
        enter_mark(True, p1, p2, eMC_2_RadialEnd, '');
      end
      else begin
        //  semi-curved switch (mark across between planing end marks instead of strictly radial).

        p1.x := stox;
        p1.y := g + j;
        p2.x := plox;
        p2.y := j;

        enter_mark(True, p1, p2, eMC_2_RadialEnd, '');
      end;
    end;

    if tradius_is_straight = False then begin
      if half_diamond = False   // turnout only (and gaunt curve start).
      then begin
        p1.x := torgx + csradius * SIN(k2);
        // switch curve end / turnout curve start.
        p1.y := torgy - csradius * COS(k2);
        p2.x := torgx + tradius * SIN(k2);     //^^^
        p2.y := torgy - tradius * COS(k2);     //^^^
        enter_mark(True, p1, p2, eMC_2_RadialEnd, '');
      end;

      if xing_calc_i <> 1     // not curviform V-crossing
      then begin
        p1.x := torgx + csradius * SIN(k3);    // turnout/diagonal curve end.
        p1.y := torgy - csradius * COS(k3);
        p2.x := torgx + tradius * SIN(k3);     //^^^
        p2.y := torgy - tradius * COS(k3);     //^^^
        enter_mark(True, p1, p2, eMC_2_RadialEnd, '');
      end;
    end
    else begin                     // straight turnout radius.
      if (half_diamond = False) and (gaunt = False) then begin
        p1.x := sworgx + (swrad - g) * SIN(k2);    // switch "curve" end mark.
        p1.y := sworgy - (swrad - g) * COS(k2);
        p2.x := sworgx + swrad * SIN(k2);
        p2.y := sworgy - swrad * COS(k2);
        enter_mark(True, p1, p2, eMC_2_RadialEnd, '');
      end;
    end;
  end;


  // return curves..

  if (rad_ends = True) and (plain_track = False) and (retpar_i = 1) and
    (crossing_vee_flag = True) and (turnout_road_stock_rail_flag = True) then begin
    p1.x := retrorgx - (retr + g / 2) * SIN(k3);         // return curve start.
    p1.y := retrorgy + (retr + g / 2) * COS(k3);
    p2.x := retrorgx - (retr - g / 2) * SIN(k3);
    p2.y := retrorgy + (retr - g / 2) * COS(k3);
    enter_mark(True, p1, p2, eMC_2_RadialEnd, '');

    p1.x := retrorgx;                          // return curve end.
    p1.y := trtscent + g;
    p2.x := retrorgx;
    p2.y := trtscent;
    enter_mark(True, p1, p2, eMC_2_RadialEnd, '');
  end;
end;
//_______________________________________________________________________________________

procedure do_railends;      // calc rail end marks...

var
  aq: ERailData;
  p1, p2: Tpex;

  aq_begin, aq_end: ERailData;

  start_boundary, end_boundary: double;

begin
  for aq in ERailData do begin
    endmarks_yn[aq, 0] := False;         // init defaults.
    endmarks_yn[aq, 1] := False;
  end;

  if {(railend_marks=False) or} (plain_track = True) and (draw_ts_platform = False) and
    (draw_ms_platform = False) then
    EXIT;

  if plain_track = True then begin
    aq_begin := eRD_AdjTrackTurnoutSideNearGaugeFace;   // platform ends
    aq_end := eRD_AdjTrackMainSideFarOuterFace;
  end
  else begin
    aq_begin := eRD_StraightStockGaugeFace;         // turnout
    aq_end := eRD_Unused;
  end;

  for aq := aq_begin to aq_end do begin

    if cl_only = True     // platforms /trackbed only
    then begin
      if not (aq in eRD_AdjacentTracks) then
        CONTINUE;
    end;

    if aqyn[aq] = True then begin
      case aq of

        eRD_AdjTrackTurnoutSideNearGaugeFace,
        eRD_AdjTrackTurnoutSideNearOuterFace,
        eRD_AdjTrackMainSideNearGaugeFace,
        eRD_AdjTrackMainSideNearOuterFace: begin
          start_boundary := startx - scale;
          //minfp_big;   // platforms - increase limits by 1ft to show ends always
          end_boundary := turnoutx + scale; //minfp_big;
        end;

        else begin
          start_boundary := startx + minfp_big;
          // rails - reduce limits to exclude ends if rail not complete
          end_boundary := turnoutx - minfp_big;
        end;
      end;//case

      p1 := xy_ends[aq, 0];        // start end of rail
      p2 := xy_ends[aq, 1];        // finish end of rail

      if (p1.x < end_boundary) and (p1.x > start_boundary) then begin
        endmarks[aq, 0] := convert_point(curve_point(p1));
        endmarks_yn[aq, 0] := True;
      end;

      if (p2.x < end_boundary) and (p2.x > start_boundary) and (ABS(p2.x - p1.x) > minfp_big)
      // ignore end mark if same position as start mark.
      then begin
        endmarks[aq, 1] := convert_point(curve_point(p2));
        endmarks_yn[aq, 1] := True;
      end;
    end;
  end;//for
end;
//_____________________________________________________________________________________________

procedure draw_rail_endmarks(on_canvas: TCanvas; ink: boolean);       // draw the rail ends.

var
  P1, P2: TPoint;
  move_to, line_to: TPoint;

  ////////////////////////////////////////////////////////////////////////

  procedure mark_end(aq1: ERailData; aq1end: integer; aq2: ERailData;
    aq2end: integer; pen_solid: boolean);
  // make the mark

  begin
    try

      if (endmarks_yn[aq1, aq1end] = True) and (endmarks_yn[aq2, aq2end] = True) then begin
        P1 := endmarks[aq1, aq1end];
        P2 := endmarks[aq2, aq2end];

        with on_canvas do begin

          Pen.Width := 1;

          Brush.Color := paper_colour;  // gaps in dotted lines.
          Brush.Style := bsSolid;

          if pen_solid = True then
            Pen.Style := psSolid   // 0.93.a mods for platforms
          else
            Pen.Style := psDot;

          if ink = True                           // not erasing ?
          then begin
            if (aq1 = eRD_AdjTrackTurnoutSideNearGaugeFace) or
              (aq1 = eRD_AdjTrackMainSideNearGaugeFace)     // 0.93.a platforms
            then
              Pen.Color := guide_colour
            else
              Pen.Color := rail_colour;
          end
          else
            Pen.Color := paper_colour;      // erase existing marks.

          Pen.Mode := pmCopy;

          move_to.X := Round(P1.X * sx + ex - gx);
          move_to.Y := Round((P1.Y + yd) * sy + by - gy);
          line_to.X := Round(P2.X * sx + ex - gx);
          line_to.Y := Round((P2.Y + yd) * sy + by - gy);
          if check_limits(move_to, line_to) = True then begin
            MoveTo(move_to.X, move_to.Y);
            LineTo(line_to.X, line_to.Y);
          end;
        end;//with
      end;
    except
      EXIT;   // ignore rail-end mark if any calc errors.
    end;
  end;
  ////////////////////////////////////////////////////////////

begin

  // 0.93.a platform ends ...

  // 0.93.a TS platform start

  mark_end(eRD_AdjTrackTurnoutSideNearGaugeFace, 0, eRD_AdjTrackTurnoutSideNearOuterFace, 0,
    draw_ts_platform_start_edge);

  // 0.93.a TS platform end

  mark_end(eRD_AdjTrackTurnoutSideNearGaugeFace, 1, eRD_AdjTrackTurnoutSideNearOuterFace, 1,
    draw_ts_platform_end_edge);

  // 0.93.a MS platform start

  mark_end(eRD_AdjTrackMainSideNearGaugeFace, 0, eRD_AdjTrackMainSideNearOuterFace,
    0, draw_ms_platform_start_edge);

  // 0.93.a MS platform end

  mark_end(eRD_AdjTrackMainSideNearGaugeFace, 1, eRD_AdjTrackMainSideNearOuterFace,
    1, draw_ms_platform_end_edge);

  if plain_track = False then begin                                       // mark rail-ends...

    //            if off_screen=True then pad_canvas:=pad_bmp.Canvas
    //                               else pad_canvas:=pad_form.Canvas;

    mark_end(eRD_StraightTurnoutWingGaugeFace, 1, eRD_StraightTurnoutWingOuterFace, 1, True);
    // main rail wing rail finish. Solid line.
    mark_end(eRD_CurvedTurnoutWingGaugeFace, 1, eRD_CurvedTurnoutWingOuterFace, 1, True);
    // turnout rail wing rail finish.

    mark_end(eRD_MainSideCheckGaugeFace, 0, eRD_MainSideCheckOuterFace, 0, True);
    // main side check rail start.
    mark_end(eRD_MainSideCheckGaugeFace, 1, eRD_MainSideCheckOuterFace, 1, True);
    // main side check rail finish.

    mark_end(eRD_TurnoutSideCheckGaugeFace, 0, eRD_TurnoutSideCheckOuterFace, 0, True);
    // turnout side check rail start.
    mark_end(eRD_TurnoutSideCheckGaugeFace, 1, eRD_TurnoutSideCheckOuterFace, 1, True);
    // turnout side check rail finish.

    mark_end(eRD_VeePointGaugeFace, 0, eRD_VeeSpliceGaugeFace, 0, True);    // blunt nose.

    if (half_diamond = True) and (fixed_diamond = True) then begin
      if isolated_crossing = False    // 217a
      then begin
        mark_end(eRD_StraightTurnoutWingGaugeFace, 0, eRD_StraightTurnoutWingOuterFace, 0, True);
        // planed faced of point rails for a fixed-diamond. Solid line.
        mark_end(eRD_CurvedTurnoutWingGaugeFace, 0, eRD_CurvedTurnoutWingOuterFace, 0, True);
      end;

      mark_end(eRD_KCrossingCheckMainSideGaugeFace, 1,
        eRD_KCrossingCheckMainSideOuterEdge, 1, True);
      // MS K-crossing check rails.
      mark_end(eRD_KCrossingCheckTurnoutSideGaugeFace, 1, eRD_KCrossingCheckTurnoutSideOuterEdge,
        1, True);     // DS K-crossing check rails.
    end;
  end;
end;
//____________________________________________________________________________________________

function pad_marks_current(on_canvas: TCanvas; ink: boolean): boolean;
  // draw all the marks (control template). (not rail ends)
  // on the specified canvas.
var
  i: integer;
  code: EMarkCode;
  p1, p2, p3, p4: Tpoint;

  move_to, line_to: TPoint;
  peg_dim: integer;
  radcenx, radceny, radcen_dim: integer;

  ptr_1st: ^Tmark;         // pointers to a Tmark record..
  ptr_2nd: ^Tmark;
  markmax: integer;

  check_int1x, check_int1y, check_int2x, check_int2y: double;
  check_int3x, check_int3y, check_int4x, check_int4y: double;

  shove_dim, pad_shovex, pad_shovey: integer;

  infill_points: array[0..3] of TPoint;

  num_str, tbnum_str: string;
  half_stringwidth, half_stringheight: integer;
  temp_str: string;
  omitted: boolean;

  dummy_i: integer;

  pad_guide_marks: boolean;
  pad_timber_outlines: boolean;
  pad_timber_centres: boolean;
  pad_timber_numbers: boolean;

begin
  Result := False;  // default init.

  with pad_form do begin
    pad_guide_marks := show_current_template_guides_menu_entry.Checked;
    // 0.79.a  current_guides_menu_entry.Checked;
    pad_timber_outlines := current_timber_outlines_menu_entry.Checked;
    pad_timber_centres := current_timber_centres_menu_entry.Checked;
    pad_timber_numbers := current_timber_numbers_menu_entry.Checked;
  end;//with
  //###

  if marks_list_ptr = nil then
    EXIT;        // pointer to marks list not valid.
  markmax := High(marks_list_ptr);  // max index for the present list.

  if mark_index > markmax{_c} then
    mark_index := markmax{_c};  // ??? shouldn't be.

  tbnum_str := timb_numbers_str;
  // the full string of timber numbering for the control template.

  with on_canvas do begin

    for i := 0 to (mark_index - 1){markmax_c} do begin
      // (mark_index is always the next free slot)

      try
        ptr_1st := @marks_list_ptr[i];  // pointer to the next Tmark record.
        if ptr_1st = nil then
          EXIT;


        code := ptr_1st^.code;

        if code = eMC_0_Ignore then
          CONTINUE;
        // ignore mark entries with code zero (might be the second or third of a multi-mark entry, e.g. for timber infill).

        if code >= eMC_600_LongMark then
          CONTINUE;
        // 206b 211b ignore long marks and switch/xing labels for control template on trackpad  600,601-605, 700,701-703

        if ((code = eMC_203_TimberInfill)
          or (code = eMC_233_ShovedTimberInfill)
          or (code = eMC_293_ShovedTimberInfill)
          or (code = eMC_493_Chair))
          and (i < (mark_index - 1))
        // timber infill, chair outlines
        then begin
          ptr_2nd := @marks_list_ptr[i + 1];
          // pointer to the second infill Tmark record.
          if ptr_2nd = nil then
            EXIT;

          p3 := ptr_2nd^.p1;              // x3,y3 in  1/100ths mm
          p4 := ptr_2nd^.p2;              // x4,y4 in  1/100ths mm
        end
        else
          ptr_2nd := nil;    // keep compiler happy.

        p1 := ptr_1st^.p1;              // x1,y1 in  1/100ths mm

        if (code <> eMC_99_TimberNumber)
          and (code < eMC_501_MSWorkingEnd)  // 0.94.a  501-508 is check-rail labels
        then begin
          p2 := ptr_1st^.p2;    // x2,y2 in  1/100ths mm

          //Pen.Style:=ptr^.pen_style;
          Pen.Style := psSolid;  // solid lines look better on screen.
          Pen.Width := 1;

          if ink = True            // not erasing ?
          then begin
            case code of
              eMC__5_Label:
                CONTINUE;                                        // ignore label position.

              {
                                   -4: if paper_colour<>clBlack then Pen.Color:=clBlack // timber selector mark.
                                                                else Pen.Color:=clWhite;
                                  !!! removed 5-6-00}
              eMC__3_CurvingRadiusCentre_2,
              eMC__2_CurvingRadiusCentre_1:
                if pad_guide_marks = True then
                  Pen.Color := guide_colour  // curving rad centres.
                else
                  CONTINUE;
              eMC__1_PegCentre:
                if paper_colour <> clRed then
                  Pen.Color := clRed     // fixing peg.
                else
                  Pen.Color := clBlack;

              eMC_1_GuideMark:
                if pad_guide_marks = True then
                  Pen.Color := guide_colour  // guide marks.
                else
                  CONTINUE;

              eMC_2_RadialEnd:
                if pad_guide_marks = True then
                  Pen.Color := align_colour  // radial ends.
                else
                  CONTINUE;

              eMC_3_TimberOutline:
                if pad_timber_outlines = True then
                  Pen.Color := timber_colour   // timber outlines
                else
                  CONTINUE;

              eMC_4_TimberCL,
              eMC_14_TimberCLSolid:
                if pad_timber_centres = True then
                  Pen.Color := timber_colour   // timber centre-lines.
                else
                  CONTINUE;

              eMC_5_TimberReducedEnd:
                CONTINUE;    // timber reduced ends not on screen.

              eMC_6_RailJoint:
                if pad_guide_marks = True then
                  Pen.Color := joint_colour  // rail joint marks.
                else
                  CONTINUE;

              eMC_7_TransitionAndSlewing:
                if pad_guide_marks = True then
                  Pen.Color := trans_colour  // transition marks.
                else
                  CONTINUE;

              eMC_8_PegArm_1: begin                  // peg 1st arm.
                peg_arm1 := ptr_1st^;  // save mark for marking later.
                CONTINUE;            // next mark.
              end;

              eMC_9_PegArm_2: begin                  // peg 2nd arm.
                peg_arm2 := ptr_1st^;  // save mark for marking later.
                CONTINUE;            // next mark.
              end;

              eMC_10_PlainTrackStart:
                if pad_guide_marks = True then
                  Pen.Color := guide_colour   // plain track start marks.
                else
                  CONTINUE;

              eMC_33_ShovingTimberOutline,
              eMC_55_ReducedEnd,
              eMC_233_ShovedTimberInfill:
                if paper_colour <> clRed then
                  Pen.Color := clRed        // selected for shoving timber outline and infill.
                else
                  Pen.Color := clYellow;

              eMC_93_ShovedTimberInfill,
              eMC_95_ReducedEndInfill,
              eMC_293_ShovedTimberInfill:
                if paper_colour <> clBlue then
                  Pen.Color := clBlue      // other shoved timbers outline and infill.
                else
                  Pen.Color := clWhite;

              eMC_44_ShovingTimberCL_1,
              eMC_54_ShovingTimberCL_2:
                if check_dark_paper = False then
                  Pen.Color := clBlack   // shoved timber centre-line.
                else
                  Pen.Color := clWhite;

              eMC_203_TimberInfill:
                if (pad_timb_infill_style > 0) and ((screenx < 200 * scale) or
                  (pad_timb_infill_style > 2))
                // infill on pad if solid/blank fill or large enough to see hatching.
                then
                  Pen.Color := timber_infill_colour
                // timber infilling. n.b. gets changed to paper colour later, but NOT yet !
                else
                  CONTINUE;

              else
                Pen.Color := clBlack;
            end;//case
          end
          else
            Pen.Color := paper_colour;       // erase existing marks.

          Pen.Mode := pmCopy;

          check_int1x := limits(h_minint, h_maxint, p1.X * sx + ex - gx, dummy_i);
          // h_min, h_max 31 bit to give room for some arithmetic on the data (shift keeps, etc.)
          check_int1y := limits(h_minint, h_maxint, (p1.Y + yd) * sy + by - gy, dummy_i);

          check_int2x := limits(h_minint, h_maxint, p2.X * sx + ex - gx, dummy_i);
          check_int2y := limits(h_minint, h_maxint, (p2.Y + yd) * sy + by - gy, dummy_i);

          if (code > eMC_0_Ignore)
            and (code < eMC_200_placeholder) then begin
            move_to.X := Round(check_int1x);
            move_to.Y := Round(check_int1y);
            line_to.X := Round(check_int2x);
            line_to.Y := Round(check_int2y);
            if check_limits(move_to, line_to) = True then begin
              MoveTo(move_to.X, move_to.Y);
              LineTo(line_to.X, line_to.Y);
            end;
          end
          else begin
            if code = eMC__1_PegCentre        // code -1, draw fixing peg (not arms) ...
            then begin
              if ink = True then begin
                draw_notch(on_canvas);
                // first draw the pegging notch again between the timbers and the rails.
                // This routine is in the grid unit (notch already drawn underneath timbers).
                // Draw before the peg so that the peg overwrites.

                if paper_colour <> clRed then
                  Pen.Color := clRed     // changed by draw_notch.
                else
                  Pen.Color := clBlack;
              end;

              peg_dim := 10;
              // 0.91.b was pad_form.ClientWidth div 100;  // 100 arbitrary.
              if peg_dim > Round(scale * fx) then
                peg_dim := Round(scale * fx); // but not more than 2ft scale.

              if pad_form.peg_solid_red_menu_entry.Checked = True    // 0.95.a
              then
                Brush.Color := Pen.Color                       // solid red
              else
                Brush.Color := paper_colour;

              if peg_dim < 5
              // 0.91.b was (pad_form.ClientWidth div 200) // but then not less than this.
              then begin
                peg_dim := 5;
                // 0.91.b was pad_form.ClientWidth div 200;
                Brush.Color := Pen.Color;
                // solid fill when very small
              end;

              if turnoutx = 0 then
                peg_dim := peg_dim * 2;   // 0.93.a  invalidated template

              Brush.Style := bsSolid;
              // Deplphi bug with bsClear when drawing directly on form canvas.
              // solid is better anyway for aligning with the notch.

              pad_pegx := Round(check_int1x);
              // save peg co-ords for rotate action.
              pad_pegy := Round(check_int1y);

              if turnoutx = 0
              // 0.93.a  invalidated template -- draw red Z instead of peg ...
              then begin
                Pen.Width := 2;
                move_to.X := pad_pegx - peg_dim;
                move_to.Y := pad_pegy - peg_dim;    // top of Z
                line_to.X := pad_pegx + peg_dim;
                line_to.Y := pad_pegy - peg_dim;
                if check_limits(move_to, line_to) = True then begin
                  MoveTo(move_to.X, move_to.Y);
                  LineTo(line_to.X, line_to.Y);
                end;

                move_to.X := pad_pegx + peg_dim;
                move_to.Y := pad_pegy - peg_dim;    // diagonal of Z
                line_to.X := pad_pegx - peg_dim;
                line_to.Y := pad_pegy + peg_dim;
                if check_limits(move_to, line_to) = True then begin
                  MoveTo(move_to.X, move_to.Y);
                  LineTo(line_to.X, line_to.Y);
                end;

                move_to.X := pad_pegx - peg_dim;
                move_to.Y := pad_pegy + peg_dim;    // bottom of Z
                line_to.X := pad_pegx + peg_dim;
                line_to.Y := pad_pegy + peg_dim;
                if check_limits(move_to, line_to) = True then begin
                  MoveTo(move_to.X, move_to.Y);
                  LineTo(line_to.X, line_to.Y);
                end;

                Pen.Width := 1; // restore
              end
              else begin     // normal peg ...

                move_to.X := pad_pegx - peg_dim;
                move_to.Y := pad_pegy - peg_dim;
                line_to.X := pad_pegx + peg_dim;
                line_to.Y := pad_pegy + peg_dim;

                if pad_form.peg_hollow_menu_entry.Checked = True    // 0.95.a
                then begin
                  if check_limits(move_to, line_to) = True then
                    arc_ellipse(on_canvas, move_to.X, move_to.Y, line_to.X, line_to.Y);
                  // 0.95.a clear centre
                end
                else begin
                  if check_limits(move_to, line_to) = True then
                    Ellipse(move_to.X, move_to.Y, line_to.X, line_to.Y);
                end;

                move_to.X := pad_pegx - peg_dim * 2;
                move_to.Y := pad_pegy;
                line_to.X := pad_pegx + peg_dim * 2;
                line_to.Y := pad_pegy;
                if check_limits(move_to, line_to) = True then begin
                  MoveTo(move_to.X, move_to.Y);
                  LineTo(line_to.X, line_to.Y);
                end;

                move_to.X := pad_pegx;
                move_to.Y := pad_pegy - peg_dim * 2;
                line_to.X := pad_pegx;
                line_to.Y := pad_pegy + peg_dim * 2;
                if check_limits(move_to, line_to) = True then begin
                  MoveTo(move_to.X, move_to.Y);
                  LineTo(line_to.X, line_to.Y);
                end;

              end;
            end;

            if (code = eMC__2_CurvingRadiusCentre_1)
              or (code = eMC__3_CurvingRadiusCentre_2)              // draw curving rad centres...
            then begin
              radcen_dim := 6;
              // 0.91.b was Screen.Width div 150; // 150 arbitrary. (larger for the current than bgnd keeps).
              if radcen_dim > Round(scale * 5 * fx) then
                radcen_dim := Round(scale * 5 * fx);     // but not more than 5ft scale.

              radcenx := Round(check_int1x);
              radceny := Round(check_int1y);

              if spiral = False then begin
                rad_centx := radcenx;
                // save pad co-ords for orbit action (r1).
                rad_centy := radceny;
              end;

              if (spiral = True) and (adjust_trans_rad = 1)
                and (code = eMC__2_CurvingRadiusCentre_1) then begin
                rad_centx := radcenx;
                // save pad co-ords for orbit action (r1).
                rad_centy := radceny;
              end;

              if (spiral = True) and (adjust_trans_rad = 2) and
                (code = eMC__3_CurvingRadiusCentre_2) then begin
                rad_centx := radcenx;
                // save pad co-ords for orbit action (r2).
                rad_centy := radceny;
              end;

              move_to.X := radcenx - radcen_dim * 2;
              move_to.Y := radceny;
              line_to.X := radcenx + radcen_dim * 2;
              line_to.Y := radceny;
              if check_limits(move_to, line_to) = True then begin
                MoveTo(move_to.X, move_to.Y);
                LineTo(line_to.X, line_to.Y);
              end;

              move_to.X := radcenx;
              move_to.Y := radceny - radcen_dim * 2;
              line_to.X := radcenx;
              line_to.Y := radceny + radcen_dim * 2;
              if check_limits(move_to, line_to) = True then begin
                MoveTo(move_to.X, move_to.Y);
                LineTo(line_to.X, line_to.Y);
              end;
            end;

            if ((code = eMC_203_TimberInfill)
              or (code = eMC_233_ShovedTimberInfill)
              or (code = eMC_293_ShovedTimberInfill)
              or (code = eMC_493_Chair))
              and (ptr_2nd <> nil)   // timber infill, chair outlines...
              and (pad_timb_infill_style > 0) then begin
              check_int3x := limits(h_minint, h_maxint, p3.X * sx + ex - gx, dummy_i);
              // h_min, h_max 31 bit to give room for some arithmetic on the data (shift keeps, etc.)
              check_int3y :=
                limits(h_minint, h_maxint, (p3.Y + yd) * sy + by - gy, dummy_i);

              check_int4x := limits(h_minint, h_maxint, p4.X * sx + ex - gx, dummy_i);
              check_int4y :=
                limits(h_minint, h_maxint, (p4.Y + yd) * sy + by - gy, dummy_i);

              infill_points[0].X := Round(check_int1x);
              infill_points[0].Y := Round(check_int1y);

              infill_points[1].X := Round(check_int2x);
              infill_points[1].Y := Round(check_int2y);

              infill_points[2].X := Round(check_int3x);
              infill_points[2].Y := Round(check_int3y);

              infill_points[3].X := Round(check_int4x);
              infill_points[3].Y := Round(check_int4y);

              if (check_limits(infill_points[0], infill_points[1]) = True) and
                (check_limits(infill_points[2], infill_points[3]) = True) then begin
                if Pen.Color = paper_colour then begin                          // erasing...
                  Brush.Color :=
                    paper_colour;
                  Brush.Style :=
                    bsSolid;
                  // always a solid infill on erase, in case of problems with hatched infill (e.g. Tony Miles' version of Windows).
                end
                else begin
                  Pen.Color :=
                    paper_colour;
                  Brush.Color :=
                    timber_infill_colour;

                  case pad_timb_infill_style
                    of
                    0:
                      CONTINUE;
                    1:
                      Brush.Style := bsFDiagonal;
                    // hatched, forward diagonal in foreground (control template).
                    2:
                      Brush.Style := bsDiagCross;
                    3:
                      Brush.Style := bsSolid;
                    4: begin
                      // blank.
                      Brush.Style := bsSolid;
                      Brush.Color := paper_colour;   // overide.
                    end;
                    else
                      CONTINUE;                 // ??
                  end;//case

                  // shoved timber overides...

                  if code = eMC_293_ShovedTimberInfill        // shoved but not selected.
                  then begin
                    if paper_colour <> clBlue then
                      Brush.Color := clBlue
                    else
                      Brush.Color := clWhite;
                  end;

                  if code = eMC_233_ShovedTimberInfill        // currently selected for shoving.
                  then begin
                    if paper_colour <> clRed then
                      Brush.Color := clRed
                    else
                      Brush.Color := clYellow;
                  end;

                  // chair outline overides...

                  if code = eMC_493_Chair        // chair outlines (appear hollow)
                  then begin
                    Pen.Color := timber_colour;
                    Brush.Color := $00B0D0D0; // was paper_colour;
                    Brush.Style := bsSolid;
                  end;

                end;
                Polygon(infill_points);
              end;
            end;
          end;
        end
        else begin   // 99 or 501+  0.94.a

          if code = eMC_99_TimberNumber then begin
            if pad_timber_numbers = True // code=99, text mark (timber numbering).
            then begin
              check_int1x := limits(h_minint, h_maxint, p1.X * sx + ex - gx, dummy_i);
              // h_min, h_max 31 bit to give room for some arithmetic on the data (shift keeps, etc.)
              check_int1y :=
                limits(h_minint, h_maxint, (p1.Y + yd) * sy + by - gy, dummy_i);

              move_to.X := Round(check_int1x);
              move_to.Y := Round(check_int1y);

              num_str := extract_tbnumber_str(tbnum_str);
              // get next timber numbering string from the acummulated string.
              if num_str = '' then
                CONTINUE;              // no string available??

              if check_limit(True, True, move_to) = True then begin
                if num_str[1] = '!'   // it's an omitted timber
                then begin
                  Delete(num_str, 1, 1);
                  // remove the omit indicator.
                  omitted := True;
                end
                else
                  omitted := False;

                Font.Assign(pad_form.pad_timber_font_label.Font);

                half_stringwidth := TextWidth(num_str) div 2;
                half_stringheight := TextHeight(num_str) div 2;

                Brush.Color := paper_colour;
                Brush.Style := bsSolid;

                if ink = False then
                  Font.Color := paper_colour             // erasing.
                else
                if shove_timber_form.Showing = True then begin
                  // see if current timber number is selected for shoving..

                  temp_str := timb_num_strip(num_str);

                  if (num_str = current_shove_str) or (temp_str = current_shove_str) or
                    (omitted = True)   // needs a rectangle box.
                  then begin
                    if (num_str = current_shove_str) or (temp_str = current_shove_str)
                    // shoving this one?
                    then begin
                      if paper_colour = clYellow then begin
                        Brush.
                          Color := clBlack;      // highlight selected timber number for shoving.
                        Font.
                          Color := clWhite;
                      end
                      else begin
                        Brush.
                          Color := clYellow;
                        Font.
                          Color := clBlack;
                      end;
                    end;

                    Pen.Width := 1;
                    // looks neater if we draw/highlight the rectangle first...
                    Pen.Mode := pmCopy;
                    Pen.Style := psSolid;
                    Pen.Color := Font.Color;
                    Rectangle(
                      move_to.X - half_stringwidth - 3, move_to.Y - half_stringheight - 2,
                      move_to.X + half_stringwidth + 4, move_to.Y + half_stringheight + 3);
                  end;
                end;//if shove_timber showing

                TextOut(
                  move_to.X - half_stringwidth, move_to.Y - half_stringheight, num_str);
                Font.Assign(pad_form.Font);
                Brush.Color := paper_colour;
              end;
            end;//numbers wanted
          end
          else begin     // 501+  0.94.a  check-rail labels ...

            if check_diffs_form.Showing = True then begin
              check_int1x := limits(h_minint, h_maxint, p1.X * sx + ex - gx, dummy_i);
              // h_min, h_max 31 bit to give room for some arithmetic on the data (shift keeps, etc.)
              check_int1y :=
                limits(h_minint, h_maxint, (p1.Y + yd) * sy + by - gy, dummy_i);

              move_to.X := Round(check_int1x);
              move_to.Y := Round(check_int1y);

              case code of

                eMC_501_MSWorkingEnd:
                  num_str := 'MS1';
                eMC_502_MSExtensionEnd:
                  num_str := 'MS2';
                eMC_503_MSWingRail:
                  num_str := 'MS3';
                eMC_504_TSWorkingEnd:
                  if half_diamond = True then
                    num_str := 'DS1'
                  else
                    num_str := 'TS1';
                eMC_505_TSExtensionEnd:
                  if half_diamond = True then
                    num_str := 'DS2'
                  else
                    num_str := 'TS2';
                eMC_506_TSWingRail:
                  if half_diamond = True then
                    num_str := 'DS3'
                  else
                    num_str := 'TS3';
                eMC_507_MSKCheckRail:
                  num_str := 'MS4';
                eMC_508_DSWingRail:
                  num_str := 'DS4';

                else
                  num_str := '';

              end;//case

              if check_limit(True, True, move_to) = True then begin
                Font.Assign(pad_form.pad_timber_font_label.Font);

                half_stringwidth := TextWidth(num_str) div 2;
                half_stringheight := TextHeight(num_str) div 2;

                Brush.Color := paper_colour;
                Brush.Style := bsSolid;

                if ink = False then
                  Font.Color := paper_colour             // erasing.
                else begin
                  // see if current check-end is selected for diffing..
                  if code = current_diff_code then begin
                    if paper_colour = clYellow then begin
                      Brush.Color := clBlack;
                      // highlight selected timber number for shoving.
                      Font.Color := clWhite;
                    end
                    else begin
                      Brush.Color := clYellow;
                      Font.Color := clBlack;
                    end;
                  end;

                  Pen.Width := 1;
                  // draw the rectangle first...
                  Pen.Mode := pmCopy;
                  Pen.Style := psSolid;
                  Pen.Color := Font.Color;
                  RoundRect(
                    move_to.X - half_stringwidth - 3, move_to.Y - half_stringheight - 2,
                    move_to.X + half_stringwidth + 4, move_to.Y + half_stringheight + 3, 6, 6);
                end;//ink=True

                TextOut(
                  move_to.X - half_stringwidth, move_to.Y - half_stringheight, num_str);
                Font.Assign(pad_form.Font);
                Brush.Color := paper_colour;
              end;//check_limits

            end;//check form showing
          end;//check label mark
        end;//text mark

      except
        CONTINUE;     // ignore this mark if any calc errors.
      end;//try

    end;//next i

    draw_rings(on_canvas, False, False);   //  re-draw the spacing-ring  (not copies).

  end;//with
  Result := True;
end;
//___________________________________________________________________________________________

procedure calctimbers;               //  calc all timbering

var
  n: integer;
  tbnext, tbint: integer;
  last_xtb: double;
  exit_begin: double;
  full_length: boolean;

  eqfix_closeup, xtbclose_start: double;

  xingtb_w, xingtb_v: double;
  bontimb_posx: double;

  mod_for_curvi: boolean;               // 215a ...
  unmod_xtb, curvi_alpha: double;
  xtb_mod, modded_xtb: double;
  total_space_remaining, num_timbers, new_spacing: double;

begin
  approach_last_xtb := 0;         // init for length snapping...
  exit_last_xtb := turnoutx;

  if (half_diamond = True) and (hd_timbers > 0)     // init for slip timber extensions...
  then begin
    sliptipsl := fpx - toex - scale * k3n;
    // from hd toe to slip-switch toe (arbitrary where wing rails 12" separation).
    sliprad := sliptipsl / TAN(k3 / 2);    // approx slip road radius.
  end;

  if timber_marks = True then begin

    if outline_extensions = True then
      tbl := 4.5 * inscale             // outline extensions = 4.5" scale
    else
      tbl := 0;

    tbq := scale;              // centre-line extensions = 1ft scale

    if nine_foot = True then
      tbred := 3 * inscale     // standard 9ft timbering, with
    // 3" length reduction each end for 8ft 6" timbers.
    else
      tbred := 0;            // non-standard timber lengths, no reductions.

    ynsnorm := 0 - (tb - g) / 2;   // timber near-end same for all xtb (before randomizing)

    // 208a mods...

    tbnumy_screen := ynsnorm - tbq - 1.5;
    // default y-position of timber numbering. 1.5mm below end of timber centre-line (only used if timber centre-lines not drawn).

    tbnumy_output := ynsnorm - tbq - 6;
    // 208a mod   // default y-position of timber numbering. 6mm below end of timber centre-line (only used if timber centre-lines not drawn).


    //eqtimb:=False;      // no equalizing along switch. 29-3-99
    frackeq := 0;           // ensure switch timbers square-on. 29-3-99.

    if gaunt = False then
      switchtimbers    // first do switch timbers, end sleepers, and approach track.
    else begin
      if xorg > 0 then
        plain_sleepers(xorg, -1, True, False);   // approach plain-track wanted on gaunt template.
      xtbswend := xorg - (psleep[pt_i, 0] * inscale);
      // start at A1 timber for closure timbering.
    end;

    // now do crossing timbers from Z timber on...

    if plain_track = False then begin

      if include_xing_timbers = True   // 218a
      then begin

        timb_str := 'X';        // restart numbering. "X" for crossing
        tbn := 1;

        // mod 0.75.a 10-10-01...

        xtba := bnx +{4}bn_to_a * inscale;   // A timber from blunt nose

        xingtb_w := wingtimb_sp * inscale;    // wing front timber spacing.
        xingtb_v := veetimb_sp * inscale;     // vee timber spacing.

        xtbz := xtba - wing_tbcount * xingtb_w;
        // x to first crossing timber (usually Z, count of 3).

        //eqtimb:=timbers_equalized;      // allow equalizing if wanted.

        if (half_diamond = True) or (timbers_equalized = True) or (square_on_angled = True)
        // mod 29-7-01.
        then
          frackeq := 1    // full equalizing angle or angled-on through crossing.
        else
          frackeq := 0;   // square-on through crossing. 29-3-99.

        xtb := xtbz;    // first wing front timber.

        tb_xing_end := xtba - (xingtb_w / 2);
        // wing front timbers don't include "A".

        repeat
          dotimber(False, False);   // do at timber width.
          last_xtb := xtb;           // save position of last one.
          xtb := xtb + xingtb_w;       // all at wing front spacing.
        until xtb > tb_xing_end;

        xtb := xtba;        // now first vee timber "A".

        if (turnout_road_i = -1) and (xing_type_i <> 1)
        // 0.93.a not if curviform
        then
          tb_xing_end := txpx + xingtb_v / 2
        // turnout for crossover having regular or generic V-crossings,
        // (2 arbitrary - best fit to eliminate timbering gaps
        // at some crossing angles, versus overlaps at others).
        else
          case exittb_i of
            0, 2:
              tb_xing_end :={mvjpx}mvjpx - (mvj_sp * inscale) + minfp;
            // none, or exit sleepering start.
            1:
              tb_xing_end := turnoutx;                             // long timbers continue.
            else
              run_error(129);
          end;//case

        xtb_mod := 0;               // 215a init..
        modded_xtb := tb_xing_end;

        repeat
          // 215a mods for curviform crossings, shorten spacings to suit standard chairs ..

          unmod_xtb := xtb;            // so can restore for spacing calc...

          if (curviform_timbering = True) and (tradius_is_straight = False) and
            (xing_calc_i = 1) and (xtb > (xtba + xingtb_v))
          // only for timbers "C" and above

          then begin
            mod_for_curvi := True;

            if ((xtb - fpx) / k3n) < (15 * inscale)
            // if rail separation under 15" (crossing chairs needed)
            then begin
              try
                curvi_alpha := (xtb - fpx) / ABS(tradius);
                // angle turned through beyond FP.
                xtb_mod :=
                  ABS(tradius) * (1 - COS(curvi_alpha)) * k3n;
                // adjust chair position to maintain vee rail separation

                xtb := xtb - xtb_mod;
                // and mod this one for the chair
                modded_xtb := xtb;     // save the position
              except
                xtb := unmod_xtb;         // abandon mod
                xtb_mod := 0;
                mod_for_curvi := False;
              end;//try
            end
            else begin
              // next timbers (ordinary chairs)...
              if xtb_mod > 0
              // some mods have taken place
              then begin
                if (xtb - modded_xtb) > (31 * inscale)     // 31" max spacing arbitrary
                then begin
                  total_space_remaining :=
                    tb_xing_end - modded_xtb;

                  num_timbers :=
                    CEIL(total_space_remaining / xingtb_v);
                  // num timbers at full spacing, rounded up

                  new_spacing :=
                    total_space_remaining / num_timbers;

                  xtb :=
                    modded_xtb + new_spacing;   // init

                  repeat
                    dotimber(False, False);
                    // insert timber
                    last_xtb := xtb;
                    // save position of last one.

                    xtb := xtb + new_spacing;
                  until xtb > (tb_xing_end + inscale);

                  BREAK; // all done
                end;
              end;
            end;

          end
          else
            mod_for_curvi := False;

          dotimber(False, False);         // do at xtb, timber width.

          if mod_for_curvi = True          // 215a
          then
            xtb := unmod_xtb;

          last_xtb := xtb;                   // save position of last one.
          xtb := xtb + xingtb_v;               // all at vee spacing.
        until xtb > (tb_xing_end + inscale);
        // 1" added to ensure end timber is hit

      end

      else begin    // no xing timbers   218a ...

        last_xtb := mvjpx - (mvj_sp * inscale);
        // so start exit timbering at last timber before MVJP

        xtba := bnx + bn_to_a * inscale;          // A timber from blunt nose
        xingtb_w := wingtimb_sp * inscale;      // wing front timber spacing.
        xtbz := xtba - wing_tbcount * xingtb_w;
        // for closure timbers     x to first crossing timber (usually Z, count of 3).

        // for wing rail joints ...

        if (half_diamond = True) and (hd_timbers <> 0)   // 215a this is a slip
        then
          xtbzz := xtbz - 28 * inscale         // 215a so use 28" next spacing
        else
          xtbzz := xtbz - wingj_sp * inscale;
        // move back joint spacing from Z. mod 0.75.a 11-10-01.
      end;

      if include_closure_timbers = True   // 218a
      then begin

        // then fill closure timbers between switch and crossing...

        timb_str := 'T';        // restart closure numbering.

        if gaunt = True then
          tbn := 1
        else
          tbn := 2;       // first closure timber has been drawn with the switch.

        if (half_diamond = True) and (hd_timbers <> 0)   // 215a this is a slip

        then
          xtbzz := xtbz - 28 * inscale   // 215a so use 28" next spacing

        else
          xtbzz := xtbz - wingj_sp * inscale;
        // move back joint spacing from Z. mod 0.75.a 11-10-01.

        if (timbers_equalized = True) and (equalizing_fixed = True) and
          (half_diamond = False) and (ABS(k3n) > minfp) then begin
          eqfix_closeup := 20 * inscale / k3n;
          // 20"/xing RAM arbitrary - close up a bit for constant equalizing.
          if eqfix_closeup > (6 * inscale) then
            eqfix_closeup := 6 * inscale;     // but not more than 6"

          xtbclose_start := xtbswend - eqfix_closeup;
        end
        else
          xtbclose_start := xtbswend;

        xclose := xtbzz - xtbclose_start;
        // length of closure rails between timbers already drawn.
        tbints := xclose / (ftimbspmax * inscale);
        // number of max intervals in this length.

        tbint := TRUNC(tbints);
        if FRAC(tbints) > minfp then
          tbint := tbint + 1;  // round up the number of intervals unless max spacing fits exactly.

        if tbint < 1 then
          tbint := 1;     // no division by zero.
        xclosespace := xclose / tbint;    // spacing for each interval

        for tbnext := 1 to tbint do begin
          xtb := xtbclose_start + tbnext * xclosespace;      // x to next timber

          if half_diamond = True then
            frackeq := 1      // ignore flags, always constant.
          else begin

            if timbers_equalized = True then begin
              if equalizing_fixed = True then
                frackeq := 1              // constant equalizing angle.
              else
                frackeq := tbnext / tbint;
              // incremental, so fraction of the equalizing angle to avoid sudden change at heel of switch.
            end
            else begin
              if square_on_angled = True then
                frackeq := 1   // angled-on 20-7-01
              else
                frackeq := 0;  // square-on closure timbers. 29-3-99.
            end;
          end;

          dotimber(False, False);
        end;//next

      end;


      // finally add exit sleepering if any ...

      if exittb_i = 2 then begin
        //if turnout_road=-1 then full_length:=False      // for crossover exit
        //                   else full_length:=True;
        full_length := True;
        frackeq := 0;

        if last_xtb > (mvjpx - (mvj_sp * inscale) + minfp) then
          exit_begin := last_xtb + (mvj_sp * inscale)
        // crossover with wide spacing? - space exit joint beyond last timber drawn.
        else
          exit_begin := mvjpx;                      // normal - rail joint for exit sleepers.

        plain_sleepers(exit_begin, 1, full_length, False);

        if retpar_i = 1    // and finally any return curve sleepering...
        then begin
          full_length := True;
          frackeq := 0;
          // square-on.

          plain_sleepers(exit_begin + (22.5 - k3n / 2) * inscale, 1, full_length, True);
          // +(22.5-k3n/2)" interlacing (arbitrary).
        end;
      end;//exit sleepering
    end;//if turnout

    // 0.76.a 23-10-01 finally add any bonus timbers...

    if bontimb > 0 then begin
      timb_str := 'B';        //  prefix for bonus timber numbering.
      tbn := 1;               //  init numbering.

      if plain_track = True then
        bontimb_posx := turnoutx - tb_roll_percent * railen[pt_i] * inscale /
          100  // adjust for any timber rolling.
      else
        bontimb_posx := xorg;  // for turnout always at CTRL-1

      for n := 1 to bontimb do
        endsleeper(bontimb_posx, True, False, False, 1);

    end;

  end;//if timber_marks
end;
//_____________________________________________________________________________________________

procedure plain_sleepers(xtb: double; dir: integer; full_length, retcurve: boolean);
// dir = direction  -1 = approach tracks, +1 = exit tracks

var
  xrail: double;
  p1, p2: Tpex;
  first_joint: boolean;
  sl_space, tb_roll_mm: double;
  ret_offset, ret_k: double;
  odd_rail: boolean;

  joint_sl: boolean;

  ////////////////////////////////////////////////////////////

  procedure fill_joints_and_timbers;

  var
    slco: integer;

  begin
    repeat
      if (joint_marks = True) and (rjcode > -1)
      // first mark the next rail-joint.
      then begin
        if first_joint = False           // skip the point rail joint
        then begin
          if retcurve = True then
            ret_offset := aq25offset(xtb, ret_k) - g / 2
          else
            ret_offset := 0;

          if (odd_rail = True) or (rjcode = 0)
          // staggered or normal, main-side rail.
          then begin
            p1.x := xtb;
            p1.y := gmi + ret_offset;
            if retcurve = True then
              dotransform(ret_k, xtb, g / 2, p1, p1);       // twist joint marks.

            p2.x := xtb;
            p2.y := 0 - j - gmo + ret_offset;
            if retcurve = True then
              dotransform(ret_k, xtb, g / 2, p2, p2);       // twist joint marks.

            if ((main_road_stock_rail_flag = True) and ((timb_str = 'A') or
              (timb_str = 'E') or (timb_str = 'N'))) or
              ((crossing_vee_flag = True) and (timb_str = 'R')) then
              enter_mark(True, p1, p2, eMC_6_RailJoint, '');
            // make rail-joint mark, straight stock rail.
          end;

          if (odd_rail = False) or (rjcode = 0)
          // staggered or normal, turnout-side rail.
          then begin
            p1.x := xtb;
            p1.y := g - gmi + ret_offset;
            if retcurve = True then
              dotransform(ret_k, xtb, g / 2, p1, p1);       // twist joint marks.

            p2.x := xtb;
            p2.y := g + j + gmo + ret_offset;
            if retcurve = True then
              dotransform(ret_k, xtb, g / 2, p2, p2);       // twist joint marks.

            if ((turnout_road_stock_rail_flag = True) and ((timb_str = 'A') or
              (timb_str = 'R') or (timb_str = 'N'))) or
              ((crossing_vee_flag = True) and (timb_str = 'E')) then
              enter_mark(True, p1, p2, eMC_6_RailJoint, '');
            // make rail-joint mark, curved stock rail.
          end;
        end;
        first_joint := False;          // do all remaining joints.
        odd_rail := not odd_rail;     // for staggered joints.
      end;

      for slco := 0 to psleep_c do begin
        // do the sleepers for a rail length.

        joint_sl := ((slco = 0) or (slco = (sleeper_count[pt_i] - 1)));
        // 212a joint sleeper

        sl_space := psleep[pt_i, slco];
        if sl_space < minfp then
          BREAK;               // no more spacing data.

        xtb := xtb + dir * sl_space * inscale;

        case dir of
          -1:
            if xtb < (xrail - railen[pt_i] * inscale) then
              BREAK;
          // gone past end of this rail..                                            // gone far enough back on this rail (4 inches past rail end).
          1:
            if xtb > (xrail + railen[pt_i] * inscale) then
              BREAK;
          else
            run_error(216);
        end;//case

        if (xtb < (0 - scale / 3)) or (xtb > (turnoutx + scale / 3)) then begin
          if timb_str <> 'N' then
            BREAK    // gone far enough on this rail (4 inches past rail end).
          else begin
            Inc(tbn);
            // keep rolled timber numbering in line (for shoves).
            CONTINUE;
            // timber rolling (turnoutx might be less than the roll, so first rolled timbers negative xtb, but may want subsequent ones).
          end;
        end;

        if (xtb > fpx + k3n * 4.5 * scale) or (dir = -1) then
          endsleeper(xtb, True, retcurve, joint_sl, dir)
        // draw normal sleepering beyond 4ft6in scale vee separation, or for approach track.
        else
          endsleeper(xtb, full_length, retcurve, joint_sl, dir);
        // might be reduced sleepers for crossover exit.

        if retcurve = False then begin
          case dir of
            -1:
              approach_last_xtb := xtb;   // save last xtb drawn for length snapping...
            1:
              exit_last_xtb := xtb;
          end;//case
        end;

      end;//for

      case dir of
        -1:
          if xtb < (0 - scale / 3) then
            BREAK;            // don't do any more rails.
        1:
          if xtb > (turnoutx + scale / 3) then
            BREAK;
        else
          run_error(218);
      end;//case

      xrail := xrail + dir * railen[pt_i] * inscale;    // to the next rail.
      xtb := xrail;

    until 0 <> 0;
  end;
  /////////////////////////////////////////////////////////////

begin
  if railen[pt_i] = 0 then
    run_error(151);        // no plain track data.

  tb_roll_mm := tb_roll_percent * railen[pt_i] * inscale / 100;  // timber rolling.

  if retcurve = False then begin
    case dir of
      -1:
        approach_last_xtb := 0;      // init for length snapping...
      1:
        exit_last_xtb := turnoutx;
    end;//case
  end;

  if dir = 1 then begin
    first_joint := True;                     // point rail joints already drawn.
    if retcurve = True then
      timb_str := 'R'    //  prefix numbering for return curve.
    else
      timb_str := 'E';   //  prefix for numbering exit plain track.
  end
  else begin
    first_joint := False;   // but not if approach track or plain track.
    timb_str := 'A';        // prefix for numbering approach plain track.
  end;

  if plain_track = True then
    xtb := xtb - tb_roll_mm;  // timber rolling offset 0.76.a 13-5-02
  // (first xtb is on turnoutx).

  tbn := 1;           // start numbering.
  xrail := xtb;       // init for rail lengths.
  odd_rail := False;  // init for staggered rails

  fill_joints_and_timbers;

  // now add any timbering in the rolled section, if any...

  if (plain_track = True) and (tb_roll_mm > minfp) then begin
    timb_str := 'N';             // "new" inserted sleepers.
    xtb := turnoutx - tb_roll_mm;  // start from first joint already done...
    dir := 1;
    first_joint := True;

    tbn := 1;           // re-start numbering.
    xrail := xtb;       // init for rail lengths.
    odd_rail := False;  // init for staggered rails

    fill_joints_and_timbers;
  end;

end;
//_______________________________________________________________________________________________________________________________

procedure toesleeper(joint: boolean);   //  deal with switch front sleepers or timbers.

// joint=True means adjacent to rail joint (may be wide joint sleeper if switch front sleepered)  // 212a

var
  sf_width: double;

begin

  if include_front_timbers = False then
    EXIT; //218a

  if xtb < (0 - scale) then
    EXIT;             // min 12" outside datum. mod 0.77.b
  if xtb > (turnoutx + scale / 3) then
    EXIT;    // max 4" beyond rail end (much shortened template?).

  timberend(1);     // get yfs, yfsred to sleeper end

  if pad_form.timber_centres_menu_entry.Checked = True then
    drawtimbcl(False);   // sleeper centre-lines wanted.
  if pad_form.timber_outlines_menu_entry.Checked = True
  // sleeper outlines wanted.
  then begin
    if csi.front_timbered = True then
      sf_width := tbwide    // timber width.
    else
    if joint = True then
      sf_width := jt_slwide    // joint sleeper width.
    else
      sf_width := slwide;      // sleeper width.

    xns := xtb - sf_width * inscale / 2;      // timber width, ( half each side of centre )
    xfs := xtb + sf_width * inscale / 2;
    drawtimber(True, False);
  end;

  if pad_form.timber_numbers_menu_entry.Checked = True then
    tbnumber(False)  // numbering wanted.
  else
    tbn := tbn + 1;      // do numbering last because increments tbn. (needed for timber shoves).
end;
//_______________________________________________________________________________________________________________________________

procedure switchtimbers;         // do switch timbering and approach track.
// (no equalizing for switch timbers).
var
  n, swtb: integer;
  xdpb, kwl, ksp: double;

  dummy: double;  // 218b

begin                             // for rail-joint marks.
  gmi := 5 * inscale;                 // 5" scale length of mark inside gauge-face.
  gmo := gmi;                       // 5" scale ditto beyond outer-edge.

  // deal first with switch front timbers...

  timb_str := 'J';        //  prefix for numbering joint sleepers at toe.
  tbn := 1;               //  init numbering.

  // !!! spacings are negative...

  if (plain_track = False) and (half_diamond = False) and (include_switch_timbers = True)   // 218a
  then begin
    repeat
      if csi.sleeper_j1 < (0 - minfp) then begin
        xtb := toex + csi.sleeper_j1 * inscale;
        // first switch front timber J1 (next to toe).
        toesleeper(csi.sleeper_j2 = 0);
      end
      else
        BREAK;

      if csi.sleeper_j2 < (0 - minfp) then begin
        xtb := xtb + csi.sleeper_j2 * inscale; // next switch front timber J2.
        toesleeper(csi.sleeper_j3 = 0);
      end
      else
        BREAK;

      if csi.sleeper_j3 < (0 - minfp) then begin
        xtb := xtb + csi.sleeper_j3 * inscale; // next switch front timber J3.
        toesleeper(csi.sleeper_j4 = 0);
      end
      else
        BREAK;

      if csi.sleeper_j4 < (0 - minfp) then begin
        xtb := xtb + csi.sleeper_j4 * inscale; // next switch front timber J4.
        toesleeper(csi.sleeper_j5 = 0);
      end
      else
        BREAK;

      if csi.sleeper_j5 < (0 - minfp) then begin
        xtb := xtb + csi.sleeper_j5 * inscale; // next switch front timber J5.
        toesleeper(True);                // True = joint sleeper  212a
      end
      else
        BREAK;
      BREAK;
    until 0 <> 0;
  end;

  if (xorg > 0) and (half_diamond = False) then
    plain_sleepers(xorg, -1, True, False);     // approach plain-track wanted.

  // now do the switch timbering...

  if plain_track = False then begin
    if (half_diamond = False)       // turnout or...
      or ((half_diamond = True) and (fixed_diamond = False) and (hd_switch_timbering = True))
    // 213a
    then begin
      swtb := 0;             // initialise switch timber number
      xtb := toex;           // switch timber centres start from toe.

      swend_for_tandem := 0;  // init 218b

      tbn := 1;         // restart numbering for switch.
      timb_str := 'S';  // prefix for switch timber numbers.

      swbegin_for_tandem := toex + csi.timber_centres[0] * inscale;
      // 218a  x to S1 timber

      repeat
        // if csi.timber_centres[swtb+1]=0 then swend_for_tandem:=xtb;   // 218a  x to last S timber

        xtb := xtb + csi.timber_centres[swtb] * inscale;  // get next timber centre
        if csi.timber_centres[swtb + 1] = 0
        // this is actually the first closure timber
        then begin
          timb_str := 'T';                 // so reset numbering
          tbn := 1;
          if (timbers_equalized = False) and (square_on_angled = True) then
            frackeq := 1  // 29-7-01 angled-on style.
          else
            frackeq := 0;
        end
        else
          frackeq := 0; // switch timbering square-on.

        if ((timb_str <> 'T') and (include_switch_timbers = True)) or
          ((timb_str = 'T') and (include_closure_timbers = True)) then
          dotimber(False, False);    // 218a

        if (aq2offset(xtb, dummy) > (10.5 * inscale)) and (swend_for_tandem = 0) then
          swend_for_tandem := xtb;
        // 218b find location for next tandem switch   more than 10.5" offset needed for opening

        Inc(swtb);                           // to the next timber
      until csi.timber_centres[swtb] = 0;      // no more switch timbers

      if swend_for_tandem = 0 then
        swend_for_tandem := xtb;   // ??? GWR switch, set last switch timber regardless of offset

      xtbswend := xtb;     // save last xtb for closure fill.

      //   ( rail-joint spacing is included in switch timbering,
    end               //     so the first closure timber has been drawn.)
    else begin
      tbn := 1;         // restart numbering for half-diamond.
      timb_str := 'K';  // prefix for k-crossing timber numbers.
      frackeq := 1;     // equalized constant;

      if fixed_diamond = False  // switch diamond...
      then begin

        // half-k-wing rail = 18'0" = 216"  BH = 0 + 24 + 6*30 + 12 to joint.
        //                    16'1" = 193"  FB = 11 + 6*28 + 14 to joint.

        case rail_section of
          0, 1: begin                    // bullhead or no rails.
            xtb := 0;
            // centre timber for bullhead switch diamonds.
            dotimber(False, False);

            xtb := xtb + 24 * inscale;    // 24" spacing for next.
            dotimber(False, False);

            for n := 0 to 5 do begin    // 6 spaces
              xtb := xtb + 30 * inscale;    // at 30" spacing.
              dotimber(False, False);
            end;

            timb_str := 'T';
            // reset numbering for fill - this the first..
            tbn := 1;

            xtb := xtb + 24 * inscale;
            // k-wing rail 12" joint.
            if include_closure_timbers = True then
              dotimber(False, False);
          end;

          2: begin                  // flat-bottom.
            xtb := 11 * inscale;
            // separate timbers for flat-bottom switch diamonds, tips 4.5" from centre.
            dotimber(False, False);

            for n := 0 to 5 do begin    // 6 spaces
              xtb := xtb + 28 * inscale;    // at 28" spacing.
              dotimber(False, False);
            end;

            timb_str := 'T';
            // reset numbering for fill - this the first..
            tbn := 1;

            xtb := xtb + 28 * inscale;
            // k-wing rail 14" joint.
            if include_closure_timbers = True then
              dotimber(False, False);
          end;
        end;//case
      end

      else begin           // fixed diamond...
        if hd_proto_timbering = True then begin
          if ((rail_section <> 2) and (hdkn >= 5.25)) or ((rail_section = 2) and (hdkn >= 4.875))
          then begin
            xtb := 0;
            // centre timber for BH 5.5 or more, FB 5 or more.
            dotimber(False, False);
          end;

          xtb := ((1.625 + bn_wide) * hdkn + 6) * inscale;
          // diamond point blunt nose + 6", flangeway 1.75" (K-nose 1/8" less than V-nose).
          dotimber(False, False);

          if use_k_custom_wing_rails = True      // // 0.95.a
          then
            kwl := k_custom_wing_long / 2
          else begin
            if hdkn <= 6.375 then begin
              if rail_section <> 2   // BH or none.
              then
                kwl := 173 / 2   //  14'5" BH k-wing rails overall.
              else
                kwl := 168 / 2;  //  14'0" FB.
            end
            else begin
              if rail_section <> 2   // BH or none.
              then
                kwl := 185 / 2   //  15'5" BH k-wing rails overall.
              else
                kwl := 220 / 2;  //  18'4" FB.
            end;
          end;

          if rail_section <> 2 then
            ksp := ((kwl - 12) * inscale - xtb)  // BH 12" = k-wing rail joint.
          else
            ksp := ((kwl - 13) * inscale - xtb); // FB 13" to joint.

          if (rail_section <> 2) or (hdkn <= 6.375)
          // BH or none. 2 spaces.
          then begin
            xtb := xtb + ksp / 2;
            dotimber(False, False);

            xtb := xtb + ksp / 2;
            dotimber(False, False);
          end
          else begin                // long FB. 3 spaces.
            xtb := xtb + ksp / 3;
            dotimber(False, False);

            xtb := xtb + ksp / 3;
            dotimber(False, False);

            xtb := xtb + ksp / 3;
            dotimber(False, False);
          end;

          timb_str := 'T';
          // reset numbering for fill - this the first..
          tbn := 1;

          if rail_section <> 2 then
            xtb := xtb + 24 * inscale  // BH k-wing rail joint.
          else
            xtb := xtb + 26 * inscale;

          if include_closure_timbers = True then
            dotimber(False, False);
        end
        else begin
          // model timbering (based on actual flangeway, a timber under diamond points)...
          xtb := 0;
          dotimber(False, False);
          // centre timber for all angles.

          //xdpb:=seg_termx[2,2]-(g/2)*SIN(hdk/2)+4*inscale;   // diamond point blunt nose + 4".
          xdpb := seg_termx[3, eRD_CurvedTurnoutWingGaugeFace] - (g / 2) *
            SIN(hdk / 2) + 4 * inscale;
          // 0.97.a diamond point blunt nose + 4".

          if xdpb > (33 * inscale)
          // arbitrary 33" spacing (e.g. wide 00/H0 flangeways at 1:8)
          then begin
            xtb := xdpb / 2;
            // insert additional timber.
            dotimber(False, False);
          end;

          xtb := xdpb;
          dotimber(False, False);

          xtb := xtb + 28 * inscale;
          // 28" arbitrary spacing for next.
          dotimber(False, False);

          xtb := xtb + 28 * inscale;
          // 28" arbitrary spacing for next.
          dotimber(False, False);

          timb_str := 'T';
          // reset numbering for fill - this the first..
          tbn := 1;

          xtb := xtb + 25 * inscale;
          // k-wing rail joint.
          if include_closure_timbers = True then
            dotimber(False, False);
        end;

      end;

      xtbswend := xtb;    // save last xtb for start fill.
    end;
  end;
end;
//_______________________________________________________________________________________________________________________________

procedure dotimber(retcurve, joint: boolean);     // process this timber

// joint=True is a joint sleeper 212a  (never actually used here)

begin
  if xtb > (turnoutx - scale / 2) then
    EXIT;  // (6" inside rail end) in case catch points, or F4 length adjust, etc.

  if (tandem_timb = 4) and (xtb > (atx + 66 * inscale)) then
    EXIT;  // 218b tandems, not beyond C timber

  timberend(0);
  // get yns, yfs for it, and equalizing angle for timber width.

  if pad_form.timber_centres_menu_entry.Checked = True then
    drawtimbcl(retcurve);          // timber centre-lines wanted.
  if pad_form.timber_outlines_menu_entry.Checked = True then
    drawtimbol(retcurve, joint);   // timber outlines wanted.

  //if pad_form.timber_chairs_menu_entry.Checked=True then drawchairs(retcurve);           // chair outlines wanted. 213b

  if pad_form.timber_numbers_menu_entry.Checked = True then
    tbnumber(retcurve)             // timber numbering wanted.
  else
    tbn := tbn + 1;
  // do numbers last because increments tbn (needed for timber shoves).
end;
//_______________________________________________________________________________________________________________________________

procedure drawtimbol(retcurve, joint: boolean);        // draw main timber outlines.

// joint=True this is a joint sleeper 212a   (never actually used here)

var
  sl_width: double;

begin
  if maintimb = 1 then begin
    xns := xtb - tbwide * inscale / 2;   // timber width, ( half each side of centre )
    xfs := xtb + tbwide * inscale / 2;
  end
  else begin
    if joint = True then
      sl_width := jt_slwide
    else
      sl_width := slwide;

    xns := xtb - sl_width * inscale / 2;   // sleepers width, ( half each side of centre )
    xfs := xtb + sl_width * inscale / 2;
  end;

  drawtimber(True, retcurve);
end;
//_______________________________________________________________________________________________________________________________

procedure tbnumber(retcurve: boolean);    // mark timber numbering !!! n.b. increments tbn !!!

var
  y, kret: double;
  pnum, p1, p2: Tpex;
  n: integer;
  marktext_str: string;
  shove_omitted: boolean;

begin
  shove_omitted := False;       // init.

  // mods 208a  p1=number position on screen,  p2=number position for print/output...

  try
    if retcurve = True    // sleepering the return curve..
    then begin
      y := aq25offset(xtb, kret) - g - scale;     // g +1ft scale arbitrary.

      p1.y := y + (tb + g / 2) * COS(kret);
      // (tb+g/2) arbitrary approx to the text position for screen.
      p2.y := y + (tb + g / 2 + 6) * COS(kret);
      // 208a      // (tb+g/2+6mm) arbitrary approx to the text position for output.

      p1.x := xtb - (tb + g / 2) * SIN(kret) - 2;
      p2.x := p1.x;
    end
    else begin
      if pad_form.timber_centres_menu_entry.Checked = True then begin
        p1 := number_point_screen;     // gets changed for omitted timber below.
        p2 := number_point_output;
      end
      else begin                // default positions if no timber centre-line calcs.
        pnum.x := xtb;

        pnum.y := tbnumy_screen;
        dotransform(keq, xtb, yeq, pnum, p1);   // equalize/shove transform pnum to p1.

        pnum.y := tbnumy_output;
        dotransform(keq, xtb, yeq, pnum, p2);   // equalize/shove transform pnum to p2.

      end;
    end;

    marktext_str := timb_str + IntToStr(tbn);     // set up numbering text string

    if shove_timber_form.Showing = False        // not shoving.
    then begin
      for n := 0 to current_shove_list.Count - 1 do begin
        if (marktext_str = current_shove_list[n].timber_string) and
          (current_shove_list[n].sv_code = svcOmit) then
          EXIT; // omit this timber, shove list.
      end;//next
    end
    else begin                             // show numbers for omitted timbers when shoving...
      for n := 0 to current_shove_list.Count - 1 do begin
        if (marktext_str = current_shove_list[n].timber_string) and
          (current_shove_list[n].sv_code = svcOmit) then begin
          // find somewhere to put it, timber centre-line calcs will be omitted.
          pnum.x := xtb;
          pnum.y := tbnumy_screen / 2;
          //  /2 arbitrary, to hihglight omitting.
          dotransform(keq, xtb, yeq, pnum, p1);
          // equalize/shove transform pnum to p1.
          shove_omitted := True;

          p2.x := p1.x;  // not needed for output if omitted..
          p2.y := p1.y;

        end;
      end;//next
    end;

    if timb_str = 'X' then begin
      case (tbn + 3 - wing_tbcount) of
        1:
          marktext_str := marktext_str + ' - Z';
        2:
          marktext_str := marktext_str + ' - Y';
        3:
          marktext_str := marktext_str + ' - X';
        4:
          marktext_str := marktext_str + ' - A';
        5:
          marktext_str := marktext_str + ' - B';
        6:
          marktext_str := marktext_str + ' - C';
        7:
          marktext_str := marktext_str + ' - D';
      end;//case
    end;

    if shove_omitted = True then
      marktext_str := '!' + marktext_str;   // indicate it's omitted while shoving.

    enter_mark(True, p1, p2, eMC_99_TimberNumber, marktext_str);

  finally
    tbn := tbn + 1;      // increment number even if omitted.
  end;//try
end;
//_______________________________________________________________________________________________________________________________

procedure endsleeper(x: double; full_length, retcurve, joint: boolean; dir: integer);
//  deal with approach and exit plain-track sleepers
//  enter with xtb to sleeper centre.
// joint=True this is a joint sleeper 212a

// dir added 218a

var
  sl_width: double;

begin
  if x > (turnoutx + scale / 3) then
    EXIT;     // max 4" beyond rail end.

  if (plain_track = False) and (dir = -1) and (approach_rails_only = True) then
    EXIT;   // 218a   no approach sleepering

  if joint = True then
    sl_width := jt_slwide
  else
    sl_width := slwide;

  xtb := x;                                   // !!! xtb is still global.
  if full_length = True then
    timberend(1)     // get yfs, yfsred to sleeper end
  else
    timberend(2);

  if pad_form.timber_centres_menu_entry.Checked = True then
    drawtimbcl(retcurve);     // sleeper centre-lines wanted
  if pad_form.timber_outlines_menu_entry.Checked = True
  // sleeper outlines wanted
  then begin
    xns := xtb - sl_width * inscale / 2;      // sleeper width, ( half each side of centre )
    xfs := xtb + sl_width * inscale / 2;
    drawtimber(full_length, retcurve);
  end;
  if pad_form.timber_numbers_menu_entry.Checked = True then
    tbnumber(retcurve)  // numbering wanted.
  else
    tbn := tbn + 1;         // do numbering last because increments tbn. (needed for timber shoves).
end;
//_______________________________________________________________________________________________________________________________

procedure drawtimbcl(retcurve: boolean);       // mark timber centre-line

var                                // enter with xtb, yns, yfs, tbq
  n: integer;
  pnum, p1, p2: Tpex;
  shove_this: integer;
  omit: boolean;
  xtimbcl: double;
  xshove, kshove, oshove, lshove, wshove, cshove: double;
  save_keq: double;

  yret, kret: double;

  str: string;

  dummy: double;
  x_curmod, x_curtimb, y_curmod, y_curtimb, k_curtimb: double;

  shove: Tshoved_timber;

  ////////////////////////////////////////////////////////////

  procedure calc_fill_timber_mark(code: EMarkCode);

  // this routine used only if timber outlines are not being drawn.

  var
    pk1, pk2, ponpad, pp1, pp2: Tpex;

  begin
    // first any blanking? (not bonus timbers or plain track)...

    if (timb_str <> 'B') and (plain_track = False) and
      ((p1.x < (startx - minfp)) or (p2.x < (startx - minfp))) then
      EXIT;

    dotransform(keq + k_curtimb, {xeq}xtimbcl, yeq{ytimbcl}, p1, pk1);
    // timber equalising + curving line angle, transform p1 to pk1 (relative to equalising centre).
    dotransform(keq + k_curtimb, {xeq}xtimbcl, yeq{ytimbcl}, p2, pk2);
    // ditto p2

    pk1.x := pk1.x + x_curmod;      // shift p1 to final position for the curving.
    pk1.y := pk1.y + y_curmod;

    dotransform(kform, xform, yform, pk1, ponpad);
    // transform to template position on pad..
    pp1.x := ponpad.x + xshift;
    pp1.y := ponpad.y + yshift;

    pk2.x := pk2.x + x_curmod;      // shift p2 to final position for the curving.
    pk2.y := pk2.y + y_curmod;

    dotransform(kform, xform, yform, pk2, ponpad);
    // transform to template position on pad..
    pp2.x := ponpad.x + xshift;
    pp2.y := ponpad.y + yshift;

    fill_mark(convert_point(pp1), convert_point(pp2), code, str);  // into marks list.
  end;
  /////////////////////////////////////////////////////////

begin
  timbcentre_wait.valid := False;             // init no data for drawing the centreline later.
  omit := False;                              // init omission flag

  xtimbcl := xtb;                             // so we don't modify xtb (global).

  xshove := 0;                                // init shove data for normal timber...
  kshove := 0;
  oshove := 0;
  lshove := 0;
  wshove := 0;
  cshove := 0;

  save_keq := keq;                            // ditto.

  str := timb_str + IntToStr(tbn);              // timber number string.

  shove_this := 0;     // default init - draw in normal centre-line colours.

  // see if this one gets shoved or omitted...

  for n := 0 to current_shove_list.Count - 1 do begin
    shove := current_shove_list[n];
    if (str = shove.timber_string) and (shove.sv_code <> svcEmpty)
    // this timber number is in shove list.
    then begin
      if (shove_timber_form.Showing = True) and
        (shove_timber_form.show_all_blue_checkbox.Checked = True) then
        shove_this := 40;  // will be drawn highlighted in blue or red.

      if shove.sv_code = svcOmit     // this value in the list is a flag.
      then
        omit := True       // he wants this timber omitted.
      else begin
        xshove := shove.sv_x;
        kshove := shove.sv_k;
        oshove := shove.sv_o;
        lshove := shove.sv_l;
        wshove := shove.sv_w;
        cshove := shove.sv_c;

        xtimbcl := xtb + xshove;   // he wants it shoved.
      end;
      BREAK;
    end;
  end;//for
  // see if this one is selected for shoving...

  if (str = current_shove_str) and (shove_timber_form.Showing = True) then begin
    shovetimbx := xtimbcl;       // centre of shoved timber.

    //shove_timber_form.xtb_panel.Caption:='  centre  X :  '+round_str(shovetimbx,2)+' mm';


    with shove_timber_form do begin
      // first clear these read-outs in case timber outlines (which calcs them) are switched off.
      throw_panel.Caption := '';
      length_panel.Caption := '';
      width_panel.Caption := '';
      twist_panel.Caption := '';
      crab_panel.Caption := '';

      if show_shove_fs = True then
        xtb_panel.Caption := ' centre :  ' + round_str(
          (shovetimbx - shovetimbx_zero) / inscale, 2) + ' ins'
      else
        xtb_panel.Caption := ' centre :  ' + round_str((shovetimbx - shovetimbx_zero), 2) + ' mm';

    end;//with

    shovex := xshove;
    // pick-up current shove data in case needed for mouse actions.
    shovek := kshove;
    shoveo := oshove;
    shovel := lshove;
    shovew := wshove;
    shovec := cshove;

    shove_this := 40;                // draw highlighted.
  end;
  //     else begin
  //if omit=True then EXIT;      // omit this timber unless it's selected for shoving.
  //shove_this:=0;               // draw normal timber.
  //          end;

  if omit = True then
    EXIT;      // omit this timber.

  if retcurve = True    // sleepering the return curve..
  then begin
    yret := aq25offset(xtimbcl, kret) - g / 2;
  end
  else begin
    yret := 0;
    kret := 0;
  end;
  // ready to draw cl.  add any shoves...

  p1.x := xtimbcl + cshove;
  p1.y := yfs + tbq + oshove + lshove + yret;
  p2.x := xtimbcl + cshove;
  p2.y := yns - tbq + oshove + yret;

  // 208a mods ...

  keq := keq + kshove + kret;       // add any twist.

  pnum.x := p2.x;

  pnum.y := p2.y - 1.5;     // position for numbering on screen 1.5mm below end of centre-line.

  dotransform(keq, xtimbcl, yeq, pnum, number_point_screen);
  // save screen numbering position in number_point.

  pnum.y := p2.y - 6;    // 208a    // position for numbering on output 6mm below end of centre-line.

  dotransform(keq, xtimbcl, yeq, pnum, number_point_output);
  // 208a  // save output numbering position in number_point.


  if (pad_form.timber_outlines_menu_entry.Checked = True) or (chair_marks = True)
  // added 213b
  then begin
    with timbcentre_wait do begin
      // save the actual co-ords, to be entered in list after the outlines.
      pex1 := p1;
      // (this is a fix - we must do the centre-line calcs first for shove timbers,
      pex2 := p2;
      //  but don't want the centre-lines overdrawn by timber infill.)
      kq := keq;
      shove_code := shove_this;
      valid := True;
    end;//with
  end;

  if pad_form.timber_outlines_menu_entry.Checked = False then begin
    // not doing any outlines, so do the timber centres now...

    // mods for parallel edges - 0.76.a  16-10-01...

    docurving(False, True, xtimbcl, yeq, x_curtimb, y_curtimb, k_curtimb, dummy);
    // calc curving for the timber rotation point.

    x_curmod := x_curtimb - xtimbcl;
    // shift required to rotation point, to suit the curving..
    y_curmod := y_curtimb - yeq;

    if midline = False then
      calc_fill_timber_mark(EMarkCode(4 + shove_this))  // 4 = centre-line,  44 = selected timber.
    else
      calc_fill_timber_mark(EMarkCode(14 + shove_this));
    // 14,54 = timber centre-line, use solid line if drawing rail centrelines. (for rivets?)
  end;

  keq := save_keq;       // restore global, for outlines, etc.
end;
//_______________________________________________________________________________________________________________________________

procedure drawtimber(full_length, retcurve: boolean);     // mark timber outline.
// enter with xtb, xns, xfs, yns, yfs, tbl (all unshoved)
// if full_length=False, this is for crossover exit road - so no far end.

var
  n: integer;
  p1, p2: Tpex;
  shove_this: integer;
  save_keq: double;
  str: string;
  xtimbcl: double;

  yret, kret: double;
  throw, crab: double;
  temp_k: double;
  dummy, dummy1, dummy2, dummy3: double;
  deg_str: string;

  x_curmod, x_curtimb, y_curmod, y_curtimb, k_curtimb: double;

  // 214a for chairs...

  chair_code: double;      // converted to integer later  1=S1 chair, 2=P chair, 3=
  chair_y: double;         // offset to chair centre.
  chair_k: double;         // chair angle (rail angle).
  chair_mod: double;

  S1_chair_outlong: double;    // Standard Railway Equipment 1926  S1 ordinary chairs
  S1_chair_inlong: double;     // chair length 14.1/2"
  S1_chair_halfwide: double;   // chair width 8"

  L1_chair_outlong: double;    // Standard Railway Equipment 1926  L1 bridge chairs
  L1_chair_inlong: double;     // chair length 10.1/2"
  L1_chair_halfwide: double;   // chair width 11"

  chair_outlong: double;
  chair_inlong: double;
  chair_halfwide: double;

  chair_space_y: double;

  eq_y, rail_y, xcl_mod: double;

  dummy_k: double;

  num_bridge: integer;

  bridge_over_ride: boolean;
  shove: Tshoved_timber;

  ////////////////////////////////////////////////////////////

  procedure calc_fill_chair_outline(code: EMarkCode);  // 214a

  // enter with chair rectangle centred on yeq

  var
    pk1, pk2, ponpad, pp1, pp2, pc1, pc2: Tpex;

    dummy1, dummy2: double;

  begin

    dotransform(({k_curtimb+}chair_k), xtimbcl,{yeq}0, p1, pk1);
    // rotate to required angle
    dotransform(({k_curtimb+}chair_k), xtimbcl,{yeq}0, p2, pk2);       // ditto p2

    pk1.y := pk1.y + (chair_y{-yeq});   // to actual rail position

    docurving(False, True, pk1.x, pk1.y, pc1.x, pc1.y, dummy1, dummy2);

    dotransform(kform, xform, yform,{pk1}pc1, ponpad);
    // transform to template position on pad..
    pp1.x := ponpad.x + xshift;
    pp1.y := ponpad.y + yshift;

    pk2.y := pk2.y + (chair_y{-yeq});

    docurving(False, True, pk2.x, pk2.y, pc2.x, pc2.y, dummy1, dummy2);

    dotransform(kform, xform, yform,{pk2}pc2, ponpad);
    // transform to template position on pad..
    pp2.x := ponpad.x + xshift;
    pp2.y := ponpad.y + yshift;

    fill_mark(convert_point(pp1), convert_point(pp2), code, '');  // into marks list.
  end;
  ////////////////////////////////////////////////////////////

  procedure calc_fill_timber_mark(code: EMarkCode);

  var
    pk1, pk2, ponpad, pp1, pp2: Tpex;

  begin

    dotransform(keq + k_curtimb, {xeq}xtimbcl, yeq{ytimbcl}, p1, pk1);
    // timber equalising + curving line angle, transform p1 to pk1 (relative to equalising centre).
    dotransform(keq + k_curtimb, {xeq}xtimbcl, yeq{ytimbcl}, p2, pk2);
    // ditto p2

    pk1.x := pk1.x + x_curmod;      // shift p1 to final position for the curving.
    pk1.y := pk1.y + y_curmod;

    dotransform(kform, xform, yform, pk1, ponpad);
    // transform to template position on pad..
    pp1.x := ponpad.x + xshift;
    pp1.y := ponpad.y + yshift;

    pk2.x := pk2.x + x_curmod;      // shift p2 to final position for the curving.
    pk2.y := pk2.y + y_curmod;

    dotransform(kform, xform, yform, pk2, ponpad);
    // transform to template position on pad..
    pp2.x := ponpad.x + xshift;
    pp2.y := ponpad.y + yshift;

    fill_mark(convert_point(pp1), convert_point(pp2), code, str);  // into marks list.
  end;
  /////////////////////////////////////////////////////////

  procedure calc_fill_dxf_chair_block_mark;

  var
    pk1, ponpad, pp1: Tpex;

  begin

    dotransform(keq + k_curtimb, {xeq}xtimbcl, yeq{ytimbcl}, p1, pk1);
    // timber equalising + curving line angle, transform p1 to pk1 (relative to equalising centre).

    pk1.x := pk1.x + x_curmod;      // shift p1 to final position for the curving.
    pk1.y := pk1.y + y_curmod;

    dotransform(kform, xform, yform, pk1, ponpad);
    // transform to template position on pad..
    pp1.x := ponpad.x + xshift;
    pp1.y := ponpad.y + yshift;

    // p2 contains chair angle and chair type code...

    enter_mark(True, p1, p2, eMC__493_DXFblock, '');     // -493 is DXF block marker
  end;
  /////////////////////////////////////////////////////////

begin
  shove_this := 0;     // default init - draw in normal timber colours.
  throw := 0;          // default init.
  crab := 0;

  save_keq := keq;                            // save the global.
  str := timb_str + IntToStr(tbn);              // timber number string.

  // see if this one gets shoved or omitted...

  for n := 0 to current_shove_list.Count - 1 do begin
    shove := current_shove_list[n];
    if (str = shove.timber_string) and (shove.sv_code <> svcEmpty)
    // this timber number is in shove list.
    then begin
      if (shove_timber_form.Showing = True) and
        (shove_timber_form.show_all_blue_checkbox.Checked = True) then
        shove_this := 90;
      // draw highlighted blue if required (may be overidden later for red if currently selected).

      if shove.sv_code = svcOmit                         // this value in the list is a flag.
      then
        EXIT//omit:=True              // he wants this timber omitted.
      else begin
        xns := xns + shove.sv_x - shove.sv_w;
        // he wants it shoved along and/or widened/narrowed.
        xfs := xfs + shove.sv_x + shove.sv_w;

        if xfs < (xns - inscale / 2)
        // if shoving produces a negative width (by more than 1/2" scale), average the sides to the centre-line.
        then begin
          xfs := (xfs + xns) / 2;
          xns := xfs;
          shove.sv_w := 0;
          // reset normal to prevent further narrowing.
        end;

        keq := keq + shove.sv_k;              // and/or twisted.

        yns := yns + shove.sv_o;              // and/or shoved across.
        ynsred := ynsred + shove.sv_o;

        yfs := yfs + shove.sv_o + shove.sv_l;
        yfsred := yfsred + shove.sv_o + shove.sv_l;

        throw := shove.sv_o;   // for read-out panel..
        crab := shove.sv_c;
      end;
      BREAK;
    end;
  end;//for

  xtimbcl := (xns + xfs) / 2;  // timber centre.

  total_template_timber_length := total_template_timber_length + (yfs - yns);  // 0/95.a

  if retcurve = True    // sleepering the return curve..
  then begin
    yret := aq25offset(xtimbcl, kret) - g / 2;
  end
  else begin
    yret := 0;
    kret := 0;
  end;

  keq := keq + kret;       // add any twist.

  // see if this one is to be shown selected for shoving...

  if (str = current_shove_str) and (shove_timber_form.Showing = True) then begin

    shovetimb_wide := xfs - xns;
    shovetimb_len := yfs - yns;
    shovetimb_throw := throw;
    shovetimb_crab := crab;

    if show_shove_fs = True then begin
      shove_timber_form.width_panel.Caption :=
        ' width :  ' + round_str(shovetimb_wide / inscale, 2) + ' ins';
      shove_timber_form.length_panel.Caption :=
        ' length :  ' + round_str(shovetimb_len / inscale, 2) + ' ins';
      shove_timber_form.throw_panel.Caption :=
        ' throw :  ' + round_str(shovetimb_throw / inscale, 2) + ' ins';
      shove_timber_form.crab_panel.Caption :=
        ' crab :  ' + round_str(shovetimb_crab / inscale, 2) + ' ins';
    end
    else begin
      shove_timber_form.width_panel.Caption :=
        ' width :  ' + round_str(shovetimb_wide, 2) + ' mm';
      shove_timber_form.length_panel.Caption :=
        ' length :  ' + round_str(shovetimb_len, 2) + ' mm';
      shove_timber_form.throw_panel.Caption :=
        ' throw :  ' + round_str(shovetimb_throw, 2) + ' mm';
      shove_timber_form.crab_panel.Caption :=
        ' crab :  ' + round_str(shovetimb_crab, 2) + ' mm';
    end;

    if show_origin_k = True then begin
      docurving(False, True,{xtb}xtimbcl, g / 2, dummy1, dummy2, temp_k, dummy3);
      // curving angle to this xtb.
      shovetimb_keq := (keq + temp_k) * hand_i;
      // twist angle from template origin.

      if shovetimb_keq < 0 then
        deg_str := ' degs '        // no room for "degrees" in full if negative.
      else
        deg_str := ' degrees ';

      shove_timber_form.twist_panel.Caption :=
        ' twist :  ' + round_str(shovetimb_keq * 180 / Pi, 2) + deg_str + '÷';
    end
    else begin
      shovetimb_keq := keq * hand_i;
      if shovetimb_keq < 0 then
        deg_str := ' degs '        // no room for "degrees" in full if negative.
      else
        deg_str := ' degrees ';

      shove_timber_form.twist_panel.Caption :=
        ' twist :  ' + round_str(shovetimb_keq * 180 / Pi, 2) + deg_str + '¬';
    end;

    shove_this := 30;                 // draw highlighted in red.

  end;

  // now ready to make timbering marks...

  // mods for parallel edges - 0.76.a  16-10-01...

  docurving(False, True,{xeq}xtimbcl, yeq{ytimbcl}, x_curtimb, y_curtimb, k_curtimb, dummy);
  // calc curving for the timber rotation point.

  x_curmod := x_curtimb -{xeq}xtimbcl;   // shift required to rotation point, to suit the curving..

  y_curmod := y_curtimb - yeq{ytimbcl};

  try
    // first any blanking? (not bonus timbers)...

    if (timb_str <> 'B') and (plain_track = False) and (xfs < startx) then
      EXIT;  //ignore whole timber if heel side is blanked.

    // first do any timber infill, so outlines and reduced ends can can overwrite, possibly in a different colour..

    if timbering_infill = True then begin
      p1.x := xns + crab;
      p1.y := yns + yret;
      p2.x := xns + crab;
      p2.y := yfs + yret;
      calc_fill_timber_mark(EMarkCode(203 + shove_this));

      p1.x := xfs + crab;
      p1.y := yfs + yret;
      p2.x := xfs + crab;
      p2.y := yns + yret;
      calc_fill_timber_mark(eMC_0_Ignore);
    end;

    // then timber outlines..

    p1.x := xns - tbl + crab;
    p1.y := yns + yret;
    p2.x := xfs + tbl + crab;
    p2.y := yns + yret;
    calc_fill_timber_mark(EMarkCode(3 + shove_this));
    // mark timber near end. ( 3 = timber outline.)
    // (33 = highlighted timber outline).

    if full_length = True then begin
      p1.x := xns - tbl + crab;
      p1.y := yfs + yret;
      p2.x := xfs + tbl + crab;
      p2.y := yfs + yret;
      calc_fill_timber_mark(EMarkCode(3 + shove_this));      // mark timber far end
    end;


    p1.x := xns + crab;
    p1.y := yns - tbl + yret;
    p2.x := xns + crab;
    p2.y := yfs + tbl + yret;
    calc_fill_timber_mark(EMarkCode(3 + shove_this));       // timber toe side.

    p1.x := xfs + crab;
    p1.y := yns - tbl + yret;
    p2.x := xfs + crab;
    p2.y := yfs + tbl + yret;
    calc_fill_timber_mark(EMarkCode(3 + shove_this));       // timber heel side.

    //-------------

    if (nine_foot = True) and (reduced_ends = True)   // standard 9ft timbering..
    then begin
      if shove_this = 30 then
        shove_this := 50;

      p1.x := xns - tbl + crab;           // draw reduced timber ends (close-dotted) ...
      p1.y := ynsred + yret;
      p2.x := xfs + tbl + crab;
      p2.y := ynsred + yret;
      calc_fill_timber_mark(EMarkCode(5 + shove_this)); // 5 =  timber reduced near end
      // 55 = highlighted reduced ends (selected, red).
      // 95 = highlighted reduced ends (shoved, blue).
      if full_length = True then begin
        p1.x := xns - tbl + crab;
        p1.y := yfsred + yret;
        p2.x := xfs + tbl + crab;
        p2.y := yfsred + yret;
        calc_fill_timber_mark((EMarkCode(5 + shove_this)));       // timber reduced far end
      end;
    end;

    // can now do the timber centre-lines if there is some data...

    if (pad_form.timber_centres_menu_entry.Checked = True) and (timbcentre_wait.valid = True) then
    begin

      with timbcentre_wait do begin
        // saved actual co-ords, to be entered in list after the outlines.
        p1 := pex1;
        // (this is a fix - we must do the centre-line calcs first for the shove timber select,
        p2 := pex2;
        //  but don't want the centre-lines overdrawn by timber infill.)
        keq := kq;
        shove_this := shove_code;

        valid := False;       // don't use this data again.
      end;//with

      if midline = False then
        calc_fill_timber_mark(EMarkCode(4 + shove_this))
      // 4 = centre-line,  44 = selected timber.
      else
        calc_fill_timber_mark(EMarkCode(14 + shove_this));
      // 14,54 = timber centre-line, use solid line if drawing rail centrelines. (for rivets?)

    end;

    // 214a and finally do the experimental chairs...
    //(*

    if (chair_marks = True) and (exp_chairing = True)    // generator  AND  template option
    then begin
      // add chair outlines and markers  214a ...

      if (timb_str = 'S') and (csi.num_slide_chairs = 0) then
        EXIT;  // temp only REA switches yet. 214a

      if (timb_str = 'R') and (xtimbcl < trpx) then
        EXIT;            // temp not yet on return curve section

      if timb_str = 'X' then
        EXIT;                                 // temp not yet crossing

      chair_code := 0;  // init

      num_bridge := 0;  // init

      bridge_over_ride := False;    // init

      S1_chair_outlong := 9.16 * inscale;
      // Standard Railway Equipment 1926  S1 ordinary chairs
      S1_chair_inlong := 5.34 * inscale;     // chair length 14.1/2"
      S1_chair_halfwide := 4 * inscale;

      L1_chair_outlong := 6.91 * inscale;
      // Standard Railway Equipment 1926  L1 bridge chairs
      L1_chair_inlong := 3.59 * inscale;     // chair length 10.1/2"
      L1_chair_halfwide := 5.5 * inscale;    // chair width 11"

      chair_outlong := 0; // keep compiler happy...
      chair_inlong := 0;
      chair_halfwide := 0;

      yeq := aq3offset(xtimbcl, dummy_k) / 2;

      docurving(False, True, xtimbcl, yeq, x_curtimb, y_curtimb, k_curtimb, dummy);
      // calc curving for the timber rotation point.

      x_curmod := x_curtimb - xtimbcl;
      // shift required to rotation point, to suit the curving..

      y_curmod := y_curtimb - yeq;


      {
              if (timb_str='T')
              or (timb_str='A')
              or (timb_str='E')
              or (timb_str='J')
              or (timb_str='N')
              or (timb_str='B')


              if (timb_str<>'X')     // not crossing section
                 then begin
}

      chair_code := 1;  // S1 ordinary chairs   default

      // from gauge-face

      chair_outlong := S1_chair_outlong;
      chair_inlong := S1_chair_inlong;
      chair_halfwide := S1_chair_halfwide;

      // see if L1 bridge chairs needed instead...
      // calc space available on the turnout side. (main side has priority for ordinary chairs)

      if (timb_str = 'T') or ((timb_str = 'S') and (csi.num_slide_chairs > 0) and
        (tbn > (csi.num_slide_chairs + csi.num_block_slide_chairs + csi.num_block_heel_chairs)))
      then begin
        chair_space_y := aq3offset(xtimbcl - S1_chair_halfwide, dummy_k) - g;
        // calc for turnout side

        if chair_space_y < (L1_chair_outlong + L1_chair_inlong) then
          EXIT;  // temp even bridge chairs conflict - needs bolted half-chairs.

        if chair_space_y < (S1_chair_outlong + S1_chair_inlong + inscale)
        // require 1" space between them
        then begin

          // need 1 or 2 L1 bridge chairs.

          if chair_space_y < (S1_chair_outlong + L1_chair_inlong + inscale)
          // calc for turnout side, both chairs L1 ?
          then
            num_bridge := 2
          else
            num_bridge := 1;  // flag to over-ride bridge chairs on main road

          chair_code := 5;  // L1 bridge chairs

          // from gauge face

          chair_outlong := L1_chair_outlong;
          chair_inlong := L1_chair_inlong;
          chair_halfwide := L1_chair_halfwide;

        end;
      end;

      if (timb_str = 'S') and (csi.num_slide_chairs > 0) and (tbn <= csi.num_slide_chairs) then
      begin
        chair_code := 2;  // P slide chairs

        // from gauge-face

        chair_outlong := 9.16 * inscale;    // Standard Railway Equipment 1926
        chair_inlong := 8.84 * inscale;     // chair length 18"
        chair_halfwide := 4 * inscale;
      end;

      if (timb_str = 'S') and (csi.num_block_slide_chairs > 0) and
        (tbn > csi.num_slide_chairs) and (tbn <= (csi.num_slide_chairs +
        csi.num_block_slide_chairs))
      then begin
        chair_code := 3;
        // 1P and 2P block slide chairs (no inner jaw - bolted distance blocks)

        // from gauge-face

        chair_outlong := 9.16 * inscale;
        // Standard Railway Equipment 1926
        chair_inlong := aq2offset(xtimbcl, chair_k) + 4.84 * inscale;
        chair_halfwide := 4 * inscale;
      end;

      if (timb_str = 'S') and (csi.num_block_heel_chairs > 0) and
        (tbn > (csi.num_slide_chairs + csi.num_block_slide_chairs)) and
        (tbn <= (csi.num_slide_chairs + csi.num_block_slide_chairs + csi.num_block_heel_chairs))
      then begin
        chair_code := 4;  // 3P+ block chairs (inner jaw)

        // from gauge-face

        chair_outlong := 9.16 * inscale;
        // Standard Railway Equipment 1926
        chair_inlong := aq2offset(xtimbcl, chair_k) + 5.34 * inscale;
        chair_halfwide := 4 * inscale;
      end;


      if chair_code = 0 then
        EXIT;  // no other chairs done yet


      // now calc them ...

      chair_mod := (chair_outlong + chair_inlong) / 2 - chair_inlong;
      // adjust to chair middle from gauge-face

      eq_y := aq3offset(xtimbcl, dummy_k) / 2;     // equalizing rotation point (as yeq)

      // main road stock rail...

      if (chair_code = 5) and (num_bridge = 1)  // over-ride bridge chairs?
      then begin
        bridge_over_ride := True;

        chair_code := 1;  // S1 ordinary chairs instead

        chair_outlong := S1_chair_outlong;
        chair_inlong := S1_chair_inlong;
        chair_halfwide := S1_chair_halfwide;

        chair_mod := (chair_outlong + chair_inlong) / 2 - chair_inlong;
        // adjust to chair middle from gauge-face
      end
      else
        bridge_over_ride := False;

      chair_k := 0;
      chair_y := 0;  // MS

      rail_y := 0;
      xcl_mod := (eq_y - rail_y + chair_mod) * TAN(keq);
      // approx forward shift when equalized

      p1.x := xtimbcl + xcl_mod - chair_halfwide;
      p1.y := yret - chair_outlong;

      p2.x := p1.x;
      p2.y := yret + chair_inlong;

      calc_fill_chair_outline(eMC_493_Chair);


      p1.x := xtimbcl + xcl_mod + chair_halfwide;
      p1.y := yret + chair_inlong;

      p2.x := p1.x;
      p2.y := yret - chair_outlong;

      calc_fill_chair_outline(eMC_0_Ignore);

      // main road crossing rail...

      if (timb_str <> 'S')  // chairing restarts at heel
        or ((timb_str = 'S') and (csi.num_slide_chairs > 0) and
        (tbn > (csi.num_slide_chairs + csi.num_block_slide_chairs + csi.num_block_heel_chairs)))
      then begin

        chair_k := 0;
        chair_y := g;  // TS

        rail_y := g;
        xcl_mod := 0 - (rail_y - eq_y + chair_mod) * TAN(keq);
        // approx backward shift when equalized

        p1.x := xtimbcl + xcl_mod - chair_halfwide;
        p1.y := yret + chair_outlong;

        p2.x := p1.x;
        p2.y := yret - chair_inlong;

        calc_fill_chair_outline(eMC_493_Chair);


        p1.x := xtimbcl + xcl_mod + chair_halfwide;
        p1.y := yret - chair_inlong;

        p2.x := p1.x;
        p2.y := yret + chair_outlong;

        calc_fill_chair_outline(eMC_0_Ignore);
      end;


      if bridge_over_ride = True  // reset bridge chairs for turnout road ?
      then begin
        chair_code := 5;  // L1 bridge chairs

        chair_outlong := L1_chair_outlong;
        chair_inlong := L1_chair_inlong;
        chair_halfwide := L1_chair_halfwide;

        chair_mod := (chair_outlong + chair_inlong) / 2 - chair_inlong;
        // adjust to chair middle from gauge-face
      end;

      //end;


      if (timb_str = 'T') or ((timb_str = 'S') and (csi.num_slide_chairs > 0) and
        (tbn > (csi.num_slide_chairs + csi.num_block_slide_chairs + csi.num_block_heel_chairs)))
      then begin

        // turnout road crossing-rail chairs...

        chair_y := aq2offset(xtimbcl, chair_k);

        if keq = 0 then
          xcl_mod := 0    // no equalizing
        else begin
          try
            xcl_mod :=
              (chair_y - eq_y - chair_mod) * SIN(keq) / COS(chair_k - keq) * COS(chair_k);
            // approx shift when equalized
          except
            xcl_mod := 0;    // !!! 90 degrees?
          end;//try
        end;

        p1.x := xtimbcl - xcl_mod - chair_halfwide - chair_mod * SIN(chair_k);
        // create chair rectangle at y=0 ...
        p1.y := yret - chair_outlong;

        p2.x := p1.x;
        p2.y := yret + chair_inlong;

        calc_fill_chair_outline(eMC_493_Chair);


        p1.x := xtimbcl - xcl_mod + chair_halfwide - chair_mod * SIN(chair_k);
        p1.y := yret + chair_inlong;

        p2.x := p1.x;
        p2.y := yret - chair_outlong;

        calc_fill_chair_outline(eMC_0_Ignore);

      end;// T timbers

      if (timb_str = 'T') or (timb_str = 'S') then begin

        // turnout road stock rail chairs...

        chair_y := aq3offset(xtimbcl, chair_k);

        if keq = 0 then
          xcl_mod := 0    // no equalizing
        else begin
          try
            xcl_mod :=
              (chair_y - eq_y + chair_mod) * SIN(keq) / COS(chair_k - keq) * COS(chair_k);
            // approx shift when equalized
          except
            xcl_mod := 0;    // !!! 90 degrees?
          end;//try
        end;

        //wrong info  if (chair_code=3) or (chair_code=4) then chair_k:=0;  // block chairs are always square-on.

        p1.x := xtimbcl - xcl_mod - chair_halfwide + chair_mod * SIN(chair_k);
        // create chair rectangle at y=0 ...
        p1.y := yret + chair_outlong;

        p2.x := p1.x;
        p2.y := yret - chair_inlong;

        calc_fill_chair_outline(eMC_493_Chair);


        p1.x := xtimbcl - xcl_mod + chair_halfwide + chair_mod * SIN(chair_k);
        p1.y := yret - chair_inlong;

        p2.x := p1.x;
        p2.y := yret + chair_outlong;

        calc_fill_chair_outline(eMC_0_Ignore);

      end;

    end;

    //*)

  finally
    keq := save_keq;        // restore global.
  end;//try
end;
//_______________________________________________________________________________________________________________________________

procedure timberend(size: integer);            //  calc timber ends and equalizing angle.

//   enter with xtb and return yns, yfs for centre of timber ends.
//   size=0 is timber, size=1 is sleeper, size=2 is reduced-length sleeper (for crossover exit track)
//   also enter with frackeq fraction of full equalizing angle required.

var
  k: double;
  sliptimb_inc: double;
  yaq3, rawns, rawfs, rawtblen, tblen6, tblen6int, tblen: double;
  extended_for_slip: boolean;

begin
  yaq3 := aq3offset(xtb, k);
  // offset to curved stock rail, gauge-face at this xtb. also returns angle in k.
  rawfs := 0 - ynsnorm + yaq3;
  // raw timber far-end to equalize it each side of stock rails.
  rawns := ynsnorm;               // timber near-end.

  // extend timbers for tandem   218a  ...

  if (size = 0) and (tandem_timb > 0) then begin
    if tandem_timb = 1 then
      if xtb > dpx then
        rawns := (g - rawfs) * 3 / 4;     // =1  1st double-sided tandem turnout

    if tandem_timb = 2 then
      if xtb < dpx then
        rawns := (g - rawfs) * 1.7      // =2  2nd double-sided tandem turnout
      else
        rawns := (g - rawfs) * 1.4;

    if tandem_timb = 3 then
      if xtb < dpx then
        rawfs := rawfs + yaq3 - g * 0.75    // =3  1st single-sided tandem turnout
      else
        rawfs := rawfs + yaq3 - g * 0.6;

    if tandem_timb = 4 then
      rawns := g * 3 + rawns * 4 - rawfs; //rawns+(g-rawfs)/2;

  end;

  // calc extension length of half_diamond timbers for slip...

  if (size = 0) and (half_diamond = True) and (hd_timbers > 0) and (xtb > setx) and
    (xtb < (toex + sliptipsl)) then begin
    extended_for_slip := True;
    try
      sliptimb_inc := sliprad - SQRT(SQR(sliprad) - SQR(sliptipsl - (xtb - toex)));
    except
      extended_for_slip := False;
      sliptimb_inc := 0;
    end;//try

    if (hd_timbers = 1) or (hd_timbers = 3) then
      rawfs := rawfs + sliptimb_inc;    // TS or both.
    if (hd_timbers = 2) or (hd_timbers = 3) then
      rawns := rawns - sliptimb_inc;    // MS or both.
  end
  else begin
    extended_for_slip := False;
    sliptimb_inc := 0;
  end;

  tblen := 0;    // keep compiler happy.


  // mods 0.78.a   11-11-02... (adjustable step size, also for 00 gauge).

  case size of
    0: begin                          // timber...
      if timbinc > minfp             // stepped timber lengths.
      then begin
        rawtblen := rawfs - rawns;                // raw timber length.
        tblen6 := (rawtblen) / inscale / timbinc;
        // number of length increments in this timber length.
        tblen6int := INT(tblen6 + 0.67);
        // round up to next increment if more than 1/3rd increment extra, otherwise down.
        // ( 2" is 1/3rd of 6")
        tblen := tblen6int * timbinc * inscale;     // adjusted timber length in mm
        maintimb := 1;                          // flag timber width
        yfsnorm := rawns + tblen;                 // return adjusted far end.
      end
      else begin
        yfsnorm := rawfs;                 // gradual steps, leave unadjusted.
        tblen := yfsnorm - rawns;
        maintimb := 1;                    // flag timber width
      end;
    end;

    1: begin
      tblen := tb;        // standard sleeper.

      if (gaunt = False) or (xtb >= xorg) or (plain_track = True)
      // plain track 211c bug fix          //0.93.a
      then
        yfsnorm := rawns + tblen                                // return far end.
      else
        yfsnorm := rawns + tblen + gaunt_sleeper_mod_in * inscale;
      // extended sleeper for gauntletted approach track.

      yaq3 := g;                 // for end centralizing.
      maintimb := 0;             // flag sleeper width.
    end;

    2: begin
      tblen := tb / 8;             // 1/8th of standard sleeper.
      yfsnorm := rawns + tblen;    // return adjusted far end.
      yaq3 := g;                 // for end centralizing.
      maintimb := 0;             // flag sleeper width.
    end;

    else
      run_error(141);

  end;//case

  if (half_diamond = True) and (size = 0) then begin
    if tradius_is_straight = True then
      keq := k3 / 2   // regular diamond, timbers equalized-constant at half V-crossing angle.
    else
      keq := k / 2;   // 0.93.a irregular diamond, maintain timbers at half angle in stock rail.
  end
  else begin
    if timbers_equalized = True       // equalized style, rotate timbers...
    then begin
      if (equalizing_fixed = True) and (frackeq <> 0)
      // constant angle and not a square-on portion..
      then
        keq := k3 / 2                           // constant angle = half of crossing angle.
      else
        keq := k / 2 * frackeq;
      // angle is half gradient of curved stock rail, modified by the equalizing fraction in force for this timber.
    end
    else begin                                     // square-on style...
      if (square_on_angled = True) and (frackeq <> 0) then
        keq := k    // to turnout road. (29-7-01 approximately square to turnout road, rotation point is not on outer rail)
      else
        keq := 0;   // to main road.
    end;
  end;

  yeq := yaq3 / 2;           // centralize rotation point between stock rails.
  //xeq:=xtb;

  randk := randangle / 50;              // randomize angle by 0-.18 rads (approx 10 degrees).
  keq := keq - randk + randk * Random * 2;

  // centralize ends if wanted...

  eqendmod := 0;            // init amount of movement needed.
  if size <> 2              // normal length sleeper or timber.
  then begin
    if ((half_diamond = False) and
      (ms_ends = False))  // turnout/plain track with centralized ends.
      or (half_diamond = True) and (tandem_timb <> 4)
    // half-diamond always centralized    unless partial in a tandem 218b
    then
      eqendmod := 0 - rawns - (tblen - yaq3) / 2;        // amount of centralizing mod needed.

    // modify if extended for slip one side only...

    if (half_diamond = True) and (extended_for_slip = True)
    // half-diamond extended timbers for slip.
    then begin
      case hd_timbers of
        1:
          eqendmod := eqendmod + sliptimb_inc / 2;  // TS side.
        2:
          eqendmod := eqendmod - sliptimb_inc / 2;  // MS side.
      end;//case
    end;
  end;

  randmod := 0 - randend + randend * Random * 2;      // end-randomizing amount

  yns := rawns + randmod + eqendmod;            // return near end
  yfs := yfsnorm + randmod + eqendmod;          // return far end

  ynsred := yns + tbred;                        // and the reduced near end
  if size = 2 then
    yfsred := yfs
  else
    yfsred := yfs - tbred;         // and the reduced far end.
end;
//_______________________________________________________________________________________________________________________________

procedure set_plain_track(pt, new_label: boolean);  // !!! new_label not used 0.82.a

var
  save_peg_code: integer;

begin

  with pad_form do begin
    if pt = True                       // set up for drawing plain track.
    then begin
      //track_menu_top_entry.Caption:='      PLAIN  TRACK  :';

      save_peg_code := peg_code;

      if peg_rail = 2 then
        peg_on_rail1_menu_entry.Click;     // no curved turnout rail.
      //if peg_rail=4 then peg_on_rail3_menu_entry.Click;     // no curved stock rail.
      if peg_rail = 3 then
        peg_on_rail4_menu_entry.Click;     // no straight turnout rail.
      if peg_rail = 9 then
        peg_on_rail8_menu_entry.Click;
      // can't run peg up turnout road centre-line, put it on main-side centre-line.

      peg_code := save_peg_code;                           // (the above clicks set code 20).
      startx := 0;
      // blanking not valid for plain track - change length instead.
      half_diamond := False;
      // nor half-diamond (loses the rails).

      peg_on_rail2_menu_entry.Enabled := False;
      peg_on_rail3_menu_entry.Enabled := False;
      peg_on_rail9_menu_entry.Enabled := False;

      peg_on_rail4_menu_entry.Caption :=
        'on  running  rail  &4  ( TS )               Ctrl-Numpad-4';
      peg_on_rail1_menu_entry.Caption :=
        'on  running  rail  &1  ( MS )              Ctrl-Numpad-1';

      crop_approach_menu_entry.Enabled := False;
      blank_to_peg_menu_entry.Enabled := False;      // no blanking for plain track.

      length_free_popup_entry.Enabled := False;
      // must stay locked to draw approach track...
      length_free_menu_entry.Enabled := False;

      snap_to_catch_points_menu_entry.Enabled := False;
      snap_to_MVJP_menu_entry.Enabled := False;
      snap_exit_track_menu_entry.Enabled := False;
      snap_to_heel_menu_entry.Enabled := False;
      blank_to_toe_menu_entry.Enabled := False;

      insert_turnout_menu_entry.Enabled := True;
      lengths_rails_menu_entry.Enabled := True;
      roll_rails_by_menu_entry.Enabled := True;
      convert_to_plain_track_menu_entry.Enabled := False;
      swap_facing_trailing_menu_entry.Enabled := False;
      swap_current_facing_trailing_menu_entry.Enabled := False;

      nearest_menu_entry.Enabled := False;
      basic_turnout_menu_entry.Enabled := False;


      turnout_i := 1;      // length locked at new turnoutx.

      // so can draw approach track...

      length_free_popup_entry.Enabled := False;
      length_free_menu_entry.Enabled := False;

      //adjust_roam_menu_entry.Enabled:=False;

      //control_room_form.plain_track_menu_entry.Checked:=True;           // radio item.
    end
    else begin
      //track_menu_top_entry.Caption:='      TURNOUT  :';

      peg_on_rail2_menu_entry.Enabled := True;
      peg_on_rail3_menu_entry.Enabled := True;
      peg_on_rail9_menu_entry.Enabled := True;

      peg_on_rail4_menu_entry.Caption :=
        'on  turnout-road  stoc&k  rail            Ctrl-Numpad-4';
      peg_on_rail1_menu_entry.Caption :=
        'on  main-road  &stock  rail               Ctrl-Numpad-1';

      crop_approach_menu_entry.Enabled := True;
      blank_to_peg_menu_entry.Enabled := True;

      snap_to_catch_points_menu_entry.Enabled := True;
      snap_to_MVJP_menu_entry.Enabled := True;
      snap_exit_track_menu_entry.Enabled := True;
      snap_to_heel_menu_entry.Enabled := True;
      blank_to_toe_menu_entry.Enabled := True;


      insert_turnout_menu_entry.Enabled := False;
      lengths_rails_menu_entry.Enabled := False;
      roll_rails_by_menu_entry.Enabled := False;
      convert_to_plain_track_menu_entry.Enabled := True;
      swap_facing_trailing_menu_entry.Enabled := True;
      swap_current_facing_trailing_menu_entry.Enabled := True;

      nearest_menu_entry.Enabled := True;
      basic_turnout_menu_entry.Enabled := True;
      //draw_with_diagnostics_menu_entry.Enabled:=True;

      length_free_popup_entry.Enabled := True;       // disabled for plain track..
      length_free_menu_entry.Enabled := True;

      //adjust_roam_menu_entry.Enabled:=True;
      //control_room_form.turnout_menu_entry.Checked:=True;           // radio item.
    end;

    //reset_to_plain_track_menu_entry.Checked:=pt;
    //convert_to_plain_track_menu_entry.Checked:=pt;
  end;//with pad form

  railedges(gauge_faces, outer_edges, centre_lines);
  // !!! 30-11-99 may need to put aq 25 back on.

  if shove_timber_form.Showing = True then begin
    current_shove_str := '';      // de-select any shoved timber.
    shovetimbx := 0;
    shove_buttons(False, -1);
  end;

  enable_peg_positions;    // to enable/disable the peg options for Ctrl-# KB shortcuts.
end;
//_________________________________________________________________________________________

function check_infill_ok(str: string): boolean;
  // ensure generator is on if he wants timber infill.

begin
  Result := False;                // default init.

  if timbering_infill = False then begin
    if alert(3, '    show  timber  infill', 'It is not possible to show ' +
      str + ' infilled timbers for the control template while this feature remains switched off in the GENERATOR SETTINGS.', '', '', '', '', 'cancel', 'change  generator  setting  -  timber  infill  on', 0) = 5 then
      EXIT;

    pad_form.timbering_infill_menu_entry.Click;
    Result := True;
  end
  else
    Result := True;
end;
//__________________________________________________________________________________________

procedure adjacent_redraw;     //  do a re-draw after selecting/deselecting adjacent rails.

begin
  railedges(gauge_faces, outer_edges, centre_lines);
  redraw(True);               //  do a re-draw
end;
//_________________________________________________________________________________________

procedure clear_transform_data;

begin
  cancel_adjusts(False);
  xform := 0;
  yform := 0;
  kform := 0;
  xshift := 0;
  yshift := 0;
end;
//____________________________________________________________________________________________

procedure keep_colours1;           // scheme 1 colours for the keep form...

begin
  keep_paper_colour := clWhite; // was clSilver;
  keep_grid_colour := clWhite;
  keep_timber_colour := clOlive;
  keep_rail_colour := clBlack;
  keep_mark_colour := clGray;
end;
//________________________________________________________________________________________

procedure keep_colours2;           // scheme 2 colours for the keep form...

begin
  keep_paper_colour := clWhite;
  keep_grid_colour := clGray;
  keep_timber_colour := clBlue;
  keep_rail_colour := clBlack;
  keep_mark_colour := clSilver;
end;
//________________________________________________________________________________________

procedure keep_colours3;           // scheme 3 colours for the keep form...

begin
  keep_paper_colour := clWhite; // was clSilver;
  keep_grid_colour := clWhite;
  keep_timber_colour := clGray;
  keep_rail_colour := clBlack;
  keep_mark_colour := clGray;
end;
//________________________________________________________________________________________

procedure set_pad_start_colours(change_flag: boolean);

// default pad (screen) colours  (not for printing)...
begin
  if (pad_cols_set = False) or (change_flag = True)
  // not if already set unless overide asked for.
  then begin
    if hi_color = True                   // can we use 16-bit colours or better ?
    then
      pad_normal                 // yes.
    else begin                                   // no, 256 colours or less.
      //info_form.user_memo.Color:=clWindow;  // use her normal screen colour for the memo.
      case start_colours of
        0:
          pad_silver;
        1: begin
          pad_bright;
          timber_colour := clOlive;
          timber_infill_colour := clMaroon;
          paper_colour := clBlack;

          selection_colour := clYellow;
          hover_colour := clWhite;

          grid_colour := clTeal;
          ring_colour := clLime;
          ring_copy_colour := clFuchsia;
          pad_form.Font.Color := clSilver;
          preview_form.Font.Color := clWhite;
          pad_form.bgnd_keeps_font_label.Font.Color := clSilver;
          // bgnd keeps.
          pad_form.pad_timber_font_label.Font.Color := clSilver;
          // timber numbers.

          shapes_colour := clLime;
          shapes_label_font.Color := shapes_colour;

          info_form.Color := clBtnFace;
          bgkeep_timber_colour := clGray;
          bgkeep_timberfill_colour := clNavy;

          bgkeep_mark_colour := clFuchsia;

          keep_colours1;
          // colours for the keep form.
        end;
        -1:
          pad_all_grey;
        else
          run_error(153);
      end;//case
    end;
    ink_colour := clBlack;                     // init current colour for drawing.
    pad_cols_set := True;                      // colours have been set.
    pad_form.Color := paper_colour;            // change the pad colour if nec.

    shapes_label_font.Color := shapes_colour;
  end;
end;
//_________________________________________________________________________________________

procedure pad_normal;
// set normal pad colours for Hi-Color...
begin
  paper_colour := $00E0C0A0;             // a nice grey-blue for the drawing paper.
  grid_colour := $00C0A080;              // with a darker blue for the screen grid.
  ring_colour := $008000C0;              // mauve spacing-ring.
  ring_copy_colour := $00FF0080;         // violet ring copies. // 0.98.a
  page_colour := $00FF0080;              // and violet for the printer page outlines.
  pad_form.Font.Color := clNavy;
  preview_form.Font.Color := clBlack;

  selection_colour := $000000B0;
  hover_colour := clWhite;

  rail_colour := clBlack;                // rail lines in black.
  timber_colour := $000060A0;            // red-brown timbers (screen colour).
  timber_infill_colour := $00D8D0B0;     //00C0D090;     //00B0D888;     // grey-green infill.

  shapes_colour := $00205878;
  // green-brown 214a  was  $0000FFD0;  lime  212a  was $006000A0;          // dark pink.
  shapes_label_font.Color := shapes_colour;

  bgkeep_rail_colour := clBlue;
  bgkeep_timber_colour := $00608000;         // sage green.
  bgkeep_timberfill_colour := $00C0C090;

  bgkeep_mark_colour := clBlack;
  bgkeep_peg_colour := clYellow;

  bgkeep_platform_colour := $0060C0;   // tan 0.93.a

  guide_colour := $00C0FFFF;
  // cream for track centre-lines, planing marks and f.p. - 0.93.a and platform outlines
  align_colour := $0000FFE0;             // rad ends (limey yellow).
  trans_colour := clWhite;               // transition marks.
  joint_colour := clBlue;                // rail joints in blue.

  //info_form.user_memo.Color:=$00FFE0C0;       // a nice pale mauve for the memo ?
  //info_form.Color:=$00B0FFFF;                 // primrose.
  info_form.Color := $00F1E3D7;  // 0.93.a for Windows 7 child borders

  //pad_form.mouse_font_label.Font.Color:=clBlue;        // mouse labels.
  pad_form.bgnd_keeps_font_label.Font.Color := $000000B0;
  // brick red   // 208a was clMaroon;   // bgnd keeps.
  pad_form.pad_timber_font_label.Font.Color := clBlue;     // timber numbers.

  pad_form.sb_black_white_menu_entry.Click;    // scalebar colours.

  keep_paper_colour := clWhite; // was $00FFF0D8;      // ice blue,  colours for the keep form...
  keep_grid_colour := clTeal;

  keep_rail_colour := clBlack;
  keep_mark_colour := clGray;
  keep_timber_colour := clMaroon;
end;
//__________________________________________________________________________________________

procedure pad_all_grey;
// set pad colours for all-grey scheme...
begin
  paper_colour := clWhite;
  grid_colour := clSilver;
  ring_colour := clBlack;
  ring_copy_colour := clBlack;
  page_colour := clGray;
  pad_form.Font.Color := clBlack;
  preview_form.Font.Color := clBlack;

  selection_colour := clBlack;
  hover_colour := clSilver;

  rail_colour := clBlack;
  timber_colour := clBlack;
  timber_infill_colour := clSilver;

  shapes_colour := clBlack;
  shapes_label_font.Color := shapes_colour;

  bgkeep_rail_colour := clGray;
  bgkeep_timber_colour := clGray;
  bgkeep_timberfill_colour := clSilver;

  bgkeep_mark_colour := clBlack;
  bgkeep_peg_colour := clBlue;

  bgkeep_platform_colour := clSilver;   // 0.93.a

  guide_colour := clBlack;
  joint_colour := clBlack;
  align_colour := clBlack;
  trans_colour := clBlack;

  //pad_form.mouse_font_label.Font.Color:=clBlack;       // mouse labels.
  pad_form.bgnd_keeps_font_label.Font.Color := clBlack;  // bgnd keeps.
  pad_form.pad_timber_font_label.Font.Color := clBlack;  // timber numbers.

  pad_form.sb_teal_aqua_menu_entry.Click;              // scalebar colours.

  keep_colours3;              // colours for the keep form.
end;
//__________________________________________________________________________________________

procedure pad_silver;

begin
  paper_colour := clSilver;
  grid_colour := clGray;
  ring_colour := clGreen;
  //ring_copy_colour:=clNavy;
  ring_copy_colour := $00FF0080;         // violet ring copies. // 0.98.a
  page_colour := clRed;
  pad_form.Font.Color := clNavy;
  preview_form.Font.Color := clBlack;

  selection_colour := clGreen;
  hover_colour := clYellow;

  rail_colour := clBlack;
  timber_colour := clMaroon;
  timber_infill_colour := clYellow;

  shapes_colour := clGreen;
  shapes_label_font.Color := shapes_colour;

  bgkeep_rail_colour := clBlue;
  bgkeep_timber_colour := clPurple;
  bgkeep_timberfill_colour := clWhite;

  bgkeep_mark_colour := clRed;
  bgkeep_peg_colour := clBlack;

  bgkeep_platform_colour := $0000A0FF;   // 0.93.a  orange

  align_colour := clRed;
  trans_colour := clFuchsia;
  guide_colour := clBlue;
  joint_colour := clRed;

  //pad_form.mouse_font_label.Font.Color:=clBlue;      // mouse labels.
  pad_form.bgnd_keeps_font_label.Font.Color := clBlue; // bgnd keeps.
  pad_form.pad_timber_font_label.Font.Color := clBlue; // timber numbers.

  pad_form.sb_black_white_menu_entry.Click;     // scalebar colours.
  info_form.Color := $00F1E3D7;  // 0.93.a for Windows 7 child borders

  keep_colours1;              // colours for the keep form.
end;
//________________________________________________________________________________________

procedure pad_bright;
// set pad colours for the grey paper scheme...
begin
  paper_colour := clGray;
  grid_colour := clNavy;
  ring_colour := clLime;
  ring_copy_colour := clFuchsia;
  page_colour := clSilver;
  pad_form.Font.Color := clSilver;
  preview_form.Font.Color := clBlack;

  selection_colour := clWhite;
  hover_colour := clYellow;

  rail_colour := clAqua;
  timber_colour := clPurple;
  timber_infill_colour := clOlive;

  shapes_colour := clPurple;
  shapes_label_font.Color := shapes_colour;

  bgkeep_rail_colour := clLime;
  bgkeep_timber_colour := clBlue;
  bgkeep_timberfill_colour := clTeal;

  bgkeep_mark_colour := clMaroon;
  bgkeep_peg_colour := clYellow;

  bgkeep_platform_colour := $0000A0FF;   // 0.93.a  orange

  align_colour := clFuchsia;
  trans_colour := clLime;
  guide_colour := clYellow;
  joint_colour := clLime;

  //pad_form.mouse_font_label.Font.Color:=clLime;            // mouse labels.

  pad_form.bgnd_keeps_font_label.Font.Color := clWhite; // bgnd keeps.
  pad_form.pad_timber_font_label.Font.Color := clWhite; // timber numbers.

  pad_form.sb_grid_paper_menu_entry.Click;        // scalebar colours.
  info_form.Color := $00F1E3D7;  // 0.93.a for Windows 7 child borders

  keep_colours1;              // colours for the keep form.
end;
//_______________________________________________________________________________________

procedure no_rails_warn;

begin
  with pad_form do begin
    if (centre_lines_menu_entry.Checked = False) and (stock_rails_menu_entry.Checked = False) then
    begin
      alert(3, '    no  outer  rails  or  track  centre - lines',
        '||You have switched off the generation of all outer rail and track centre-line elements.'
        +
        '||It may not be possible to print this template, and it may not be drawn correctly in the storage box.'
        +
        '||To print a template without any rails or centre-lines, switch them back on in the GENERATOR > GENERATOR SETTINGS > menu options,' + ' and then select instead the|PRINT > PRINTED ELEMENT OPTIONS > OMIT RAILS menu item.',
        '', '', '', '', '', 'O K', 0);
    end;
  end;//with
end;
//________________________________________________________________________________________

procedure pad_caption(Text: string);

begin
  pad_form.Caption := '    trackpad  :   ' + Text;   // 0.91.b  was trackpad
end;
//________________________________________________________________________________________

procedure caption_add(Text: string);       // replace '...' in pad caption with '=' + text.

var
  find: integer;

begin
  find := Pos('..', pad_form.Caption);                              // find  '..
  if find = 0 then
    find := Pos(' |', pad_form.Caption);               // not there so find the ' |' we put there.
  if find = 0 then
    find := Pos(' =', pad_form.Caption);               // not there so find the ' =' we put there.
  if find < 20 then
    find := 50;                                      // default
  if (roam_mod = 1) or (roll_mod = 1) or (ringdia_mod = 1) then
    pad_form.Caption := Copy(pad_form.Caption, 1, find - 1) + ' |  ' + Text
  else
    pad_form.Caption := Copy(pad_form.Caption, 1, find - 1) + ' =  ' + Text;
end;
//______________________________________________________________________________________

procedure copy_keep(keep_info: Ttemplate_info);   // get control template data from a keep.

var
  exact_flag: boolean;
  custom_flag: boolean;
  n: integer;
  y_offset: double;

begin

  with keep_info.keep_dims.box_dims1 do begin

    exact_flag := gauge_exact;
    //nyi ignored in version 0  // If true this is an exact-scale template.
    custom_flag := gauge_custom;
    //nyi ignored in version 0  // If true this is (or was when saved) a custom gauge setting.

    with rail_info do begin

      flare_type := flared_ends_ri;  // 0=straight bent  1=straight machined.

      knuckle_code := knuckle_code_ri;
      // 214a  integer;   0=normal, -1=sharp, 1=use knuckle_radius_ri
      knuckle_radius := knuckle_radius_ri;   // 214a  extended;

      // rail switches...

      track_centre_lines_flag := track_centre_lines_sw;

      switch_drive_flag := switch_drive_sw;  // 0.82.a

      isolated_crossing := isolated_crossing_sw;    // 217a


      turnout_road_stock_rail_flag := turnout_road_stock_rail_sw;
      turnout_road_check_rail_flag := turnout_road_check_rail_sw;
      turnout_road_crossing_rail_flag := turnout_road_crossing_rail_sw;
      crossing_vee_flag := crossing_vee_sw;
      main_road_crossing_rail_flag := main_road_crossing_rail_sw;
      main_road_check_rail_flag := main_road_check_rail_sw;
      main_road_stock_rail_flag := main_road_stock_rail_sw;

      k_diagonal_side_check_rail_flag := k_diagonal_side_check_rail_sw;
      k_main_side_check_rail_flag := k_main_side_check_rail_sw;

    end;//with

    railedges(gauge_faces, outer_edges, centre_lines);   // use these switches.

    cpi := proto_info;            // get all the gauge data.

    ccd := check_diffs;           // get all the check-rail diffs 0.94.a

    retain_diffs_on_make := retain_diffs_on_make_flag;    // 0.94.a check rail diffs
    retain_diffs_on_mint := retain_diffs_on_mint_flag;    // 0.94.a check rail diffs

    // 0.94.a timber shoving mods..

    retain_shoves_on_make := retain_shoves_on_make_flag;
    retain_shoves_on_mint := retain_shoves_on_mint_flag;

    // 213a  for crossing entry straight

    retain_entry_straight_on_make := retain_entry_straight_on_make_flag;
    retain_entry_straight_on_mint := retain_entry_straight_on_mint_flag;

    rail_section := rail_type;               // rail head only or head+foot(BH/FB).
    vertical_rails := uninclined_rails;      // True = rails vertical.

    fb_kludge := fb_kludge_template_code;    // 0.94.a  FB rail-foot kludge

    label_modx := mod_text_x;
    // 211b not used for control template, but retained for use when stored again
    label_mody := mod_text_y;    // 211b ditto

    with transform_info do begin

      y_datum := datum_y;                   // y datum (green dot).

      xform := x1_shift;                    //  mm    shift info...
      yform := y1_shift;                    //  mm

      kform := k_shift;                     //  radians.
      normalize_kform;

      xshift := x2_shift;                   //  mm
      yshift := y2_shift;                   //  mm

      pegx := peg_pos.x;      //  mm  peg position.
      pegy := peg_pos.y;

      peg_code := peg_point_code;
      if peg_code = -2 then
        peg_code := -1;    // so peg on joints can re-initialise.

      peg_rail := peg_point_rail;

    end;//with

    with platform_trackbed_info do begin   // 0.93.a was  Tcheck_rail_mints=record

      adjacent_edges := adjacent_edges_keep;
      // False=adjacent tracks,  True=trackbed edges and platform edges.

      draw_ms_trackbed_edge := draw_ms_trackbed_edge_keep;
      draw_ts_trackbed_edge := draw_ts_trackbed_edge_keep;

      draw_ts_platform := draw_ts_platform_keep;
      draw_ts_platform_start_edge := draw_ts_platform_start_edge_keep;
      draw_ts_platform_end_edge := draw_ts_platform_end_edge_keep;
      draw_ts_platform_rear_edge := draw_ts_platform_rear_edge_keep;

      platform_ts_front_edge_ins := platform_ts_front_edge_ins_keep;
      // centre-line to platform front edge 57 inches 4ft-9in  215a            was 2ft-4.3/4in
      platform_ts_start_width_ins := platform_ts_start_width_ins_keep;
      platform_ts_end_width_ins := platform_ts_end_width_ins_keep;

      platform_ts_start_mm := platform_ts_start_mm_keep;
      platform_ts_length_mm := platform_ts_length_mm_keep;


      draw_ms_platform := draw_ms_platform_keep;
      draw_ms_platform_start_edge := draw_ms_platform_start_edge_keep;
      draw_ms_platform_end_edge := draw_ms_platform_end_edge_keep;
      draw_ms_platform_rear_edge := draw_ms_platform_rear_edge_keep;


      platform_ms_front_edge_ins := platform_ms_front_edge_ins_keep;
      // centre-line to platform front edge 57 inches  215a
      platform_ms_start_width_ins := platform_ms_start_width_ins_keep;
      platform_ms_end_width_ins := platform_ms_end_width_ins_keep;

      platform_ms_start_mm := platform_ms_start_mm_keep;
      platform_ms_length_mm := platform_ms_length_mm_keep;


      platform_ms_start_skew_mm := platform_ms_start_skew_mm_keep;    // 207a
      platform_ms_end_skew_mm := platform_ms_end_skew_mm_keep;        // 207a

      platform_ts_start_skew_mm := platform_ts_start_skew_mm_keep;    // 207a
      platform_ts_end_skew_mm := platform_ts_end_skew_mm_keep;        // 207a


      // new trackbed edge functions 215a ...   split MS and TS settings  -  using Single floats to fit available file space ...

      trackbed_ms_width_ins := trackbed_ms_width_ins_keep;     // Single
      trackbed_ts_width_ins := trackbed_ts_width_ins_keep;     // Single

      cess_ms_width_ins := cess_ms_width_ins_keep;             // Single
      cess_ts_width_ins := cess_ts_width_ins_keep;             // Single

      draw_ms_trackbed_cess_edge := draw_ms_trackbed_cess_edge_keep;   // boolean
      draw_ts_trackbed_cess_edge := draw_ts_trackbed_cess_edge_keep;   // boolean


      trackbed_ms_start_mm := trackbed_ms_start_mm_keep;
      // extended   need to be extendeds for def_req
      trackbed_ms_length_mm := trackbed_ms_length_mm_keep;

      trackbed_ts_start_mm := trackbed_ts_start_mm_keep;
      trackbed_ts_length_mm := trackbed_ts_length_mm_keep;

    end;//with platform_trackbed_info


    with align_info do begin

      spiral := trans_flag;      // True=transition, False=fixed radius curving.

      y_offset := rad_offset;

      nomrad := fixed_rad + y_offset;
      // fixed radius mm.     (include any offset from old files pre 0.64.a)...
      nomrad1 := trans_rad1 + y_offset;     // first transition radius mm.
      nomrad2 := trans_rad2 + y_offset;     // second transition radius mm.

      tst := trans_length;       // length of transition mm.
      os := trans_start;         // start of transition mm.

      slewing := slewing_flag;   // slewing flag.              // !!! replacing Tspares 10-7-99...
      slew_s := slew_start;      // slewing zone start mm.
      slew_l := slew_length;     // slewing zone length mm.
      slew := slew_amount;       // amount of slew mm.

      slew2_kmax := tanh_kmax;           {:double;}  {spare_int1:integer;}
      // stretch factor for mode 2 slews.
      {spare_int2:integer;}
      // !!! double used because only 8 bytes available in existing file format (2 integers).
      slew_mode := slew_type;             {:byte;}   {spare_flag3:boolean;}
      // !!! byte used because only 1 byte available in existing file format 1-11-99.

      cl_only := cl_only_flag;   // for bgnd centre-line only.

      dummy_template := dummy_template_flag;  // 212a

      cl_options_code := cl_options_code_int;                   // 206a
      cl_options_custom_offset := cl_options_custom_offset_ext; // 206a

      if reminder_flag = True       // 216a
      then begin

        with jotter_form.jotter_memo.Lines do begin

          Add('');
          Add('_______________________');
          Add('');
          Add(DateToStr(Date) + '   ' + TimeToStr(Time) + '   discarded reminder:');
          Add('');
          Add(reminder_str);

        end;//with
      end;

    end;//with

    with turnout_info1 do begin

      plain_track := plain_track_flag;               //  True = plain track only.
      hand_i := hand;                                //  hand of turnout.
      timbers_equalized := timbering_flag;           //  True = equalized timbering.

      exittb_i := exit_timbering;           //  exit timbering style.

      include_front_timbers := front_timbers_flag;      //  218a
      include_switch_timbers := switch_timbers_flag;    //  218a
      include_closure_timbers := closure_timbers_flag;  //  218a
      include_xing_timbers := xing_timbers_flag;        //  218a

      approach_rails_only := approach_rails_only_flag;  // 218a


      // compatibility mods 211a ...

      if turnout_road_is_adjustable = True then
        turnout_road_i := 2                    // adjustable turnout road exit
      else
      if turnout_road_is_minimum = True then
        turnout_road_i := 3            // minimum turnout road exit     217a

      else
        turnout_road_i := turnout_road_code;   // length of turnout exit road.


      turnoutx := turnout_length;           //  mm overall length.
      xorg := origin_to_toe;                //  mm approach length.
      incx := step_size;                    //  (use saved step-size on reloading - not default).

      turnoutx_max := xy_pts_c * incx;        // limit overall length.

    end;//with

    if turnoutx > turnoutx_max then
      turnoutx := turnoutx_max;
    if xorg > turnoutx then
      xorg := turnoutx;

  end;//with

  with keep_info.keep_dims.turnout_info2 do begin

    equalizing_fixed := equalizing_fixed_flag;     //  {spare_flag1:boolean;}   1-4-00
    no_timbering := no_timbering_flag;             //  {spare_flag2:boolean;}   7-9-00

    exp_chairing := chairing_flag;       // 214a

    square_on_angled := angled_on_flag;            // 29-7-01.
    bontimb := bonus_timber_count;                 // 0.76.a  23-10-01.

    auto_diamond := diamond_auto_code;                   // 0.77.a 27-8-02...
    timbinc := timber_length_inc;                        // 0.78.a 11-11-02.
    hd_proto_timbering := diamond_proto_timbering_flag;

    hd_switch_timbering := diamond_switch_timbering_flag;  // 213a

    half_diamond := semi_diamond_flag;
    fixed_diamond := diamond_fixed_flag;   // N.B. fixed diamond will be reset in calc_switch.

    turnout_road_endx := turnout_road_endx_infile;   // 209a

    gaunt := gaunt_flag;                       // 0.93.a ex 0.81
    gaunt_offset_in := gaunt_offset_inches;    // 0.93.a ex 0.81

    startx := start_draw_x;               //  {spare_float3:double;}  turnout startx  3-11-99

    with plain_track_info do begin

      if (pt_custom = True) or (list_index > 4) then begin
        pt_i := plain_track_form.plain_track_spacings_listbox.Items.Count - 1;
        // list index for current custom plain track.
        railen[pt_i] := rail_length;
        // custom rail length in inches.
        sleeper_count[pt_i] := sleepers_per_length;
        // number of sleepers per length.
        for n := 0 to psleep_c do
          psleep[pt_i, n] := sleeper_centres[n];   // custom spacings.

        plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i] :=
          '  ' + Trim(pt_spacing_name_str);   // put name in the list.
      end
      else
        pt_i := list_index;
      // copy data if custom, otherwise use index into existing list.


      udpegx := user_pegx;    // user-defined peg data (here to use former spare floats in file)
      udpegy := user_pegy;
      udpegangle := user_pegk;
      udpeg_valid := user_peg_data_valid;
      udpeg_rail := user_peg_rail;

      rjcode := rail_joints_code;   // 0=normal, 1=staggered, -1=none (cwr).

      tb_roll_percent := pt_tb_rolling_percent;

      gaunt_sleeper_mod_in := gaunt_sleeper_mod_inches;   // 0.93.a ex 0.81

      //spares:Tspares;

    end;//with plain_track_info

    // switch stuff...

    if set_csi_from_switch_info(switch_info) = False  // set current switch from supplied info.
    then begin
      if set_csi_data(2, 2) = False     // set REA B default if copied data invalid.
      then
        run_error(82);         // ?????? no B switch in list?
    end;

    // crossing stuff...

    with crossing_info do begin
      case pattern of
        -1: begin
          xing_type_i := -1;
          retpar_i := 0;
        end;  // generic crossing.
        0: begin
          xing_type_i := 0;
          retpar_i := 0;
        end;  // straight crossing...
        1: begin
          xing_type_i := 1;
          retpar_i := 0;
        end;  // curviform V-crossing...
        2: begin
          xing_type_i := 0;
          retpar_i := 1;
        end;  // parallel crossing...
        else begin
          xing_type_i := 0;
          retpar_i := 0;
        end;  // safety ! (default straight crossing)...
      end;//case

      if (xing_type_i <> 0) and (peg_code = 108) then
        peg_code := 0;   // added 205e  not a regular crossing   108=CESP

      entry_straight_code := sl_mode;       // 0=auto_fit, 1=use fixed_sl, -1=short
      xing_ret_i := retcent_mode;
      // 0=return centres as adjacent track, 1=use custom centres.
      k3n := k3n_unit_angle;    // k3n angle in units.
      hdkn := hdkn_unit_angle;   // K-crossing angle in units. // 0.93.a
      fixed_sl := fixed_st;          // length of knuckle straight. mm.

      hd_timbers := hd_timbers_code;     // extending of timbers for slip road.
      hd_vcheck_rails := hd_vchecks_code;
      // shortening code for half-diamond v-crossing check rails.

      kck1_long := k_check_length_1;  // length of size 1 k-crossing check rail (inches).
      kck2_long := k_check_length_2;  // length of size 2 k-crossing check rail (inches).

      k_flare_len := k_check_flare;     // length of flare on k-crossing check rails. inches F-S

      curviform_timbering := curviform_timbering_keep;   // 215a

      // 0.75.a  9-10-01...

      bn_wide := blunt_nose_width;      // full-size inches.
      bn_to_a := blunt_nose_to_timb;    // full-size inches - to A timber centre.

      veetimb_sp := vee_timber_spacing;
      // full-size inches - timber spacing for vee point rail part of crossing (on from "A").
      wingtimb_sp := wing_timber_spacing;
      // full-size inches - timber spacing for wing rail front part of crossing (up to "A").

      mvj_sp := vee_joint_half_spacing;
      // full-size inches - rail overlap at vee point rail joint.
      wingj_sp := wing_joint_spacing;
      // full-size inches - timber spacing at wing rail joint.


      // number of timbers spanned by vee rail incl. "A" timber...

      vee_spco1 := vee_joint_space_co1;
      vee_spco2 := vee_joint_space_co2;
      vee_spco3 := vee_joint_space_co3;
      vee_spco4 := vee_joint_space_co4;
      vee_spco5 := vee_joint_space_co5;
      vee_spco6 := vee_joint_space_co6;

      // number of timbers spanned by wing rail front excl. "A" timber...

      wing_spco1 := wing_joint_space_co1;
      wing_spco2 := wing_joint_space_co2;
      wing_spco3 := wing_joint_space_co3;
      wing_spco4 := wing_joint_space_co4;
      wing_spco5 := wing_joint_space_co5;
      wing_spco6 := wing_joint_space_co6;

      // 0.95.a  K-crossing wing rails ...

      k_custom_wing_long := k_custom_wing_long_keep;
      // 0.95.a inches full-size k-crossing wing rails
      k_custom_point_long := k_custom_point_long_keep;
      // 0.95.a inches full-size k-crossing point rails   NYI

      use_k_custom_wing_rails := use_k_custom_wing_rails_keep;    // 0.95.a
      use_k_custom_point_rails := use_k_custom_point_rails_keep;  // 0.95.a  NYI

      main_road_endx := main_road_endx_infile;   // 217a
      main_road_i := main_road_code;             // 217a

      tandem_timb := tandem_timber_code;         // 218a

    end;//with crossing_info

    omit_swfj_marks := omit_switch_front_joints;  // 0.79.a  25-02-03
    omit_swrj_marks := omit_switch_rail_joints;
    omit_skj_marks := omit_stock_rail_joints;
    omit_wj_marks := omit_wing_rail_joints;
    omit_vj_marks := omit_vee_rail_joints;
    omit_kx_marks := omit_k_crossing_stock_rail_joints;

  end;//with turnout_info2

  copy_shove_list(False, keep_info.keep_shove_list, current_shove_list);
  // copy all the shoved timber data.

  // got all new data.

  //------------------------------

  with pad_form do begin

    if spiral = True then
      zone_normal_menu_entry.Checked := True;          // radio item - normal length adjust action.

    turnout_i := 1;      // length locked at turnoutx.

    set_plain_track(plain_track, False);

    snap_exit_to_return_curve_menu_entry.Enabled := (retpar_i = 1);

    with peg_indicator_panel do begin
      case peg_code of
        -2:
          Caption := 'J';
        -1:
          Caption := 'S';
        0:
          Caption := '0';
        1:
          Caption := '1';
        2, 22, 222:
          Caption := '2';
        3, 33:
          Caption := '3';
        4, 44:
          Caption := '4';
        6:
          Caption := '5';
        9:
          Caption := '7';
        11:
          Caption := '9';
        17:
          Caption := '8';
        18:
          Caption := '6';
        20:
          Caption := 'F';
        999:
          Caption := 'U';
        else
          Caption := 'N';
      end;//case
    end;//with

    set_xing_k_i;             // set selector list index to match current k3n.

    gauge_dims(False, False, False);
    // data from cg current gauge, not from the gauge list (ignore return).

    if (cl_only = False) and (gen_centre_lines_were_off = True) and
      (centre_lines_menu_entry.Checked = True) then begin
      centre_lines_menu_entry.Checked := False;
      // toggle centre-lines off (not needed for this one)...
      centre_lines := False;
      railedges(gauge_faces, outer_edges, centre_lines);
      gen_centre_lines_were_off := False;                  // clear the flag again.
    end;

    if (cl_only = True) and (centre_lines_menu_entry.Checked = False)  // toggles on click
    then begin
      centre_lines_menu_entry.Checked := True;     // make sure centre-lines are on.
      centre_lines := True;
      railedges(gauge_faces, outer_edges, centre_lines);
      gen_centre_lines_were_off := True;
      // so we can switch them off again on next call.
    end;

  end;//with form

  // 218b  update gauge list ...

  //gauge_i:=0; //init

  for n := 0 to gauge_form.gauge_listbox.Items.Count - 1 do begin

    if gauge[n].name_str_glist = cpi.name_str_pi then begin
      gauge_i := n;
      BREAK;
    end;
  end;//next

end;
//______________________________________________________________________________

function any_control_rails_omitted: boolean;       // 208a

var
  pt_all, turnout_all, hd_all: boolean;

begin
  Result := False;  // init

  pt_all := turnout_road_stock_rail_flag and main_road_stock_rail_flag;

  turnout_all := pt_all and turnout_road_check_rail_flag and turnout_road_crossing_rail_flag and
    crossing_vee_flag and main_road_check_rail_flag and main_road_crossing_rail_flag;

  hd_all := turnout_all and k_diagonal_side_check_rail_flag and k_main_side_check_rail_flag;

  if plain_track = True then
    Result := not pt_all
  else
  if half_diamond = True then
    Result := not hd_all
  else
    Result := not turnout_all;

end;
//______________________________________________________________________________

function create_id_number_str(idnum, hand: integer; startx, turnoutx, ipx, fpx: double;
  plain_track, half_diamond, any_omitted: boolean): string;    // 208a

var
  hand_str, prefix_str: string;

begin
  if plain_track = True then
    prefix_str := 'P'
  else begin
    if half_diamond = True then begin
      if turnoutx < fpx then
        prefix_str := 'C'      // custom partial template
      else
        prefix_str := 'D';     // full half-diamond
    end
    else begin
      if turnoutx < ipx then
        prefix_str := 'S'   // switch or catch points
      else
        prefix_str := 'T';  // full turnout
    end;

    if startx > ipx then
      prefix_str := 'C';    // blanking overide -- custom partial template
  end;

  if any_omitted = True then
    prefix_str := 'C';  // overide -- custom partial template

  if hand = 1 then
    hand_str := 'L'
  else
    hand_str := 'R';

  Result := prefix_str + hand_str + FormatFloat('000', idnum);
end;
//______________________________________________________________________________

procedure fill_kd(var keep_info: Ttemplate_info);
// copy control template data to the keep record.

var
  n: integer;
  rand_label_factor: double;

begin
  if keep_info.keep_shove_list = nil then
    keep_info.keep_shove_list := Tshoved_timber_list.Create;

  FillChar(keep_info.keep_dims, SizeOf(keep_info.keep_dims), 0);
  // all unused bytes to zero.  26-6-00

  with keep_info.keep_dims.box_dims1 do begin

    now_time := time_now_modified(Random($7FFFFFFF));
    // modify Delphi float time format to integer.
    // if conversion problem, returns random integer.

    keep_date := DateToStr(Date);
    keep_time := TimeToStr(Time);

    top_label := Copy(info_form.gauge_label.Caption, 1, 99);

    this_was_control_template := False;
    // 0.93.a  this is modified later in save_box() on the last one added there.

    reference_string := Copy(current_name_str, 1, 99);    // template name.


    id_number := highest_id_number + 1;    // 208a

    id_number_str := create_id_number_str(id_number, hand_i, startx, turnoutx,
      ipx, fpx, plain_track, half_diamond, any_control_rails_omitted);   // 208a

    total_length_of_timbering := total_template_timber_length;  // 0.96.a  for box totals info

    with rail_info do begin

      flared_ends_ri := flare_type;  // 0=straight bent  1=straight machined.

      knuckle_code_ri := knuckle_code;
      // 214a  integer;   0=normal, -1=sharp, 1=use knuckle_radius_ri
      knuckle_radius_ri := knuckle_radius;   // 214a  extended;


      track_centre_lines_sw := track_centre_lines_flag;

      switch_drive_sw := switch_drive_flag;  // 0.82.a

      isolated_crossing_sw := isolated_crossing;   // 217a


      turnout_road_stock_rail_sw := turnout_road_stock_rail_flag;
      turnout_road_check_rail_sw := turnout_road_check_rail_flag;
      turnout_road_crossing_rail_sw := turnout_road_crossing_rail_flag;
      crossing_vee_sw := crossing_vee_flag;
      main_road_crossing_rail_sw := main_road_crossing_rail_flag;
      main_road_check_rail_sw := main_road_check_rail_flag;
      main_road_stock_rail_sw := main_road_stock_rail_flag;

      k_diagonal_side_check_rail_sw := k_diagonal_side_check_rail_flag;
      k_main_side_check_rail_sw := k_main_side_check_rail_flag;

    end;//with

    auto_restore_on_startup := False;
    // defaults - changed on saving the backup (these two only read from the first keep in the file)..
    ask_restore_on_startup := True;

    bgnd_code_077 := 0;                  // can't go on background until in keeps box.
    pre077_bgnd_flag := False;           // in case reloaded in older version than 0.77.a

    templot_version := file_version;

    gauge_index := gauge_i;            // index into the gauge list. Only for showing the list,
    // the data comes from the file.

    if gauge_i = gauge_form.gauge_listbox.Items.Count - 1 then
      gauge_exact := True
    // nyi // If true this is an exact-scale template.
    else
      gauge_exact := False;

    if (gauge_i < gauge_form.gauge_listbox.Items.Count - 1) and
      (gauge_i > gauge_form.gauge_listbox.Items.Count - 6)  // 4 custom slots -2, -3, -4, -5.

    then
      gauge_custom := True   // nyi // If true this is (or was when saved) a custom gauge setting.
    else
      gauge_custom := False;

    proto_info := cpi;              // all the current gauge-size dimensions.

    check_diffs := ccd;             // all the check-rail diffs. 0.94.a

    retain_diffs_on_make_flag := retain_diffs_on_make;    // 0.94.a check rail diffs
    retain_diffs_on_mint_flag := retain_diffs_on_mint;    // 0.94.a check rail diffs

    // 0.94.a timber shoving mods..

    retain_shoves_on_make_flag := retain_shoves_on_make;
    retain_shoves_on_mint_flag := retain_shoves_on_mint;

    // 213a  for crossing entry straight

    retain_entry_straight_on_make_flag := retain_entry_straight_on_make;
    retain_entry_straight_on_mint_flag := retain_entry_straight_on_mint;


    box_save_done := False;
    // default, changed on saving backup, read only from first keep on restore previous contents. 23-6-00 v:0.62.a //spare_flag1:boolean;

    // name label position modifiers..

    // 211b mods...

    if (control_room_form.previous_labels_menu_entry.Checked = True)   // 211b option
      or ((GetKeyState(VK_CONTROL) and -2) <> 0)                       // or CTRL-Key down
    then begin
      mod_text_x := label_modx;    // 211b put label back where it was
      mod_text_y := label_mody;
    end
    else begin
      // 0.82.a randomise label position (if currently on default)...

      if control_room_form.fixed_labels_menu_entry.Checked = True then begin
        mod_text_x := 0;
        mod_text_y := 0;
      end
      else begin
        if control_room_form.very_random_labels_menu_entry.Checked = True then
          rand_label_factor := 3.0
        else
          rand_label_factor := 1.0;

        mod_text_x := ((Random * 30) - 15) * scale * rand_label_factor;
        // 0.82.a up to 15ft either way of randomising. arbitrary.
        mod_text_y := ((Random * 12) - 4) * scale * rand_label_factor;
        // 0.82.a add -4ft to +8ft of randomising. arbitrary.
      end;
    end;

    with transform_info do begin

      datum_y := y_datum;                   // y datum (green dot).

      x_go_limit := minfp;                  // nyi // print cropping limits (paper inches)...
      x_stop_limit := minfp;                // nyi


      transforms_apply := True;             // !!! no longer used. False=ignore transform data.

      // transform data...

      x1_shift := xform;                    //  mm    (xform,yform always zero after a normalize,)
      y1_shift := yform;                    //  mm    (e.g. for keeps, etc. (but not roll-back).  )
      k_shift := kform;                     //  radians.
      x2_shift := xshift;                   //  mm
      y2_shift := yshift;                   //  mm

      peg_pos.x := pegx;                    //  mm  peg position.
      peg_pos.y := pegy;

      peg_point_code := peg_code;
      peg_point_rail := peg_rail;

      mirror_on_x := False;                 //  nyi // True= invert on x.
      mirror_on_y := False;                 //  nyi // True= invert on y. (swap hand).

      // also save the peg position in file as notch data..

      notch_info := get_peg_for_notch;
      //Tnotch = {spare_float1:double;}    11-4-00 version 0.53
      {spare_float2:double;}
      {spare_float3:double;}
    end;//with

    with platform_trackbed_info do begin   // 0.93.a was  Tcheck_rail_mints=record

      adjacent_edges_keep := adjacent_edges;
      // False=adjacent tracks,  True=trackbed edges and platform edges.

      draw_ms_trackbed_edge_keep := draw_ms_trackbed_edge;
      draw_ts_trackbed_edge_keep := draw_ts_trackbed_edge;

      draw_ts_platform_keep := draw_ts_platform;
      draw_ts_platform_start_edge_keep := draw_ts_platform_start_edge;
      draw_ts_platform_end_edge_keep := draw_ts_platform_end_edge;
      draw_ts_platform_rear_edge_keep := draw_ts_platform_rear_edge;

      platform_ts_front_edge_ins_keep := platform_ts_front_edge_ins;
      // centre-line to platform front edge 57 inches 215a
      platform_ts_start_width_ins_keep := platform_ts_start_width_ins;
      platform_ts_end_width_ins_keep := platform_ts_end_width_ins;

      platform_ts_start_mm_keep := platform_ts_start_mm;
      platform_ts_length_mm_keep := platform_ts_length_mm;


      draw_ms_platform_keep := draw_ms_platform;
      draw_ms_platform_start_edge_keep := draw_ms_platform_start_edge;
      draw_ms_platform_end_edge_keep := draw_ms_platform_end_edge;
      draw_ms_platform_rear_edge_keep := draw_ms_platform_rear_edge;


      platform_ms_front_edge_ins_keep := platform_ms_front_edge_ins;
      // centre-line to platform front edge 57 inches 215a
      platform_ms_start_width_ins_keep := platform_ms_start_width_ins;
      platform_ms_end_width_ins_keep := platform_ms_end_width_ins;

      platform_ms_start_mm_keep := platform_ms_start_mm;
      platform_ms_length_mm_keep := platform_ms_length_mm;


      platform_ms_start_skew_mm_keep := platform_ms_start_skew_mm;    // 207a
      platform_ms_end_skew_mm_keep := platform_ms_end_skew_mm;        // 207a

      platform_ts_start_skew_mm_keep := platform_ts_start_skew_mm;    // 207a
      platform_ts_end_skew_mm_keep := platform_ts_end_skew_mm;        // 207a

      // new trackbed edge functions 215a ...   split MS and TS settings  -  using Single floats to fit available file space ...

      trackbed_ms_width_ins_keep := trackbed_ms_width_ins;     // Single
      trackbed_ts_width_ins_keep := trackbed_ts_width_ins;     // Single

      cess_ms_width_ins_keep := cess_ms_width_ins;             // Single
      cess_ts_width_ins_keep := cess_ts_width_ins;             // Single

      draw_ms_trackbed_cess_edge_keep := draw_ms_trackbed_cess_edge;   // boolean
      draw_ts_trackbed_cess_edge_keep := draw_ts_trackbed_cess_edge;   // boolean


      trackbed_ms_start_mm_keep := trackbed_ms_start_mm;
      // extended   need to be extendeds for def_req
      trackbed_ms_length_mm_keep := trackbed_ms_length_mm;

      trackbed_ts_start_mm_keep := trackbed_ts_start_mm;
      trackbed_ts_length_mm_keep := trackbed_ts_length_mm;

    end;//with platform_trackbed_info


    with align_info do begin

      curving_flag := True;
      // no longer used 0.77.a - all templates curved (straight=max_rad).

      trans_flag := spiral;      // True=transition, False=fixed radius curving.

      fixed_rad := nomrad;       // fixed radius mm.
      trans_rad1 := nomrad1;     // first transition radius mm.
      trans_rad2 := nomrad2;     // second transition radius mm.
      trans_length := tst;       // length of transition mm.
      trans_start := os;         // start of transition mm.
      rad_offset := 0;{ycurv;}   // curving line offset mm.   // scrapped 26-7-00.

      slewing_flag := slewing;   // slewing flag.             // !!! replacing Tspares 10-7-99...
      slew_start := slew_s;      // slewing zone start mm.
      slew_length := slew_l;     // slewing zone length mm.
      slew_amount := slew;       // amount of slew mm.

      try
        tanh_kmax := slew2_kmax;     // ! double from extended..
        slew_type := slew_mode;      // ! byte from integer.
      except
        // in case of overflows...
        tanh_kmax := 2;
        slew_type := 1;
      end;//try

      cl_only_flag := cl_only;    // for bgnd centre-line only.

      dummy_template_flag := dummy_template;  // 212a

      cl_options_code_int := cl_options_code;                   // 206a
      cl_options_custom_offset_ext := cl_options_custom_offset; // 206a

      reminder_flag := False;          // 216a  defaults no reminder yet
      reminder_colour := clYellow;
      reminder_str := '';
    end;//with

    rail_type := rail_section;               // rail head only or head+foot(BH/FB).
    uninclined_rails := vertical_rails;      // True = rails vertical.

    fb_kludge_template_code := fb_kludge;    // 0.94.a  FB rail-foot kludge

    print_mapping_colour := cur_prmap_col;    // 0.76.a  27-10-01 //spare_inta:integer;
    pad_marker_colour := cur_padmark_col;     // 0.76.a  27-10-01 //spare_intb:integer;

    use_print_mapping_colour := False;  // 0.76.a  27-10-01 //spare_boola:boolean;
    use_pad_marker_colour := False;     // 0.76.a  27-10-01 //spare_boolb:boolean;

    disable_f7_snap := False;           // 0.82.a  14-10-06  default.


    with turnout_info1 do begin

      plain_track_flag := plain_track;            //  True = plain track only.
      hand := hand_i;                             //  hand of turnout.

      timbering_flag := timbers_equalized;        //  True = equalized timbering.

      exit_timbering := exittb_i;           //  exit timbering style.

      front_timbers_flag := include_front_timbers;      //  218a
      switch_timbers_flag := include_switch_timbers;    //  218a
      closure_timbers_flag := include_closure_timbers;  //  218a
      xing_timbers_flag := include_xing_timbers;        //  218a

      approach_rails_only_flag := approach_rails_only;  // 218a

      // compatibility mods 211a  217a ...

      if turnout_road_i = 2          // adjustable turnout road exit
      then begin
        turnout_road_code := 0;
        // so can be loaded in 208 and earlier ( =2 will crash)
        turnout_road_is_adjustable := True;
      end
      else
      if turnout_road_i = 3  // minimum turnout road exit   217a
      then begin
        turnout_road_code := 0;
        // so can be loaded in 208 and earlier ( =3 will crash)
        turnout_road_is_minimum := True;
      end

      else begin
        turnout_road_code := turnout_road_i;    //  length of turnout exit road.
        turnout_road_is_adjustable := False;
        turnout_road_is_minimum := False;       // 217a
      end;

      turnout_length := turnoutx;           //  mm overall length.
      origin_to_toe := xorg;                //  mm approach length.

      step_size := incx;                    //  (use saved step-size on reloading - not default).

    end;//with turnout_info1

  end;//with

  with keep_info.keep_dims.turnout_info2 do begin

    equalizing_fixed_flag := equalizing_fixed;  // {spare_flag1:boolean;} equalizing style 1-4-00
    no_timbering_flag := no_timbering;          // {spare_flag2:boolean;} 7-9-00

    chairing_flag := exp_chairing;       // 214a

    angled_on_flag := square_on_angled;         // 29-7-01.
    bonus_timber_count := bontimb;              // 0.76.a  23-10-01.

    diamond_auto_code := auto_diamond;                  // 0.77.a 27-8-02...
    timber_length_inc := timbinc;                       // 0.78.a 1-11-02.
    diamond_proto_timbering_flag := hd_proto_timbering;

    diamond_switch_timbering_flag := hd_switch_timbering;  // 213a

    semi_diamond_flag := half_diamond;
    diamond_fixed_flag := fixed_diamond;   // N.B. fixed diamond will be reset in calc_switch.

    turnout_road_endx_infile := turnout_road_endx;   // 209a

    if plain_track = True                       // 208c (max 6 chars) ...
    then
      template_type_str := '??pt'
    else
    if half_diamond = True then
      template_type_str := '??hd'
    else
      template_type_str := '??to';

    gaunt_flag := gaunt;                      // 0.93.a ex 081
    gaunt_offset_inches := gaunt_offset_in;   // 0.93.a ex 081

    start_draw_x := startx;
    //  {spare_float3:double;}  turnout startx  3-11-99.

    smallest_radius_stored := smallest_radius;
    // 208a needed for box data -- not loaded to the control

    dpx_stored := dpx;    // 208a needed for ID number creation -- not loaded to the control
    ipx_stored := ipx;    // 208a needed for ID number creation -- not loaded to the control
    fpx_stored := fpx;    // 208a needed for ID number creation -- not loaded to the control

    with plain_track_info do begin

      if pt_i > 4 then
        pt_custom := True       // list index for custom plain track.
      else
        pt_custom := False;

      list_index := pt_i;
      rail_length := railen[pt_i];
      // rail length in inches (only used for custom lengths).
      sleepers_per_length := sleeper_count[pt_i];
      // number of sleepers per length.
      for n := 0 to psleep_c do
        sleeper_centres[n] := psleep[pt_i, n];   // spacings (only used for custom spacings).

      pt_spacing_name_str := Copy(
        plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i], 1, 198);
      // get name from the list.

      user_pegx := udpegx;    // user-defined peg data (here to use former spare floats in file)
      user_pegy := udpegy;
      user_pegk := udpegangle;
      user_peg_data_valid := udpeg_valid;
      user_peg_rail := udpeg_rail;

      rail_joints_code := rjcode;   // 0=normal, 1=staggered, -1=none (cwr).

      pt_tb_rolling_percent := tb_roll_percent;

      gaunt_sleeper_mod_inches := gaunt_sleeper_mod_in;   // 0.93.a ex 0.81

    end;//with plain_track_info

    // switch stuff ..

    switch_info := csi;  // current switch.

    // crossing stuff...

    with crossing_info do begin

      if retpar_i = 1 then
        pattern := 2
      else
        pattern := xing_type_i;  // 0=straight, 1=curviform, 2=parallel, -1=generic.

      sl_mode := entry_straight_code;   // 0=auto_fit, 1=use fixed_sl, -1=short
      retcent_mode := xing_ret_i;
      // 0=return centres as adjacent track, 1=use custom centres.
      k3n_unit_angle := k3n;         // k3n angle in units.
      hdkn_unit_angle := hdkn;        // K-crossing angle in units. 0.93.a
      fixed_st := fixed_sl;    // length of knuckle straight. mm.

      hd_timbers_code := hd_timbers;       // extending of timbers for slip road.
      hd_vchecks_code := hd_vcheck_rails;
      // shortening code for half-diamond v-crossing check rails.

      k_check_length_1 := kck1_long;   // length of size 1 k-crossing check rail (inches).
      k_check_length_2 := kck2_long;   // length of size 2 k-crossing check rail (inches).

      k_check_flare := k_flare_len;  // length of flare on k-crossing check rails. inches F-S

      curviform_timbering_keep := curviform_timbering;   // 215a

      // 0.75.a  9-10-01...

      blunt_nose_width := bn_wide;         // full-size inches.
      blunt_nose_to_timb := bn_to_a;       // full-size inches - to A timber centre.

      vee_timber_spacing := veetimb_sp;
      // full-size inches - timber spacing for vee point rail part of crossing (on from "A").
      wing_timber_spacing := wingtimb_sp;
      // full-size inches - timber spacing for wing rail front part of crossing (up to "A").

      vee_joint_half_spacing := mvj_sp;
      // full-size inches - rail overlap at vee point rail joint.
      wing_joint_spacing := wingj_sp;      // full-size inches - timber spacing at wing rail joint.

      // number of timbers spanned by vee rail incl. "A" timber...

      vee_joint_space_co1 := vee_spco1;
      vee_joint_space_co2 := vee_spco2;
      vee_joint_space_co3 := vee_spco3;
      vee_joint_space_co4 := vee_spco4;
      vee_joint_space_co5 := vee_spco5;
      vee_joint_space_co6 := vee_spco6;

      // number of timbers spanned by wing rail front excl. "A" timber...

      wing_joint_space_co1 := wing_spco1;
      wing_joint_space_co2 := wing_spco2;
      wing_joint_space_co3 := wing_spco3;
      wing_joint_space_co4 := wing_spco4;
      wing_joint_space_co5 := wing_spco5;
      wing_joint_space_co6 := wing_spco6;

      // 0.95.a  K-crossing wing rails ...

      k_custom_wing_long_keep := k_custom_wing_long;
      // 0.95.a inches full-size k-crossing wing rails
      k_custom_point_long_keep := k_custom_point_long;
      // 0.95.a inches full-size k-crossing point rails   NYI

      use_k_custom_wing_rails_keep := use_k_custom_wing_rails;    // 0.95.a
      use_k_custom_point_rails_keep := use_k_custom_point_rails;  // 0.95.a  NYI

      main_road_endx_infile := main_road_endx;   // 217a
      main_road_code := main_road_i;             // 217a

      tandem_timber_code := tandem_timb;         // 218a

    end;//with crossing_info

    omit_switch_front_joints := omit_swfj_marks;  // 0.79.a  25-02-03
    omit_switch_rail_joints := omit_swrj_marks;
    omit_stock_rail_joints := omit_skj_marks;
    omit_wing_rail_joints := omit_wj_marks;
    omit_vee_rail_joints := omit_vj_marks;
    omit_k_crossing_stock_rail_joints := omit_kx_marks;

  end;//with turnout_info2

  copy_shove_list(False, current_shove_list, keep_info.keep_shove_list);
  // copy all the current shoved timber data to the keep.

end;
//_______________________________________________________________________________________

procedure pad_view_fit_bgnd(group_only: boolean);  // zoom to fit background templates.

var
  n: integer;
  max_long, max_wide: double;
  min_long, min_wide: double;
  wl_factor: double;
  margin_factor: double;

  reduced_screeny: double;   // 217a

begin
  cancel_adjusts(False);

  // mods 216c for increased size of top toolbar ...

  if ABS(fy) < minfp then
    EXIT;   // ??  div 0

  reduced_screeny := screeny - pad_form.top_toolbar_panel.Height / ABS(fy);  // 217a

  if ABS(reduced_screeny) < minfp then
    EXIT;    // ??  div 0

  wl_factor := screenx / reduced_screeny;


  if (group_only = False) or (any_selected = 0)      // include control template unless group only.
  then begin
    max_wide := y_datum * 100 + xy_max[1];
    //xy_most[1];   // init for control template in 1/100th mm...
    max_long := xy_max[0];//xy_most[0];

    min_wide := y_datum * 100 + xy_min[1];//:=0;
    min_long := xy_min[0];//:=0;
  end
  else begin                                 // group only
    max_wide := 0 - screenx_max * 100;        // init max neg.
    max_long := 0 - screenx_max * 100;

    min_wide := screenx_max * 100;          // init max pos.
    min_long := screenx_max * 100;
  end;


  if any_bgnd > 0      // any in list and on background?
  then begin
    for n := 0 to (keeps_list.Count - 1) do begin

      with keeps_list[n] do begin

        if bg_copied = False then
          CONTINUE;  // this one not a background template.

        if (group_only = True) and (group_selected = False) then
          CONTINUE;  // ignore if not in group.

        with bgnd_keep do begin

          if xlist_max > max_long then
            max_long := xlist_max;
          if ylist_max > max_wide then
            max_wide := ylist_max;

          if xlist_min < min_long then
            min_long := xlist_min;
          if ylist_min < min_wide then
            min_wide := ylist_min;

        end;//with bgnd_keep.
      end;//with template.
    end;//for-next n template.
  end;//if bgnd.

  min_long := min_long / 100;      // to mm.
  min_wide := min_wide / 100;

  max_long := (max_long) / 100;
  max_wide := (max_wide) / 100;

  //margin_factor:=1.15;         // arbitrary 15% extra for margins.

  margin_factor := 1.10;         // arbitrary 10% extra for margins.   216c

  screenx := (max_long - min_long) * margin_factor;

  if screenx < ((max_wide - min_wide) * margin_factor * wl_factor) then
    screenx := (max_wide - min_wide) * margin_factor * wl_factor;

  if screenx < screenx_min then
    screenx := screenx_min; // minimum for screen width (max zoom in).
  if screenx > screenx_max then
    screenx := screenx_max; // maximum zoom out.

  // centralize on pad..

  zoom_offsetx := min_long - (screenx - (max_long - min_long)) / 2;
  if wl_factor > minfp then
    zoom_offsety := min_wide - (screenx / wl_factor - (max_wide - min_wide)) / 2;

  pad_form.lock_scaling_menu_entry.Click; // lock pad zoom.

  show_and_redraw(False, False);    // in case current is hidden.
  // do immediate redraw (so that a reload appears behind the keeps box).
end;
//____________________________________________________________________________________

procedure explode_shrink(new_screenx: double; loop, wheel: boolean);
// mouse wheel mode added 0.97.d

var
  screen_factor, zoom_factor: double;
  mps: TPoint;
  border_width, mouse_left, mouse_top: integer;

begin

  if draw_mode <> 2 then
    pad_form.lock_scaling_menu_entry.Click;

  do_rollback := False;   // no need to put this in rollback register on redraw.

  screen_factor := screeny / screenx;

  if new_screenx > screenx_max then
    new_screenx := screenx_max;
  if new_screenx < screenx_min then
    new_screenx := screenx_min;

  if (wheel = True) and (wheel_zoom_code = 1)  // mouse wheel, zoom and keep mouse on location
  then begin

    zoom_factor := new_screenx / screenx;

    zoom_offsetx := mouse_now_x - (mouse_now_x - zoom_offsetx) * zoom_factor;
    zoom_offsety := mouse_now_y - (mouse_now_y - zoom_offsety) * zoom_factor;

    screenx := new_screenx;

    redraw(False);
    EXIT;
  end;


  if (wheel = True) and (wheel_zoom_code = 2)  // mouse wheel, jump to centre and zoom.
  then begin

    // first zoom normal settings...

    zoom_offsetx := zoom_offsetx + (screenx - new_screenx) / 2;
    zoom_offsety := zoom_offsety + (screenx - new_screenx) / 2 * screen_factor;

    screenx := new_screenx;

    if GetCursorPos(mps) = False then begin
      mps.X := 0;
      mps.Y := 0;
    end;  // get cursor X,Y

    // move cursor to centre of pad ...

    with pad_form do begin

      border_width := Round((Width - ClientWidth) / 2);

      mouse_left := Left + border_width + Round((ex + ClientWidth) / 2);

      mouse_top := Top + Height - border_width - ClientHeight + Round(by / 2);

    end;//with

    SetCursorPos(mouse_left, mouse_top);

    // move pad to match ...

    zoom_offsetx := zoom_offsetx - (mouse_left - mps.X) * ffx;
    zoom_offsety := zoom_offsety - (mouse_top - mps.Y) * ffy;

    redraw(False);
    EXIT;
  end;

  // zoom on pad centre ...

  zoom_offsetx := zoom_offsetx + (screenx - new_screenx) / 2;
  // normal zoom, keep screen centre stable.
  zoom_offsety := zoom_offsety + (screenx - new_screenx) / 2 * screen_factor;

  screenx := new_screenx;

  redraw(loop);     // draw direct if click/keypress so each one is calculated.   (True via onIdle for examine peg)
end;
//______________________________________________________________________________________

procedure shift_group_into_positive_quadrant(warn: boolean);

var
  i, n: integer;
  min_long, min_wide: double;

  xshapes, yshapes: double;

begin
  mouse_shift_sync_wanted := False;    // not mouse action here

  if any_selected = 0 then begin
    if alert_no_group = True    // alert him, and does he want all?
    then
      EXIT;
  end;

  min_wide := screenx_max * 100;          // init max pos.
  min_long := screenx_max * 100;

  for n := 0 to (keeps_list.Count - 1) do begin

    with keeps_list[n] do begin

      if bg_copied = False then
        CONTINUE;  // this one not a background template.

      if group_selected = False then
        CONTINUE;  // ignore if not in group.

      with bgnd_keep do begin

        if xlist_min < min_long then
          min_long := xlist_min;
        if ylist_min < min_wide then
          min_wide := ylist_min;

      end;//with bgnd_keep.
    end;//with template.
  end;//for-next n template.

  min_long := min_long / 100;      // to mm.
  min_wide := min_wide / 100;

  if (min_long >= 0) and (min_wide >= 0) then begin
    ShowMessage('All group templates are currently within the positive quadrant on the grid.');
    EXIT;
  end;

  if warn = True then begin
    i := alert(7, '    shift  group  into  positive  quadrant',
      '||You are about to shift all group templates as a block such that every one is within the positive quadrant on the grid.'
      + '||This is a one-time process which cannot be undone.' +
      '||You may wish to save a data file first, so that you can revert to the existing template locations if necessary.',
      '', '', '', 'save  group  templates  first', 'cancel  shift',
      'shift  group  without  saving', 0);

    case i of
      4:
        keep_form.save_group_menu_entry.Click;
      5:
        EXIT;
    end;//case
  end;

  if min_long < 0 then
    xshift_keeps := 0 - min_long + g     // +g arbitrary to clear axes
  else
    xshift_keeps := 0;

  if min_wide < 0 then
    yshift_keeps := 0 - min_wide + g
  else
    yshift_keeps := 0;

  xshapes := xshift_keeps;
  yshapes := yshift_keeps;

  shift_all_group;

  rebuild_group(False, False);

  redraw(True);

  if (bgnd_form.bgnd_shapes_listbox.Items.Count < 1) or
    (bgnd_form.allow_sync_checkbox.Checked = False) then
    EXIT;

  if alert(4, '    shift  background  shapes  in  sync ?',
    'The group templates have been shifted into the positive quadrant.' +
    '||Do you now want all your background shapes to be shifted by the same amount?',
    '', '', '', '', 'no  thanks', 'yes  please', 0) = 5 then
    EXIT;

  shift_all_shapes(xshapes, yshapes);

  shapes_saved := False;      // need a resave.
  shapes_current_state;

  do_rollback := False;
  redraw(True);
end;
//______________________________________________________________________________

procedure init_rotate(x, y: double; rad_centre: boolean);
// set up transform constants for rotates.
// rotation centre at x,y.
var
  pc, pf: Tpex;
  dummy1, dummy2: double;

begin
  if rad_centre = False then
    docurving(False, True, x, y, pc.x, pc.y, dummy1, dummy2)
  // curve untransformed rotation centre position in pc (rad and angle not needed).
  else begin
    pc.x := x;
    pc.y := y;
  end;                         // but don't curve the curving centre!

  dotransform(kform, xform, yform, pc, pf);              // transform it to pf.

  xform := pc.x;     // pc is the new rotation point.
  yform := pc.y;

  xshift := xshift - pc.x + pf.x;     // adjust shifts to maintain position.
  yshift := yshift - pc.y + pf.y;
end;
//___________________________________________________________________________________________

procedure rotate_turnout(k: double; draw: boolean);     // rotate turnout k radians around peg.

begin
  init_rotate(pegx, pegy, False);
  kform := kform + k;                  // positive k anti-clockwise.
  normalize_kform;
  if draw = True then
    redraw(True);
end;
//________________________________________________________________________________________

function alert_no_group: boolean;    // return False if any get selected.

const
  nosel_help_str: string = '      Selecting  Group  Templates' +
    '||Before a group of stored templates can be subject to shift, rotate, save, or other group operations, they must first be selected.' + '||To select all background templates as a group, click the GROUP > GROUP SELECT ALL menu item (or press CTRL+A).' + '||To add or remove individual templates to or from a group, click anywhere on each template and then click the GROUP SELECT (TOGGLE) menu item on the pop-up menu which appears for that template.' + '||Or to quickly select multiple background templates with the mouse, click the GROUP > GROUP SELECT > CLICK BACKGND TO GROUP menu item and then click on their name labels.' + '||A group of templates can also be selected by clicking the GROUP-SELECTION FENCE toolbutton at the top of the pad, and then drawing a rectangle around them.' + '||Group templates can also be selected or de-selected in the Storage Box, and the group can then also include unused stored templates. Click the ? HELP button on the Storage Box for more information.';

var
  i: integer;

begin
  Result := True;       // default init, no group.
  repeat

    i := alert(3, '        no  group',
      'There are no stored templates currently selected for group operations.',
      '', '', '', '?  help', 'cancel', 'group  select  all', 4);
    case i of
      4:
        alert_help(0, nosel_help_str, '');
      6: begin
        pad_form.select_all_keeps_menu_entry.Click;
        if any_selected <> 0 then
          Result := False;
      end;
    end;//case
  until i <> 4;
end;
//____________________________________________________________________________________________

procedure alert_no_bgnd;      // mod 0.93.a

begin
  alert(3, '    no  templates  currently  on  background',
    '||There are no stored templates currently on the background drawing on the trackpad.' +
    '||The template which you can see on the trackpad is the control template.' +
    '||Many functions in Templot0 apply to background templates only, for example setting a marker colour, exporting a DXF file, selecting a group of templates.' + '||And some control template functions require a background template to be present, for example make transition curve, extend template to meet.' + '||To place a copy of the current control template on the background, click the `0PROGRAM > STORE & BACKGROUND`1 menu item or press the `0INSERT`2 key.' + '||To make an unused stored template appear on the background, click the `0COPY TO BACKGROUND`1 button on the storage box.| ',
    '', '', '', '', '', 'continue', 0);
end;
//____________________________________________________________________________________________

procedure alert_no_unused;

begin
  alert(3, '    no  templates  currently  unused',
    'There are currently no unused stored templates.' +
    '||To store an unused copy of the control template, click the|`0PROGRAM > STORE AS UNUSED`1 menu item.'
    + '||To remove a stored template from the background, so making it an unused stored template, click the|`0WIPE FROM BACKGROUND`1 button in the storage box.',
    '', '', '', '', '', 'continue', 0);
end;
//____________________________________________________________________________________________

procedure alert_no_library;

begin
  alert(3, '    no  library  templates',
    'There are currently no library templates in your storage box.' +
    '||To store a library copy of the control template, click the|`0MAIN > STORE AS LIBRARY`1 menu item.'
    + '||To add library templates from a file, click the `0ADD LIBRARY...`1 button on the storage box.',
    '', '', '', '', '', 'continue', 0);
end;
//____________________________________________________________________________________________

function get_new_rad_org(rad_str: string; var orgx, orgy: double): boolean;
  // get new radial centres.

const
  help_xradshift_str: string = '     Shift radial centre to X dimension.' +
    '||Enter an X-dimension in millimetres for the new position of the radial centre on the trackpad (the centre location from which the curving line radius is drawn).' + '||X-dimensions are measured across the width of the screen, positive from left to right.' + '||Unless the exact location of the radial centre is important, shifting the control template is more usually done with the mouse action, select the|`0ACTION > MOUSE ACTIONS: GEOMETRY > SHIFT POSITION`1 menu item (or press `0F7`2).';

  help_yradshift_str: string = '     Shift radial centre to Y dimension.' +
    '||Enter an Y-dimension in millimetres for the new position of the radial centre on the trackpad (the centre location from which the curving line radius is drawn).' + '||Y-dimensions are measured vertically on the screen, the positive direction is upwards from the bottom.' + '||Unless the exact location of the radial centre is important, shifting the control template is more usually done with the mouse action, select the|`0ACTION > MOUSE ACTIONS: GEOMETRY > SHIFT POSITION`1 menu item (or press `0F7`2).';

var
  n: integer;
  od: Toutdim;

begin
  Result := False;     // default init.

  putdim(help_xradshift_str, 1, 'shift  ' + rad_str + 'radial  centre  to  X  ( from  left )',
    orgx, False, True, False, False);
  // negative ok, no preset, zero ok, don't terminate on zero.
  n := putdim(help_yradshift_str, 1, 'shift  ' + rad_str +
    'radial  centre  to  Y  ( from  bottom )', orgy, False, True, False, False);
  // negative ok, no preset, zero ok, don't terminate on zero.

  if n <> 1 then
    EXIT;
  if getdims('shift  ' + rad_str + 'radial  centre  to...', '', pad_form, n, od) = True then begin
    orgx := od[0];
    orgy := od[1];
    Result := True;
  end;
end;
//_______________________________________________________________________________________

procedure shift_radial_centre(to_notch: boolean);

var
  orgx, orgy: double;
  first_rad: boolean;
  i: integer;

begin
  if spiral = False then begin
    if ABS(nomrad) > max_rad_test then begin
      alert(6, '    no  radial  centre',
        '            Shift  radial  centre.' +
        'The current curving radius is so great that the template is effectively dead straight and there is no radial centre to be shifted.',
        '', '', '', '', 'cancel', '', 0);
      EXIT;
    end;

    if to_notch = True    // move centre to notch
    then begin
      orgx := notchx;
      orgy := notchy;
      xshift := xshift + (orgx - rad1_orgx);
      yshift := yshift + (orgy - rad1_orgy) * hand_i;

      //if transform=False then transform_on_and_redraw;    //  won't work otherwise - also does a redraw.
      redraw(True);
    end
    else begin                // move centre somewhere else...
      orgx := rad1_orgx;
      orgy := rad1_orgy;

      if get_new_rad_org('', orgx, orgy) = True   // get new radial centres.
      then begin
        xshift := xshift + (orgx - rad1_orgx);
        yshift := yshift + (orgy - rad1_orgy) * hand_i;

        //if transform=False then transform_on_and_redraw;    //  won't work otherwise - also does a redraw.
        redraw(True);
      end;
    end;
  end
  else begin
    if (ABS(nomrad1) <= max_rad_test) and (ABS(nomrad2) <= max_rad_test)
    // neither rad straight?
    then begin
      if to_notch = True then begin
        i :=
          alert(4, '    which  radial  centre ?', '      Shift  radial  centre  to  notch.' +
          '||The control template is on a transition curve. Which radial centre do you want to shift to the pegging notch?',
          '', '', 'shift  centre  of  1st  radius  to  notch',
          'shift  centre  of  2nd  radius  to  notch', 'cancel', '', 0);
      end
      else begin
        i :=
          alert(4, '    which  radial  centre ?', '            Shift  radial  centre.' +
          '||The control template is on a transition curve. For which radial centre do you want to set a new position?'
          + '||(It is not possible to set both centres directly. The other centre can be moved using the CTRL-F5 ORBIT mouse action,' + ' or by adjusting the transition start and length settings while the fixing peg is in the fixed part of the curve.)', '', '', 'shift  centre  of  1st  radius  to ...', 'shift  centre  of  2nd  radius  to ...', 'cancel', '', 0);
      end;
      case i of
        3:
          first_rad := True;
        5:
          EXIT;
        else
          first_rad := False;
      end;//case
    end
    else begin
      if ABS(nomrad1) > max_rad_test then
        first_rad := False  //easement from straight.
      else
        first_rad := True;  //easement to straight.
    end;

    if first_rad = True then begin
      if to_notch = True then begin
        orgx := notchx;
        orgy := notchy;
        xshift := xshift + (orgx - rad1_orgx);
        yshift := yshift + (orgy - rad1_orgy) * hand_i;

        //if transform=False then transform_on_and_redraw;    //  won't work otherwise - also does a redraw.
        redraw(True);
      end
      else begin
        orgx := rad1_orgx;
        orgy := rad1_orgy;

        if get_new_rad_org('1st  ', orgx, orgy) = True
        // get new radial centres.
        then begin
          xshift := xshift + (orgx - rad1_orgx);
          yshift := yshift + (orgy - rad1_orgy) * hand_i;

          //if transform=False then transform_on_and_redraw;    //  won't work otherwise - also does a redraw.
          redraw(True);
        end;
      end;
    end//rad1
    else begin
      if to_notch = True then begin
        orgx := notchx;
        orgy := notchy;
        xshift := xshift + (orgx - rad2_orgx);
        yshift := yshift + (orgy - rad2_orgy) * hand_i;

        //if transform=False then transform_on_and_redraw;    //  won't work otherwise - also does a redraw.
        redraw(True);
      end
      else begin
        orgx := rad2_orgx;
        orgy := rad2_orgy;

        if get_new_rad_org('2nd  ', orgx, orgy) = True
        // get new radial centres.
        then begin
          xshift := xshift + (orgx - rad2_orgx);
          yshift := yshift + (orgy - rad2_orgy) * hand_i;

          //if transform=False then transform_on_and_redraw;    //  won't work otherwise - also does a redraw.
          redraw(True);
        end;
      end;
    end;//rad2
  end;//transition
end;
//________________________________________________________________________________________

function get_peg_for_notch: Tnotch;

var
  temp, dummy1, dummy2: double;
  notch_data: Tnotch;

begin
  with Result do begin      // default inits...
    notch_x := 0;
    notch_y := 0;
    notch_k := 0;
  end;//with

  with notch_data do begin
    try
      normalize_transforms;
      docurving(True, True, pegx, pegy, notch_x, temp, dummy1, dummy2);
      // get notch data from current peg position.
      notch_y := temp * hand_i + y_datum;
      notch_k := arm_angle * hand_i;
    except
      EXIT;
    end;//try
  end;//with
  Result := notch_data;
end;
//____________________________________________________________________________________________

function get_current_notch: Tnotch;

begin
  with Result do begin
    notch_x := notchx;
    notch_y := notchy;
    notch_k := notch_angle;
  end;//with
end;
//________________________________________________________________________________________

procedure set_current_notch(notch_data: Tnotch);

begin
  with notch_data do begin
    notchx := notch_x;
    notchy := notch_y;
    notch_angle := notch_k;
  end;//with
end;
//________________________________________________________________________________________

procedure do_group_link_to_notch;

begin
  shift_rotate_group(notchx - old_notchx, notchy - old_notchy, 0 -
    (notch_angle - old_notch_angle), False);
  //  moving peg, maintain direction.  no egg-timer.
end;
//________________________________________________________________________________________

procedure new_notch(notch_data: Tnotch; link_group: boolean);    // set new notch position on pad.

begin

  old_notchx := notchx;
  old_notchy := notchy;
  old_notch_angle := notch_angle;

  set_current_notch(notch_data);

  cancel_adjusts(False);
  // notch is shown on the background - can't change it during foreground adjusts.

  Inc(notch_index);                             // to next rollback slot.
  if notch_index > notch_c then
    notch_index := 0;

  undo_notch[notch_index] := notch_data;          // save notch in this slot...

  pad_form.cycle_notch_menu_entry.Enabled := True;

  if (link_group = True) and (group_notch_linked = True) then
    do_group_link_to_notch;

  do_rollback := False;       // no need to put this change in rollback register on redraw.
  redraw(True);
end;
//___________________________________________________________________________________________

procedure shift_onto_notch(click, min_rot: boolean);

// click=True if he clicked the menu, so minimise rotation (visually closest fit).
// if min_rot=True, use minimum amount of rotation even if not clicked.

var
  padpegx, padpegy, dummy1, dummy2: double;
  angle_diff: double;
  new_padpegx, new_padpegy: double;

begin
  pad_form.notch_unlinked_from_current_menu_entry.Click;
  // radio item - cancel any moving the notch in mouse actions.

  normalize_transforms;
  docurving(True, True, pegx, pegy, padpegx, padpegy, dummy1, dummy2);
  // calc current peg position.

  xshift := xshift + (notchx - padpegx);
  yshift := yshift + (notchy - (padpegy * hand_i + y_datum)) * hand_i;
  // then shift turnout onto notch.

  angle_diff := notch_angle * hand_i - arm_angle;

  if (click = True) or (min_rot = True)
  // he's not likely to be wanting more than 90 degs of rotation...
  then begin
    while angle_diff < (0 - Pi / 2) do
      angle_diff := angle_diff + Pi;  // less than -90, add 180 degrees.
    while angle_diff > Pi / 2 do
      angle_diff := angle_diff - Pi;      // more than 90, subtract 180 degrees.
  end;

  rotate_turnout(angle_diff, True);
  // rotate turnout around peg to match angles and redraw.

  // job done, but we need to keep a record of what's happened in case of shift group.

  // if it was already on notch, rotate it instead (but not if creating a tandem 218a).


  if click = True then begin

    docurving(True, True, pegx, pegy, new_padpegx, new_padpegy, dummy1, dummy2);
    // calc new peg position.

    saved_pegging_shiftx := new_padpegx - padpegx;
    saved_pegging_shifty := (new_padpegy - padpegy) * hand_i;
    saved_pegging_rot := 0 - angle_diff * hand_i;

    if (ABS(saved_pegging_shiftx) < minfp) and (ABS(saved_pegging_shifty) < minfp) and
      (ABS(saved_pegging_rot) < minfp) and (creating_tandem = False)
    // 218a
    then
      pad_form.rotate_current_180_menu_entry.Click;   // didn't need to move it, so rotate instead.
  end;
end;
//____________________________________________________________________________________

procedure retain_on_make;     // 213a

var
  dummy: double;

begin

  cancel_platforms;  // always cancel existing platforms

  omit_wj_marks := False;     // always put back on (turned off in make_slip)    215a

  if making_a_diamond = False    // global flag    215a
  then begin
    hd_vcheck_rails := 0;   // normal
    hd_timbers := 0;        // normal
  end
  else
    making_a_diamond := False;   // for next make

  if pad_form.make_tools_cancel_blanking_menu_entry.Checked = True then
    startx := 0;    // cancel any blanking.

  if retain_shoves_on_make = False then
    clear_shovedata;  // clear any shoved timbers.
  if retain_diffs_on_make = False then
    clear_check_diffs; // 0.94.a clear any check rail diffs

  if (retain_entry_straight_on_make = False) and (entry_straight_code <> 0)
  // 213a 0=using auto-fit instead
  then begin

    if plain_track = True then
      entry_straight_code := 0     // changing to auto-fit has no effect on plain track geometry
    else begin

      // modify the new control template for the changed entry straight...

      kform_now := kform;
      arm_angle_now := arm_angle;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
      // first save current peg position on pad and curving angle.

      entry_straight_code := 0;
      // changed to auto-fit, so geometry will now be modified.

      gocalc(0, 0);           // recalc to get new pegx, pegy, arm_angle.

      peg_curve;
      //  adjust shifts and rotates for current peg position.
      gocalc(0, 0);           //  get new arm_angle (peg might be on turnout road).

      rotate_turnout(arm_angle_now - arm_angle, False);
      // re-align to previous angle,no draw.
    end;

    gocalc(0, 0);
  end;

end;
//______________________________________________________________________________

procedure make_double_track_calcs(side: integer);

var
  old_rad, rad_mod: double;

  dummy1, dummy2, dummy3, dummy4, dummy5: double;

  old_apartl: double;

  old_rad2_orgx, old_rad2_orgy: double;
  old_rad1_orgx, old_rad1_orgy: double;


  //////////////////////////////////////////////////////////////

  procedure calc_error;

  var
    slew_str: string;

  begin
    wait_form.Close;
    if Application.Terminated = False then
      Application.ProcessMessages;

    if slewing = True then
      slew_str :=
        ', or try repeating the process with slewing cancelled. Slewing can then be re-applied to the new template as required.'
    else
      slew_str := '.';

    alert(5, '    calculation  failed',
      'Sorry, automatic adjustment has failed.' +
      '||Please adjust the new template manually' + slew_str,
      '', '', '', '', '', 'continue', 0);

  end;
  //////////////////////////////////////////////////////////////

begin
  try
    // keep compiler happy..

    old_rad1_orgx := 0;
    old_rad1_orgy := 0;

    old_rad2_orgx := 0;
    old_rad2_orgy := 0;

    if (spiral = True) and (auto_spiral_adjust = True) then begin

      // first get the existing transition data (relative to TRANSITION datum).
      // (apartl ignores any slewing)

      if calc_transition(nomrad1, nomrad2, tst, dummy1, dummy2, dummy3, dummy4,
        old_apartl, dummy5) = False then begin
        calc_error;
        auto_spiral_adjust := False;
      end;

      old_rad2_orgx := rad2_orgx;       // 2nd rad centres on pad..
      old_rad2_orgy := rad2_orgy;

      old_rad1_orgx := rad1_orgx;       // 1st rad centres on pad..
      old_rad1_orgy := rad1_orgy;

    end;

    with pad_form do begin

      //if adjacent_lines_code=1 then adjacent_lines_code:=0;   // 0.82.d  cancel any adjacent tracks.

      do_rollback := False;
      adjacent_redraw;                         // update rail-edges.

      do_rollback := False;
      store_and_background(False, False);     // first keep it and copy to background.
      if keep_added = False then
        EXIT;         // he cancelled.

      retain_on_make;    // do blanking, shoves, diffs, crossing entry straight, cancel platforms  213a

      show_and_redraw(False, False);   // in case copy caused a current hide.
      // force redraw to remove adjacent track.

      rad_mod := 0;               // keep compiler happy.

      do_rollback := False;
      case side of
        -1: begin
          rad_mod := 0 - trmscent;
          peg_on_adjacent_ms_menu_entry.Click;
          // put the peg on the adjacent main-side track.
        end;
        1: begin
          rad_mod := trtscent;
          peg_on_adjacent_ts_menu_entry.Click;
          // put the peg on the adjacent turnout-side track.
        end;
        else
          run_error(199);
      end;//case

      if (spiral = True) and (auto_spiral_adjust = True)
      // !!! 14-7-00 put peg well behind transition start.
      // (os might be negative and peg must be in rad1 for calcs to work).
      then begin

        do_rollback := False;
        gocalc(0, 0);                     // first set pegy for adjacent.

        peg_code := -1;                    // now make peg free.
        case side of
          -1:
            pegx := os - 10 * trmscent;  // main side.  (10*spacing arbitrary).
          1:
            pegx := os - 10 * trtscent;  // turnout side.
          else
            run_error(198);
        end;//case
      end;

      do_rollback := False;
      gocalc(0, 0);                           // ensure peg calcs done,

      new_notch(get_peg_for_notch, False);    // so can put notch under.

      // now change to plain track...

      plain_track := True;
      set_plain_track(True, True);

      xorg := turnoutx;           // keep current length for starters.

      hand_i := 0 - hand_i;
      // swap hand (so turnout-side is to same double-track centre).
      if slewing = True then
        slew := 0 - slew;   // need to swap the hand of any slewing also.

      if (ABS(nomrad) < max_rad_test) and (spiral = False)
      // fixed curved template, so must adjust the curving rad...
      then begin
        old_rad := nomrad;
        nomrad := 0 - (nomrad - rad_mod);   // adjust for adjacent track (swapping hand).

        if ABS(old_rad) > minfp   // 0.79.a
        then begin
          xorg := xorg * ABS(nomrad / old_rad);
          // adjust length to maintain swing angle. 0.79.a
          turnoutx := xorg;
        end;
      end;

      if spiral = True     // transition template, adjust the rads...
      then begin
        nomrad1 := 0 - (nomrad1 - rad_mod);     // adjust for adjacent track (swapping hand)...
        nomrad2 := 0 - (nomrad2 - rad_mod);

        if auto_spiral_adjust = True then begin
          case do_auto_trans_length_adjust(old_apartl) of
            // set the new transition length.

            -1:
              auto_spiral_adjust := False;    // he cancelled.

            0: begin                         // calc error.
              auto_spiral_adjust := False;
              calc_error;
            end;

            //  1: ok
          end;//case
        end;
      end;

      do_rollback := False;
      turnout_i := 1;      // length locked at turnoutx.

      // so can draw approach track...

      length_free_popup_entry.Enabled := False;
      length_free_menu_entry.Enabled := False;

      do_rollback := False;

      if (spiral = True) and (auto_spiral_adjust = True) and (wait_cancel_clicked = False) then
        pegy := g / 2                                  //!!! 14-7-00 put peg back on centre-line)
      else
        reset_peg_menu_entry.Click;

      do_rollback := False;
      gocalc(0, 0);                   // ensure peg calcs done.

      do_rollback := False;
      shift_onto_notch(False, False);       // and finally put it on the notch.

      //!!! mods 14-7-00 ...

      if (spiral = True) and (auto_spiral_adjust = True) and (wait_cancel_clicked = False) then
      begin
        case do_auto_trans_start_adjust(old_rad1_orgx, old_rad1_orgy,
            old_rad2_orgx, old_rad2_orgy) of
          // set the new transition start.

          -1:
            auto_spiral_adjust := False;    // he cancelled.

          0: begin                         // calc error.
            auto_spiral_adjust := False;
            calc_error;
          end;

          //  1: ok
        end;//case

        reset_peg_menu_entry.Click;  // put peg back in sensible place.
        wait_form.Close;

      end;

      reset_notch_menu_entry.Click;     // put notch back on datum.

      clear_current_name;

      show_and_redraw(True, True);                // in case hidden.
    end;//with
  finally
    wait_form.Close;
  end;//try
end;
//______________________________________________________________________________________

procedure make_double_track(side: integer);
// change to plain track in place of the current adjacent track.
// side=1 is turnout side.
// side=-1 is main side.
const
  slew_adj_str: string = '      Make  Slewed  Double - Track' +
    '||The MAKE DOUBLE-TRACK functions create double-track by first storing the control template and making a copy of it on the background, and then creating a new plain track template alongside,' + ' adjusting the curving radius according to the current setting for the turnout-side or main-side adjacent track spacings.' + '||When the tracks are slewed, some additional adjustment is necessary.' + '||To adjust the new track created, do this:' + '||First using the MOVE SLEWING START (SHIFT+CTRL-F5) mouse action, move the slewing zone start marker on the newly created track until it aligns' + ' with the slewing zone start marker on the original track.' + '||Then using the ADJUST SLEWING LENGTH (SHIFT+CTRL-F6) mouse action, move the slewing zone end marker on the newly created track until it aligns' + ' with the slewing zone end marker on the original track.' + '||It is helpful to zoom in on these marks while making the adjustments, and to check the spacing between the tracks while doing so. On sharp curves or where there is significant slewing,' + ' the slewing zone end marks may need to be displaced slightly to maintain the proper clearance between the tracks.' + '||Use the SPACING-RING tool to check track spacing clearances.' + '||N.B. If the original template was being drawn with ADJACENT TRACKS switched on in the GENERATOR SETTINGS, these will be switched off to avoid duplication.';

  spiral_adj_str: string = '      Make  Double - Track  on  Transition  Curve' +
    '||The MAKE DOUBLE-TRACK functions create double-track by first storing the control template and making a copy of it on the background, and then creating a new plain track template alongside,' + ' adjusting the curving radius according to the current setting for the turnout-side or main-side adjacent track spacings.' + '||When the tracks are on a transition curve, additional adjustments are made to the transition start and length settings to ensure that the initial and final radii remain concentric with those of the previous template.' + '||The calculations for these adjustments may take some time to complete, during which a PLEASE WAIT message will be displayed.' + '||You can watch these calculations being performed by expanding the INFORMATION panel, and scrolling the INFO area to see the transition data.' + '||Occasionally these calculations may not be able to reach a conclusion, in which case you should click the CANCEL button on the PLEASE WAIT window (or press the ESC key), and then complete the adjustment manually.' + '||Or if preferred, you can perform the whole adjustment manually, for more information see below.' + '||Caution: It is not mathematically possible to have two perfectly "parallel" transition curves. This means that within the transition zones it may not be possible to maintain the current adjacent track spacing dimension.' + '||Before making double-track on a transition curve therefore, it may be advisable to increase the adjacent track spacing slightly above the minimum (GEOMETRY > ADJACENT TRACK CENTRES... menu item), and to check the spacing afterwards' + ' (UTILS > DUMMY VEHICLE • SPACING-RING menu item).' + '||These precautions are more important when working with a reverse S-curve transition. For easements to or from straight track and transitions where both the initial and final radii are curving' + ' in the same direction (both radii having the same sign), it will usually be found that the spacing discrepancy is small or insignificant.' + '||If the double-track templates also contain a SLEW, the slew settings should be adjusted manually if necessary before checking the spacings.' + '|------------------------' + '||To manually adjust the new track created, do this:' + '||First using the MOVE TRANSITION START (SHIFT+CTRL-F3) mouse action, move the transition start marker on the newly created track until it aligns' + ' with the transition start marker on the original track.' + '||Then using the ADJUST TRANSITION LENGTH (SHIFT+CTRL-F4) mouse action, move the transition end marker on the newly created track until it aligns' + ' with the transition end marker on the original track.' + '||It is helpful to zoom in on these marks while making the adjustments, and to check the rail alignments while doing so. On sharp curves the best rail alignment' + ' may require one or both of the transition marks to be displaced slightly from these positions.' + '||( A slight discrepancy in the curving centres may remain, because it is not mathematically possible to have two perfectly "parallel" transition curves. The alternative method' + ' of applying the transition maths to the double-track centre-line is not used because this would introduce unacceptable distortion when the tracks are widely spaced, and also disrupt' + ' the alignment of the original track.)' + '||The adjustments detailed above will produce satisfactory double-track on transition curves in the majority of situations found in practice.' + ' Use the SPACING-RING tool to check the track spacings for adequate clearance.' + '||If the double-track templates also contain a SLEW, the slew settings should be adjusted similarly if necessary before checking the spacings.' + '|------------------------' + '||N.B. If the original track or turnout was being drawn with ADJACENT TRACKS switched on in the GENERATOR SETTINGS, these will be switched off to avoid duplication.';

var
  i: integer;
  s_curve_str: string;

  sp, way_ft, way_ins: double;
  ft_str, ins_str, way_str, sp_str: string;

begin

  //if check_t_55_ok=False then EXIT;   // check he wants it if T-55.

  if check_control_template_is_valid('double - track') = False then
    EXIT;  // 0.93.a  zero length

  if no_spacings_confirm = False      // 215b
  then begin

    case side of
      -1: begin
        sp := cpi.trmscent_pi;   //   MS

        way_ft := ABS((sp / inscale - 62) / 12);

        ft_str := IntToStr(TRUNC(way_ft)) + 'ft';

        way_ins := FRAC(way_ft) * 12;

        if way_ins < minfp then
          ins_str := ''
        else
          ins_str := '-' + FormatFloat('0.#', way_ins) + 'in';

        way_str := '<SPAN STYLE="COLOR:BLUE;">' + ft_str + ins_str + ' way</SPAN>';

        sp_str := '||   prototype: <SPAN STYLE="COLOR:BLUE;">' +
          FormatFloat('0.##', sp / inscale) +
          ' inches</SPAN>      model: <SPAN STYLE="COLOR:BLUE;">' +
          FormatFloat('0.##', sp) + ' mm</SPAN>' +
          '||For standard-gauge tracks at your current scale, this spacing would make ' +
          way_str + ' between the rails.' +
          '||If this is not correct you can change it before continuing. Remember to allow sufficient running clearance on sharp curves.';


        i := alert(2, '    make  double-track  MS',
          '||You are about to make main-side (MS) double-track.' +
          '||The current setting for the main-side (MS) adjacent track centre spacing is:' +
          sp_str, 'continue  and  don''t  show  this  message  again  today    ',
          'widen  MS  spacing  by  18  inches  and  continue',
          'reduce  MS  spacing  by  18  inches  and  continue',
          'set  new  track  spacings  and  continue ...', 'cancel  double-track', 'continue', 0);
        case i of
          1:
            no_spacings_confirm := True;
          2:
            widen_centres_18in(2);
          3:
            reduce_centres_18in(2);
          4:
            pad_form.adjacent_centres_menu_entry.Click;
          5:
            EXIT;
        end;//case

      end;


      1: begin
        sp := cpi.trtscent_pi;   //   TS

        way_ft := ABS((sp / inscale - 62) / 12);

        ft_str := IntToStr(TRUNC(way_ft)) + 'ft';

        way_ins := FRAC(way_ft) * 12;

        if way_ins < minfp then
          ins_str := ''
        else
          ins_str := '-' + FormatFloat('0.#', way_ins) + 'in';

        way_str := '<SPAN STYLE="COLOR:BLUE;">' + ft_str + ins_str + ' way</SPAN>';

        sp_str := '||   prototype: <SPAN STYLE="COLOR:BLUE;">' +
          FormatFloat('0.##', sp / inscale) +
          ' inches</SPAN>      model: <SPAN STYLE="COLOR:BLUE;">' +
          FormatFloat('0.##', sp) + ' mm</SPAN>' +
          '||For standard-gauge tracks at your current scale, this spacing would make ' +
          way_str + ' between the rails.' +
          '||If this is not correct you can change it before continuing. Remember to allow sufficient running clearance on sharp curves.';

        i := alert(2, '    make  double-track  TS',
          '||You are about to make turnout-side (TS) double-track.' +
          '||The current setting for the turnout-side (TS) adjacent track centre spacing is:' +
          sp_str, 'continue  and  don''t  show  this  message  again  today    ',
          'widen  TS  spacing  by  18  inches  and  continue',
          'reduce  TS  spacing  by  18  inches  and  continue',
          'set  new  track  spacings  and  continue ...', 'cancel  double-track', 'continue', 0);
        case i of
          1:
            no_spacings_confirm := True;
          2:
            widen_centres_18in(1);
          3:
            reduce_centres_18in(1);
          4:
            pad_form.adjacent_centres_menu_entry.Click;
          5:
            EXIT;
        end;//case

      end;

    end;//case

  end;

  if (side = -1) and (g > (47 * inscale)) and (cpi.trmscent_pi < (134 * inscale)) then begin
    if alert(1, '   make  double-track  -  MS',
      'Your current setting for the MS (main-side) track spacing is less than the 11ft-2in centres (134 inches) minimum for UK standard-gauge railways.' + '||If you continue it is very likely that there will be insufficient running clearance between rolling stock on the two tracks.' + '||If the tracks are sharply curved you will need additional track spacing above the minimum to provide sufficient clearance.' + '||To change the setting, click the `0tools > adjacent track centres`1 menu item.', '', '', '', '', 'cancel', 'continue - make  MS  double-track  at  current  setting    ', 0) = 5 then
      EXIT;
  end;

  if (side = 1) and (g > (47 * inscale)) and (cpi.trtscent_pi < (134 * inscale)) then begin
    if alert(1, '   make  double-track  -  TS',
      'Your current setting for the TS (turnout-side) track spacing is less than the 11ft-2in centres (134 inches) minimum for UK standard-gauge railways.' + '||If you continue it is very likely that there will be insufficient running clearance between rolling stock on the two tracks.' + '||If the tracks are sharply curved you will need additional track spacing above the minimum to provide sufficient clearance.' + '||To change the setting, click the `0tools > adjacent track centres`1 menu item.', '', '', '', '', 'cancel', 'continue - make  TS  double-track  at  current  setting    ', 0) = 5 then
      EXIT;
  end;

  if slewing = True then begin
    repeat
      i := alert(3, '   make  double-track  -  slewed  track',
        'Your control template contains a slew.' +
        '||The new template created may need to have the slewing zone start and length settings adjusted to ensure a proper spacing from the original track.', '', '', '', 'more  information', 'cancel  make', 'continue  -  make  double-track', 4);
      case i of
        4:
          alert_help(0, slew_adj_str, '');
        5:
          EXIT;
      end;//case
    until i <> 4;
  end;

  if spiral = True then begin
    auto_spiral_adjust := True;    // default init.

    if (ABS(nomrad1) < max_rad_test) and (ABS(nomrad2) < max_rad_test) and
      (SGZ(nomrad1) <> SGZ(nomrad2)) then
      s_curve_str :=
        '||This is a reverse S-curve transition. It may be necessary to check the track spacing within the transition zone for adequate passing clearance.'
    else
      s_curve_str := '';

    repeat
      i := alert(4, '   make  double-track  -  transition  curve',
        'Your control template is on a transition curve.' +
        '||The new track created will need to have the transition start and length settings adjusted.'
        + '||You can let Templot0 do this automatically, or make the adjustments yourself manually.'
        + s_curve_str, '', '', 'more  information', 'make  double-track  -  manual  adjust',
        'cancel  make', 'make  double-track  -  automatic  adjust', 3);
      case i of
        3:
          alert_help(0, spiral_adj_str, '');
        4:
          auto_spiral_adjust := False;
        5:
          EXIT;
      end;//case
    until i <> 3;

    wait_cancel_clicked := False;
    wait_form.cancel_button.Show;
    wait_form.waiting_label.Caption := 'calculating ...';

    wait_form.waiting_label.Width :=
      wait_form.Canvas.TextWidth(wait_form.waiting_label.Caption);  // 205b bug fix for Wine

    pad_form.trans_calc_timer.Tag := side;
    // do the calcs while the wait message shows modal.
    pad_form.trans_calc_timer.Enabled := True;    // one-shot only.

    if auto_spiral_adjust = True then
      do_show_modal(wait_form);  // 212a   ShowModal

    if Application.Terminated = False then
      Application.ProcessMessages;

  end
  else
    make_double_track_calcs(side);  // not transition, no need to show wait/cancel message.

  rail_options_form.restore_all_button.Click;  // 211c

end;
//______________________________________________________________________________

procedure make_pt_geo_rad(int_ext: integer; click: boolean);

// create plain track replacing the turnout road.
// store the previous approach section up to the tangent point (if any) as a separate template.

// click always True 0.93.a

var
  geor, geox, geok: double;

begin
  if plain_track = True then
    EXIT;    // ? shouldn't get here, menu disabled for plain track.

  case int_ext of
    -1: begin                 // internal geometrical radius...
      geor := igeo_rad;
      geox := igpx;
      geok := igeo_swing;
      pad_form.peg_on_IGTP_menu_entry.Click;
    end;

    else begin               // external geometrical radius...
      geor := egeo_rad;
      geox := egpx;
      geok := egeo_swing;
      pad_form.peg_on_EGTP_menu_entry.Click;
    end;

  end;//case

  if geox < (0 - minfp) then
    EXIT;  // can't fit the new turnout road template.

  //if click=True then if check_t_55_ok=False then EXIT;   // check he wants it if T-55.

  if click = True then begin
    if check_control_template_is_valid('turnout  road') = False then
      EXIT;  // 0.93.a  zero length
  end
  else begin
    if turnoutx = 0 then
      EXIT;    // 0.93.a  zero length, no alert
  end;

  case int_ext of
    -1:
      pad_form.peg_on_IGTP_menu_entry.Click;

    else
      pad_form.peg_on_EGTP_menu_entry.Click;

  end;//case

  gocalc(0, 0);                                 // peg calcs.

  pad_form.notch_under_peg_menu_entry.Click;   // and put notch ready at the tangent point.

  pad_form.reset_peg_menu_entry.Click;         // peg on CTRL-0.
  do_rollback := False;
  gocalc(0, 0);                                 // peg calcs.

  plain_track := True;
  set_plain_track(True, True);       // cancels any blanking.

  retain_on_make;

  if geox > inscale     // minimum 1" scale length for stored template (arbitrary)..
  then begin
    xorg := geox;
    turnoutx := geox;                   // new length
    redraw(False);

    store_and_background(False, False);   // keep it and copy to background.
    if keep_added = False then begin
      show_and_redraw(True, False);
      EXIT;                                // he cancelled.
    end;
  end;

  // now change current to the geometrical rad...

  //pad_form.fixed_radius_template_menu_entry.Click;  // might have been straight.

  gocalc(0, 0);                                        // peg calcs.

  xorg := ABS(geor * geok);     // curve length.
  turnoutx := xorg;
  nomrad := geor;       // might be negative - we haven't changed the hand.

  gocalc(0, 0);        // peg calcs.

  shift_onto_notch(False, False);

  rail_options_form.restore_all_button.Click;  // 211c

  show_and_redraw(True, True);
end;
//______________________________________________________________________________

procedure make_separate_approach(click: boolean);

// click always True 0.93.a

var
  cur_tem: Ttemplate_info;

begin

  if (plain_track = True) and (click = True) then begin
    alert(6, '    make  separate  approach  track',
      'The control template is a plain track template.' +
      '||A plain track template has no approach track to be split off.' +
      '||To make a split in plain track, click the `0tools > make split > make split at peg`1 menu item.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  if (half_diamond = True) and (click = True) then begin
    alert(6, '    make  separate  approach  track',
      'The control template is a half-diamond template.' +
      '||A half-diamond template has no approach track to be split off.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  if (xorg < minfp) and (click = True) then begin
    alert(6, '    make  separate  approach  track',
      'This turnout has no approach track to be separated.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  if (xorg < (10 * scale)) and (click = True)            // 10ft scale arbitrary minimum
  then begin
    if alert(7, '  make  separate  approach  track  -  very  short',
      'The approach track to this turnout is very short.' +
      '||Are you sure you want it to be a separate template?', '', '', '', '',
      'no  -  cancel', 'yes  -  make  separate  approach  track', 0) = 5 then
      EXIT;
  end;


  if click = True then begin
    if check_control_template_is_valid('split') = False then
      EXIT;  // 0.93.a  zero length
  end
  else begin
    if turnoutx = 0 then
      EXIT;    // 0.93.a  zero length, no alert
  end;

  try
    cur_tem.keep_shove_list := Tshoved_timber_list.Create;
    fill_kd(cur_tem);                              // first save the current.

    crop_approach;       // then crop all approach.
    gocalc(0, 0);         // peg calcs.

    if (spiral = True) and (pad_form.make_tools_normalize_transitions_menu_entry.Checked =
      True) then begin
      normalize_transition;   // ignore result.
      gocalc(0, 0);            // peg calcs.
    end;

    if (slewing = True) and (slew_s > turnoutx) then begin
      pad_form.disable_slewing_menu_entry.Click;   // new template in unslewed section.
      gocalc(0, 0);                                 // peg calcs.
    end;

    store_and_background(False, False); // keep it and copy to background.
    if keep_added = False then begin
      copy_keep(cur_tem);                  // restore original.
      show_and_redraw(True, False);
      EXIT;                                // he cancelled.
    end;

    // now change previous current to plain track...

    copy_keep(cur_tem);      // get it again.

    retain_on_make;    // do blanking, shoves, diffs, crossing entry straight, cancel platforms  213a

    turnoutx := xorg;          // only the approach track wanted.

    pad_form.peg_on_joint_end_menu_entry.Click;     // put peg at CTRL-1 rail joint with turnout.

    plain_track := True;
    set_plain_track(True, True);

    if (spiral = True) and (pad_form.make_tools_normalize_transitions_menu_entry.Checked =
      True) then begin
      gocalc(0, 0);                 // peg calcs.
      normalize_transition;        // ignore result.
    end;

    if (slewing = True) and (slew_s > turnoutx) then begin
      gocalc(0, 0);                                 // peg calcs.
      pad_form.disable_slewing_menu_entry.Click;   // new template in unslewed section.
    end;

    clear_current_name;

    rail_options_form.restore_all_button.Click;  // 211c

  finally
    cur_tem.keep_shove_list.Free;
    show_and_redraw(True, True);                 // in case copy caused a current hide.
  end;//try
end;
//_______________________________________________________________________________________

function make_crossover(simple, allow_curviform, for_slip: boolean): boolean;

const
  slewed_cross_str: string = '      Crossover  in  Slewed  Track' +
    '||Your control template contains a slew.' +
    '||If a crossover on a constant radius cannot be accommodated it is usually better to use one or more transition curves instead of slewing. The slewing function is intended primarily for plain track.' + '||It is generally unwise to construct a crossover if any part of it will be within the slewing zone (unless the amount of slew is very small and/or the slewing zone is very long).' + '||If you do so, some additional adjustment will probably be necessary. To adjust the new turnout created, do this:' + '||First using the MOVE SLEWING START (SHIFT+CTRL-F5) mouse action, move the slewing zone start marker on the newly created turnout until it aligns' + ' with the slewing zone end marker on the original turnout.' + '||Then using the ADJUST SLEWING LENGTH (SHIFT+CTRL-F6) mouse action, move the slewing zone end marker on the newly created turnout until it aligns' + ' with the slewing zone start marker on the original turnout.' + '||It is helpful to zoom in on these marks while making the adjustments, and to check the spacing between the tracks while doing so. On sharp curves or where there is significant slewing,' + ' the rail alignments and clearances will need to be carefully checked and the slewing zone marks may need to be displaced slightly to maintain the proper clearance between the tracks.' + '||Use the SPACING-RING tool to check track spacing clearances.' + '||For more help information about slewing, select the GEOMETRY > SLEW (NUDGE) > SLEWING DATA... menu item.';

  curved_cross_str: string = '      Crossover  with  Curviform  V-Crossings' +
    '||In a curviform V-crossing, the turnout radius continues through and beyond the crossing. If a crossover is constructed using such crossings, there will be an unacceptable' + ' instant reverse curve at the mid-point, causing rough running. This is avoided if regular crossings are used; the curving in the main roads then applies unchanged' + ' along the full length of the section between the crossings.' + '||It is possible to manually form a crossover with curviform V-crossings. One reason to do this might be that you are copying existing set-track components, rather than following' + ' correct prototype practice. To form a crossover manually, do this:' + '||1. Ensure that the turnout-side adjacent track spacing dimension is correctly set to your current requirements (GEOMETRY > ADJACENT TRACK CENTRES... menu item). If the crossover' + ' will be on a transition curve it is helpful to have the adjacent track drawn in (GENERATOR > GENERATOR SETTINGS > ADJACENT TRACK (TURNOUT-SIDE) menu item ticked).' + '||2. Shorten the turnout (F4 mouse action) to just beyond the TXP crossover mid-point mark.' + '||3. Move the fixing peg onto the TXP point (CTRL-5).' + '||4. Store this turnout, and copy it to the background (INSERT key).' + '||5. Rotate the turnout 180 degrees (SHIFT-F8).' + '||6. If the original turnout was not straight, change the sign of the curving radius, and change the radius dimension to match the current adjacent track spacing.' + ' (And if the original turnout was on a transition curve, interchange the first and second radius dimensions.)' + '||7. If the crossover is on a constant curve, check by zooming in on the marks that the two radial centres are coincident.' + '||8. If the crossover is on a transition curve, align the transition length settings. Click "crossover on transition curve" below for more details.' + '||N.B.|Contrary to what might be expected at first sight, DO NOT swap the hand of the second turnout. The turnouts forming a crossover are always of the SAME hand, even when' + ' the crossover is on a curve.';

  spiral_cross_str: string = '      Crossover  on  Transition  Curve' +
    '||The MAKE ORDINARY CROSSOVER function creates a crossover by first storing the control template and making a copy of it on the background, and then creating a new control template turnout to form a crossover,' + ' adjusting the curving line radii according to your current setting for the turnout-side adjacent track spacing.' + '||When the crossover is on a transition curve, some subsequent adjustment to the transition start and length settings may be necessary.' + ' To aid this, the MAKE ORDINARY CROSSOVER function will if necessary extend the overall length of the newly-created control template.' + ' This change can be undone later using the F4 mouse action, or the DO > SNAP and DO > EXIT TRACK menu functions, to reduce the overall length.'

    {  +'||It will also be helpful when making the adjustments to have the turnout-side adjacent track rails showing (select the GENERATOR > GENERATOR SETTINGS > ADJACENT TRACKS (TURNOUT-SIDE) menu items),'
  +' so that you can check the alignment of the rails on the newly created turnout with the existing ones. De-select the adjacent track rails when you have completed the adjustment.'
} + '||To adjust the turnout created, do this:' +
    '||First using the MOVE TRANSITION START (SHIFT+CTRL-F3) mouse action, move the transition start marker on the newly created turnout until it aligns' + ' with the transition end marker on the original turnout.' + '||Then using the ADJUST TRANSITION LENGTH (SHIFT+CTRL-F4) mouse action, move the transition end marker on the newly created turnout until it aligns' + ' with the transition start marker on the original turnout.' + '||It is helpful to zoom in on these marks while making the adjustments, and to check the rail alignments while doing so. On sharp curves the best rail alignment with the adjacent track' + ' may require one or both of the transition marks to be displaced slightly from these positions.' + '||A slight discrepancy in the radial centres may remain, because it is not mathematically possible to have two perfectly "parallel" transition curves.' + '||The adjustments detailed above will produce satisfactory crossovers on transition curves in the majority of situations found in practice.' + ' Use the SPACING-RING tool to check the track spacings for adequate clearance.' + '||-----------------' + '|Maths notes:' + '||The TOOLS > MAKE DOUBLE-TRACK TS function uses slightly different maths, and can produce exactly concentric transition radii if the AUTO-ADJUST option is selected.' + ' If the crossover mid-point is not within the transition zone, an alternative method of making a crossover is to use this function first to create an adjacent track.' + ' The crossover is then created using the TEMPLATE > INSERT TURNOUT IN PLAIN TRACK menu item and the SNAKE THROUGH PEG (CTRL-F6) mouse action.' + '||If the crossover mid-point is within the transition zone, this method is not suitable.' + '||The alternative approach of applying the transition maths to the double-track centre-line is not used because this would introduce unacceptable distortion when the tracks are widely spaced,' + ' and also disrupt the alignment of the original turnout.';

var
  dummy: double;
  i: integer;
  temp_str: string;
  save_current: Ttemplate_info;

  sp, way_ft, way_ins: double;
  ft_str, ins_str, way_str, sp_str: string;

begin
  Result := False;
  if plain_track = True then begin
    alert(6, '    make  crossover  -  plain  track',
      'The control template is plain track. It is not possible to construct a crossover from plain track.'
      + '||You must first change to a turnout or half-diamond template, by selecting the `0TEMPLATE > INSERT TURNOUT IN PLAIN TRACK`1 or the `0TEMPLATE > INSERT HALF-DIAMOND IN PLAIN TRACK`1 menu items.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  if retpar_i = 1 then begin
    alert(6, '    make  crossover  -  parallel  V-crossing',
      'It is not possible to form a crossover when the V-crossing type is parallel.' +
      '||To change to a regular or generic type of V-crossing suitable for a crossover, select the'
      +
      '|TEMPLATE > V-CROSSING OPTIONS... menu item' +
      '|or copy a suitable turnout from your storage box or background drawing.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  if (xing_type_i = 1) and (allow_curviform = False)    // 209c mod
  then
    repeat
      i := alert(2, '    make  crossover  -  curviform  V-crossing',
        '|Your current V-crossing type is curviform. It is not sensible to construct an ordinary or slip crossover or a regular ladder using curviform V-crossings.' + '||It is possible to override this and form such a crossover manually - click `0more information`1 below.', '', '', '', 'more  information', 'cancel  crossover', 'change  to  regular  V-crossing  and  continue', 4);

      if i = 4 then
        if alert_help(0, curved_cross_str, 'crossover  on  transition  curve') = 1 then
          alert_help(0, spiral_cross_str, '');

      if i = 5 then
        EXIT;

      if i = 6 then
        pad_form.regular_crossing_menu_entry.Click;

    until i <> 4;

  if slewing = True then begin
    repeat
      i := alert(3, '    make  crossover  -  slewed  track',
        '||Your control template contains a slew.' +
        '||It is generally unwise to construct a crossover if any part of it will be within the slewing zone.'
        +
        '||The slewing function is intended primarily for plain track.', '',
        '', 'more  information', 'make  slewed  crossover', 'cancel  crossover',
        'cancel  slewing  -  make  normal  crossover', 3);
      case i of
        3:
          alert_help(0, slewed_cross_str, '');
        5:
          EXIT;
        6:
          pad_form.disable_slewing_menu_entry.Click;
      end;//case
    until i <> 3;
  end;

  if check_control_template_is_valid('crossover') = False then
    EXIT;  // 0.93.a  zero length

  if no_spacings_confirm = False      // 215b
  then begin

    sp := cpi.trtscent_pi;   //   TS

    way_ft := ABS((sp / inscale - 62) / 12);

    ft_str := IntToStr(TRUNC(way_ft)) + 'ft';

    way_ins := FRAC(way_ft) * 12;

    if way_ins < minfp then
      ins_str := ''
    else
      ins_str := '-' + FormatFloat('0.#', way_ins) + 'in';

    way_str := '<SPAN STYLE="COLOR:BLUE;">' + ft_str + ins_str + ' way</SPAN>';

    sp_str := '||   prototype: <SPAN STYLE="COLOR:BLUE;">' + FormatFloat('0.##', sp / inscale) +
      ' inches</SPAN>      model: <SPAN STYLE="COLOR:BLUE;">' + FormatFloat('0.##', sp) +
      ' mm</SPAN>' + '||For standard-gauge tracks at your current scale, this spacing would make '
      + way_str + ' between the rails.' +
      '||If this is not correct you can change it before continuing. Remember to allow sufficient running clearance on sharp curves.';


    i := alert(2, '    make  crossover', '||You are about to make a crossover.' +
      '||The current setting for the turnout-side (TS) adjacent track centre spacing is:' +
      sp_str, 'continue  and  don''t  show  this  message  again  today    ',
      'widen  TS  spacing  by  18  inches  and  continue',
      'reduce  TS  spacing  by  18  inches  and  continue',
      'set  new  track  spacings  and  continue ...', 'cancel  crossover', 'continue', 0);
    case i of
      1:
        no_spacings_confirm := True;
      2:
        widen_centres_18in(1);
      3:
        reduce_centres_18in(1);
      4:
        pad_form.adjacent_centres_menu_entry.Click;
      5:
        EXIT;
    end;//case

  end;

  if (g > (47 * inscale)) and (cpi.trtscent_pi < (134 * inscale)) then begin
    if alert(1, '   make  crossover',
      'Your current setting for the TS (turnout-side) track spacing is less than the 11ft-2in centres (134 inches) minimum for UK standard-gauge railways.' + '||If you continue it is very likely that there will be insufficient running clearance between rolling stock on the two tracks.' + '||If the tracks are sharply curved you will need additional track spacing above the minimum to provide sufficient clearance.' + '||To change the setting, click the `0tools > adjacent track centres`1 menu item.', '', '', '', '', 'cancel', 'continue - make  crossover  at  current  setting    ', 0) = 5 then
      EXIT;
  end;

  save_current.keep_shove_list := Tshoved_timber_list.Create;

  try
    fill_kd(save_current);                              // in case he wants to cancel.

    //if adjacent_lines_code=1 then adjacent_lines_code:=0;   // 0.82.d  cancel any adjacent tracks.

    do_rollback := False;
    adjacent_redraw;                         // update rail-edges.

    do_rollback := False;

    pad_form.peg_on_txp_menu_entry.Click;                // put the peg on the mid-point.

    turnout_road_i := -1;              // shorten turnout road to suit.

    if turnoutx < (txpx + 2.5 * scale)     // lengthen existing if nec. (2ft6ins arbitrary)
    then begin
      turnoutx := txpx + 2 * scale;                                   // 2ft arbitrary.
      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;
    end;

    turnout_i := 1;     // length locked at turnoutx.

    do_rollback := False;
    store_and_background(False, False);       // keep it (does a recalc) and copy to background.

    if keep_added = False          // he cancelled because still on T-55, or no memory for it.
    then begin
      copy_keep(save_current);    // retrieve previous control template.
      // (this is OK even if gauge change on T-55, because
      //  gauge form is not showing Modal, we come back here first.)
      redraw_pad(True, False);
      EXIT;
    end;

    retain_on_make;    // do blanking, shoves, diffs, crossing entry straight, cancel platforms  213a

    show_and_redraw(True, False);   // in case copy caused a current hide.

    do_rollback := False;
    pad_form.rotate_current_180_menu_entry.Click;      // rotate it.

    if spiral = True then begin

      if turnoutx < (txpx * 2 - xorg) then
        turnoutx := txpx * 2 - xorg;     // and some extra length...
      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;

      gocalc(0, 0);      // need to do new curving calcs, but no need to show results.

      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
      // save current peg data for peg_curve calcs.

      // change sign of centre-line 1st radius.
      nomrad1 := 0 - (nomrad1 - trtscent);    // and adjust for adjacent track.

      // change sign of centre-line 2nd radius.
      nomrad2 := 0 - (nomrad2 - trtscent);    // and adjust for adjacent track.

      dummy := nomrad1;         // swap the 2 radii as we are facing the other way.
      nomrad1 := nomrad2;
      nomrad2 := dummy;

      os := pegx * 2 - (os + tst);
      // approximate adjust transition start to match previous transition end.

      peg_curve;                     // do curving calcs for the current peg position.
    end
    else begin                       // fixed curve or straight...

      turnoutx := txpx + 2.5 * scale;
      // reduce to 2ft6ins arbitrary.
      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;

      gocalc(0, 0);      // need to do new curving calcs, but no need to show results.

      if (ABS(nomrad) < max_rad_test)    // curved turnout, so must adjust the curving rad...
      then begin
        kform_now := kform;
        docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
        // save current peg data for peg_curve calcs.

        // change sign of centre-line radius.
        nomrad := 0 - (nomrad - trtscent);  // and adjust for adjacent track.

        peg_curve;
        // do curving calcs for the current peg position.
      end;
    end;

    clear_current_name;

    if half_diamond = True then begin
      convert_to_turnout;
      gocalc(0, 0);
      pad_form.peg_on_txp_menu_entry.Click;      // restore Ctrl-5.
    end
    else
      crop_approach;

    redraw_pad(False, True);                    // needed for rollback.

    pad_form.pad_on_peg_menu_entry.Click;      // centralize pad on it.

    show_and_redraw(True, False);       // rollback already done.

    if (spiral = True) and (simple = True) and (for_slip = False)     // 215a
    then begin

      repeat
        i := alert(3, '    crossover  on  transition  curve',
          '||The crossover just created is on a transition curve.' +
          '||The newly created template may need to have the transition start and length settings adjusted to achieve the optimum alignment with the adjacent track.', '', '', '', 'more  information'{,temp_str}, 'cancel  crossover', 'O K', 4);
        case i of
          4:
            alert_help(0, spiral_cross_str, '');

          5: begin
            if keeps_list.Count > 0 then begin
              list_position := keeps_list.Count - 1;
              // make last one in current in the keeps box.
              delete_keep(False, False);
              // then delete the current keep.
            end;
            copy_keep(save_current);   // retrieve previous control template.
            redraw(True);
          end;
        end;//case
      until i <> 4;
    end;

    Result := True;

  finally
    save_current.keep_shove_list.Free;
  end;//try
end;
//_____________________________________________________________________________________

function make_branch_crossover: boolean;     // 209c

var
  save_timbering: boolean;
  i: integer;

begin
  Result := False;  // init   not used

  save_timbering := pad_form.square_on_menu_entry.Checked;

  if save_timbering = True then begin
    i := alert(3, '    make  branch  crossover    -    timbering  style',
      'The timbering style is currently set to square-on timbering.' +
      '||For a branch crossover the equalized-incremental style is usually more appropriate.' +
      '||Do you want Templot0 to change it?' +
      '||If you answer yes, you may want to change it back later to the square-on style for subsequent templates.||The settings are in the `0real > timbering >`1 menu options.', '', '', '', 'no  thanks', 'cancel  branch  crossover', 'yes  please', 0);

    case i of

      4:
        save_timbering := False;

      5:
        EXIT;

    end;//case
  end;

  if save_timbering = True then begin
    // change to equalized timbering for a junction crossover...

    pad_form.equalized_incremental_menu_entry.Click;
    // not needed pad_form.timbers_centralized_menu_entry.Click;
  end;

  if make_crossover(False, True, False) = False     // not simple, allow curviform
  then begin
    if save_timbering = True   // restore his square-on
    then begin
      pad_form.square_on_menu_entry.Click;
      // not needed pad_form.timbers_in_line_menu_entry.Click;
    end;
    EXIT;
  end;

  pad_form.notch_unlinked_from_current_menu_entry.Click;
  // radio item - cancel any moving the notch in mouse actions.
  new_notch(get_peg_for_notch, False);

  pad_form.peg_on_mxp_menu_entry.Click;  // Ctrl-7

  gocalc(0, 0);

  invert_handing;

  gocalc(0, 0);

  shift_onto_notch(False, True);   // not clicked, minimum rotation

  turnoutx := pegx;
  turnout_i := 1;      // length locked at MXP

  if xorg > turnoutx then
    xorg := turnoutx;

  gocalc(0, 0);

  pad_form.reset_notch_menu_entry.Click;    // does the redraw if needed

  Result := True;  // not used
end;
//______________________________________________________________________________

function make_mirror_on_peg: boolean;

begin
  Result := False;     // default init.

  if check_control_template_is_valid('mirror') = False then
    EXIT;  // 0.93.a  zero length

  do_rollback := False;
  store_and_background(False, False);      // keep it (does a recalc) and copy to background.
  if keep_added = False then
    EXIT;          // he cancelled.

  retain_on_make;    // do blanking, shoves, diffs, crossing entry straight, cancel platforms  213a

  do_rollback := False;
  pad_form.rotate_current_180_menu_entry.Click;      // rotate it.
  gocalc(0, 0);                                       // need a recalc so can swap hand.

  swap_hand;               // to opposite hand.
  clear_current_name;
  Result := True;
end;
//___________________________________________________________________________________________

function make_diamond_crossing: boolean;

const
  make_diamond_help_str: string =
    'php/101     `0make  irregular  diamond-crossing`9' +
    '||It is not possible to create a full diamond-crossing from this half-diamond template.' +
    '||The difference between the V-crossing angle and the K-crossing angle is too great.' +
    '||Try using the `0F9`2 and `0F10`2 mouse actions, to adjust the V-crossing and K-crossing angles respectively.';

var
  temp1: integer;
  temp2: double;
  cos_new_hdk: double;
  cos_new_k3: double;
  i: integer;

  new_k3, new_hdk: double;
  new_k3n, new_hdkn: double;

begin
  Result := False;     // default init.

  if check_control_template_is_valid('diamond - crossing') = False then
    EXIT;  // 0.93.a  zero length

  try

    if half_diamond = False      // force a half-diamond...
    then begin
      if plain_track = True then
        insert_half_diamond
      else
        convert_to_regular_half_diamond;
      gocalc(0, 0);
    end;

    pad_form.reset_peg_menu_entry.Click;
    gocalc(0, 0);

    cos_new_k3 := COS(k3);   // keep compiler happy ...
    cos_new_hdk := COS(hdk);
    new_k3 := k3;
    new_hdk := hdk;

    if tradius_is_straight = False    // check we can make a valid irregular diamond..
    then begin
      cos_new_hdk := (torgy - g) / (tradius - g);
      // irregular diamond has differing K-crossing angles.
      cos_new_k3 := cos_new_hdk - (th - h) / (g - tradius);
      // calc new V-crossing angle.
      if (ABS(cos_new_k3) > (1 - minfp)) or (ABS(cos_new_hdk) > (1 - minfp))
      // invalid crossing angles (COS out of range - rails do not intersect?).
      then begin
        repeat
          i := alert(6, 'php/101   impossible  diamond - crossing',
            'It is not possible to create a full diamond-crossing using the current settings.' +
            '||The rails would not intersect to create a new V-crossing.', '',
            '', '', '?  help', 'cancel', '', 4);
          if i = 4 then
            alert_help(0, make_diamond_help_str, '');
        until i <> 4;
        EXIT;
      end;

      if (xing_type_i = 0) and (irreg_crossings_msg_pref = False) then begin

        alert_box.preferences_checkbox.Checked := False;       //%%%%
        alert_box.preferences_checkbox.Visible := True;

        repeat
          i := alert(7, 'php/102   make  irregular  diamond - crossing',
            'Using the current settings, you are about to make an irregular-type diamond-crossing having regular-type V-crossings.' +
            '||The result will be that the diagonal road will not follow a single ruling curve through the V-crossings.'
            + '||This is normally correct only when a half-diamond template is forming part of a crossover with a turnout also having a regular or generic type of V-crossing,' + ' or the half-diamond is connected to a return curve.' + '||Otherwise it is generally better to use curviform V-crossings in an irregular diamond-crossing, so that the diagonal road follows a single curve through the full diamond.' + '||In special cases it is possible to mix different types of V-crossing in the same diamond-crossing, and/or to have a different diagonal radius in each half-diamond.' + ' Make such changes after creating the full diamond-crossing, so that the K-crossing angles in each half always match.' + '||(This diamond-crossing will be irregular-type because the current V-crossing and K-crossing angles are unequal.)', '', '', '', 'more  information  about  types  of  V-crossing', 'cancel', 'continue  with  regular  V-crossings', 4);

          if i = 4 then
            alert_help(0, v_xing_types_help_str, '');
        until i <> 4;

        irreg_crossings_msg_pref := alert_box.preferences_checkbox.Checked;    //%%%%
        alert_box.preferences_checkbox.Visible := False;

        if i = 5 then
          EXIT;
      end;

      if (xing_type_i = -1) and (irreg_crossings_msg_pref = False) then begin

        alert_box.preferences_checkbox.Checked := False;       //%%%%
        alert_box.preferences_checkbox.Visible := True;

        repeat
          i := alert(7, 'php/103   make  irregular  diamond - crossing',
            'Using the current settings, you are about to make an irregular-type diamond-crossing having generic-type type V-crossings.' + '||The result will be that the diagonal road will not follow a single ruling curve through the V-crossings.' + '||This is normally correct only when a half-diamond template is forming part of a crossover with a turnout also having a regular or generic type of V-crossing,' + ' or the half-diamond is connected to a return curve.' + '||Otherwise it is generally better to use curviform V-crossings in an irregular diamond-crossing, so that the diagonal road follows a single curve through the full diamond.' + '||In special cases it is possible to mix different types of V-crossing in the same diamond-crossing, and/or to have a different diagonal radius in each half-diamond.' + ' Make such changes after creating the full diamond-crossing, so that the K-crossing angles in each half always match.' + '||(This diamond-crossing will be irregular-type because the current V-crossing and K-crossing angles are unequal.)', '', '', '', 'more  information  about  types  of  V-crossing', 'cancel', 'continue  with  generic  V-crossings', 4);

          if i = 4 then
            alert_help(0, v_xing_types_help_str, '');
        until i <> 4;

        irreg_crossings_msg_pref := alert_box.preferences_checkbox.Checked;    //%%%%
        alert_box.preferences_checkbox.Visible := False;

        if i = 5 then
          EXIT;
      end;

      new_hdk := ARCCOS(cos_new_hdk);
      new_hdkn := 1 / TAN(new_hdk);

      new_k3 := ARCCOS(cos_new_k3);
      new_k3n := 1 / TAN(new_k3);

      if (ABS(new_k3n) < 1.5) or (ABS(new_hdkn) < 1.5) then begin
        repeat
          i := alert(6, 'php/107   invalid  diamond - crossing',
            'It is not possible to create a full diamond-crossing using the current settings.' +
            '||One of the new crossing angles would be shorter than 1 : 1.5',
            '', '', '', '?  help', 'cancel', '', 4);
          if i = 4 then
            alert_help(0, make_diamond_help_str, '');
        until i <> 4;
        EXIT;
      end;

    end;//if irregular

    store_and_background(False, False);      // keep it (does a recalc) and copy to background.
    if keep_added = False then
      EXIT;          // he cancelled.

    if tradius_is_straight = False     // set new crossing angles if not a regular diamond ...
    then begin
      hdk := new_hdk;
      hdkn := 1 / TAN(hdk);

      k3 := new_k3;
      k3n := 1 / TAN(k3);

      gocalc(0, 0);
    end;

    making_a_diamond := True;     // 215a global flag for retain_on_make  (retain slip adjustments)
    retain_on_make;
    // do blanking, shoves, diffs, crossing entry straight, cancel platforms  213a

    turnout_road_i := 0;
    // reset normal turnout road (in case first half-diamond is part of crossover).
    turnout_i := 0;          // and free overall length.

    snake_onto_bgnd_peg(keeps_list.Count - 1, False, False);
    invert_handing;

    temp1 := hd_vcheck_rails;      // shortening code for half-diamond v-crossing check rails.
    case temp1 of
      1:
        hd_vcheck_rails := 2;    // swap shortened ms or ts v-crossing check rail for single-slip.
      2:
        hd_vcheck_rails := 1;
    end;//case

    temp1 := hd_timbers;           // extension code for slip timbers.
    case temp1 of
      1:
        hd_timbers := 2;         // swap extended sides for single-slip.
      2:
        hd_timbers := 1;
    end;//case

    temp2 := ccd.end_diff_mk.len_diff;
    // swap modified k-crossing check rail lengths.
    ccd.end_diff_mk.len_diff := ccd.end_diff_dk.len_diff;
    ccd.end_diff_dk.len_diff := temp2;

    Result := True;
  except
    Result := False;
    show_modal_message('Sorry, the diamond-crossing calculations have failed.');
    // modal_message needed if math form is showing modal
  end;//try
end;
//____________________________________________________________________________________________

function make_curviform_ladder: boolean;

var
  cos_new_hdk_inner, cos_new_k3: double;
  dummy: double;
  i: integer;
  save_current: Ttemplate_info;
  saved_notch: Tnotch;

  old_trans_end, old_slew_end, old_rad_at_txp, new_rad_at_txp: double;  // 0.97.a

  sp, way_ft, way_ins: double;
  ft_str, ins_str, way_str, sp_str: string;

begin
  Result := False;  // init

  if plain_track = True then begin
    alert(6, '    make  ladder  -  plain  track',
      'The control template is plain track. It is not possible to construct a ladder from plain track.'
      + '||You must first change to a turnout or half-diamond template, by selecting the TEMPLATE > INSERT TURNOUT IN PLAIN TRACK or the TEMPLATE > INSERT HALF-DIAMOND IN PLAIN TRACK menu item.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  if slewing = True then begin
    i := alert(3, '    make  laddder  -  slewed  track',
      '||Your control template contains a slew.' +
      '||It is generally unwise to construct a ladder if any part of it will be within the slewing zone.'
      + '||The slewing function is intended primarily for plain track.', '',
      '', '', 'make  slewed  laddder', 'cancel  ladder',
      'cancel  slewing  -  make  unslewed  ladder', 3);
    case i of
      5:
        EXIT;
      6: begin
        pad_form.disable_slewing_menu_entry.Click;
        gocalc(0, 0);
      end;
    end;//case
  end;

  if xing_calc_i <> 1    // regular/generic crossing, or tradius is straight - make regular ladder...
  then begin
    {if ladder_message=True
               then begin}
    repeat
      i := alert(7, '   make  regular  ladder', 'You are about to make a REGULAR ladder.' +
        '||If you are not sure, or your intention was to make a CURVIFORM ladder, click the white bar below for more information about ladder tracks.', '', '', '', '?  more  information', 'cancel', 'continue  -  make  regular  ladder', 4);
      case i of
        4:
          alert_help(0, ladder_help_str, '');
        5:
          EXIT;
      end;//case
    until i <> 4;
    //end;

    if make_crossover(False, False, False) = False then
      EXIT;
    gocalc(0, 0);
    if make_diamond_crossing = False then
      EXIT;
    gocalc(0, 0);
    pad_form.pad_on_peg_menu_entry.Click;       // centralize pad on it.
    show_and_redraw(True, True);
    EXIT;
  end;

  // make curviform ladder...
  repeat
    i := alert(7, '   make  curviform  ladder', 'You are about to make a CURVIFORM ladder.' +
      '||If you are not sure, or your intention was to make a REGULAR ladder, click the white bar below for more information about ladder tracks.| ', '', '', '', '?  more  information', 'cancel', 'continue  -  make  curviform  ladder', 4);
    case i of
      4:
        alert_help(0, ladder_help_str, '');
      5:
        EXIT;
    end;//case
  until i <> 4;

  if no_spacings_confirm = False      // 215b
  then begin
    sp := cpi.trtscent_pi;   //   TS

    way_ft := ABS((sp / inscale - 62) / 12);

    ft_str := IntToStr(TRUNC(way_ft)) + 'ft';

    way_ins := FRAC(way_ft) * 12;

    if way_ins < minfp then
      ins_str := ''
    else
      ins_str := '-' + FormatFloat('0.#', way_ins) + 'in';

    way_str := '<SPAN STYLE="COLOR:BLUE;">' + ft_str + ins_str + ' way</SPAN>';

    sp_str := '||   prototype: <SPAN STYLE="COLOR:BLUE;">' + FormatFloat('0.##', sp / inscale) +
      ' inches</SPAN>      model: <SPAN STYLE="COLOR:BLUE;">' + FormatFloat('0.##', sp) +
      ' mm</SPAN>' + '||For standard-gauge tracks at your current scale, this spacing would make '
      + way_str + ' between the rails.' +
      '||If this is not correct you can change it before continuing. Remember to allow sufficient running clearance on sharp curves.';

    i := alert(2, '    make  ladder', '||You are about to make a ladder.' +
      '||The current setting for the turnout-side (TS) adjacent track centre spacing is:' +
      sp_str, 'continue  and  don''t  show  this  message  again  today    ',
      'widen  TS  spacing  by  18  inches  and  continue',
      'reduce  TS  spacing  by  18  inches  and  continue',
      'set  new  track  spacings  and  continue ...', 'cancel  ladder', 'continue', 0);
    case i of
      1:
        no_spacings_confirm := True;
      2:
        widen_centres_18in(1);
      3:
        reduce_centres_18in(1);
      4:
        pad_form.adjacent_centres_menu_entry.Click;
      5:
        EXIT;
    end;//case

  end;

  if (g > (47 * inscale)) and (cpi.trtscent_pi < (134 * inscale)) then begin
    if alert(1, '   make  ladder',
      'Your current setting for the TS (turnout-side) track spacing is less than the 11ft-2in centres (134 inches) minimum for UK standard-gauge railways.' + '||If you continue it is very likely that there will be insufficient running clearance between rolling stock on the double tracks.' + '||If the tracks are sharply curved you will need additional track spacing above the minimum to provide sufficient clearance.' + '||To change the setting, click the `0tools > adjacent track centres`1 menu item.', '', '', '', '', 'cancel', 'continue - make  ladder  at  current  setting    ', 0) = 5 then
      EXIT;
  end;


  // first calculate the angles for the first half-diamond...

  cos_new_hdk_inner := (torgy - trtscent - g) / (tradius - g);
  // new K-crossing angle (inner rail).
  cos_new_k3 := cos_new_hdk_inner - g / (g - tradius);
  // new V-crossing angle (inner rail).

  if (ABS(cos_new_k3) > (1 - minfp)) or (ABS(cos_new_hdk_inner) > (1 - minfp))
  // invalid crossing angles.
  then begin
    alert(6, '   impossible  curviform  ladder',
      'It is not possible to create a curviform ladder using the current settings.' +
      '||The most likely reason is that the extended curve does not fully cross the adjacent track.',
      '', '', '', '', 'cancel', '', 0);
    EXIT;
  end;

  //if check_t_55_ok=False then EXIT;   // check he wants it if T-55.

  if check_control_template_is_valid('diamond - crossing') = False then
    EXIT;  // 0.93.a  zero length

  saved_notch := get_current_notch;     // save his current notch position.

  save_current.keep_shove_list := Tshoved_timber_list.Create;

  try
    fill_kd(save_current);                              // in case he wants to cancel.

    do_rollback := False;
    pad_form.peg_on_txp_menu_entry.Click;   // put the peg on the mid-point.

    gocalc(0, 0);  // set pegx on TXP (CTRL-5)

    if spiral = True then
      old_trans_end := os + tst - pegx
    // centre of crossover to end of transition zone  // 0.97.a
    else
      old_trans_end := 0;             // keep compiler happy

    if slewing = True then
      old_slew_end := slew_s + slew_l - pegx     // ditto to end of slewing
    else
      old_slew_end := 0;

    old_rad_at_txp := clrad_at_x(pegx);     // returns the MS centre-line radius at this x

    do_rollback := False;
    pad_form.notch_under_peg_menu_entry.Click;       // and the notch.

    turnout_road_i := -1;              // shorten turnout road to crossover

    if turnoutx < (txpx + 2.5 * scale)     // lengthen existing if nec. (2ft6ins arbitrary)
    then begin
      turnoutx := txpx + 2 * scale;                                   // 2ft arbitrary.
      if turnoutx > turnoutx_max then
        turnoutx := turnoutx_max;
    end;

    turnout_i := 1;     // length locked at turnoutx.

    store_and_background(False, False);     // keep it and copy to background.

    retain_on_make;    // do blanking, shoves, diffs, crossing entry straight, cancel platforms  213a

    pad_form.rotate_current_180_menu_entry.Click;  // rotate it.
    gocalc(0, 0);                                   // calc rotation

    // first adjust radii for ordinary crossover (can't use normal routine -- curviform) ...

    new_rad_at_txp := 0 - (old_rad_at_txp - trtscent);    // rad at crossover mid-point on new side


    if spiral = True then begin
      kform_now := kform;
      docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
      // save current peg data for peg_curve calcs.

      // change sign of centre-line 1st radius.
      nomrad1 := 0 - (nomrad1 - trtscent);    // and adjust for adjacent track.

      // change sign of centre-line 2nd radius.
      nomrad2 := 0 - (nomrad2 - trtscent);    // and adjust for adjacent track.

      dummy := nomrad1;         // swap the 2 radii as we are facing the other way.
      nomrad1 := nomrad2;
      nomrad2 := dummy;

      peg_curve;              // do curving calcs for the current peg position.

    end
    else begin     // fixed curve or straight...

      if (ABS(nomrad) < max_rad_test)    // curved turnout, so must adjust the curving rad...
      then begin
        kform_now := kform;
        docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
        // save current peg data for peg_curve calcs.

        // change sign of centre-line radius.
        nomrad := 0 - (nomrad - trtscent);  // and adjust for adjacent track.

        peg_curve;      // do curving calcs for the current peg position.
      end;
    end;

    clear_current_name;

    if half_diamond = False then
      convert_to_regular_half_diamond;

    hdk := ARCCOS(cos_new_hdk_inner);      // set up using new crossing angles...
    hdkn := 1 / TAN(hdk);
    k3 := ARCCOS(cos_new_k3);
    k3n := 1 / TAN(k3);

    pad_form.peg_on_txp_menu_entry.Click;      // restore Ctrl-5.
    gocalc(0, 0);                               // calc new pegx

    if spiral = True then
      os := pegx - old_trans_end;
    gocalc(0, 0);

    if slewing = True then
      slew_s := pegx - old_slew_end;
    gocalc(0, 0);

    do_rollback := False;                        // and shift onto previous TXP.
    shift_onto_notch(False, True);
    // True = minimum rotation (template already rotated).

    show_and_redraw(False, True);               // immediate generate first half-diamond.

    if make_diamond_crossing = False then
      EXIT;
    gocalc(0, 0);                               // so can centralize pad.

  finally
    save_current.keep_shove_list.Free;
    set_current_notch(saved_notch);                  // restore his notch.

    pad_form.pad_on_peg_menu_entry.Click;            // centralize pad on it.
    show_and_redraw(True, True);
  end;//try
end;
//_____________________________________________________________________________________

function check_grey_paper: boolean;     // return True if the paper colour is near to mid grey.

var
  red, green, blue: integer;

begin
  red := paper_colour and $000000FF;
  green := paper_colour and $0000FF00;
  blue := paper_colour and $00FF0000;

  if (red > $70) and (red < $90) and (green > $7000) and (green < $9000) and
    (blue > $700000) and (blue < $900000) then
    Result := True
  else
    Result := False;

end;
//____________________________________________________________________________________________

function check_dark_paper: boolean;     // return True if the paper colour is black or very dark.

var
  red, green, blue: integer;

begin
  red := paper_colour and $000000FF;
  green := paper_colour and $0000FF00;
  blue := paper_colour and $00FF0000;

  if (red < $60) and (green < $6000) and (blue < $600000)    // RGB ($650 = decimal 96).
  then
    Result := True
  else
    Result := False;
end;
//____________________________________________________________________________________________

function mouse_x(X: integer): double;   // return x mm at this pad X pixels.

begin
  if ABS(fx) < minfp then
    Result := 0               // div by zero on startup.
  else
    Result := (X + gx - ex) / fx;
  if paper_bunching = True then begin
    if X < bunch_start then
      EXIT;
    if X < (bunch_start + bunch_gap) then
      Result := 0                     // in the bunch!
    else
      Result := Result + bunching_jump;
  end;
end;
//______________________________________________________________________________________

function mouse_y(X, Y: integer): double;   // return y mm at this pad Y pixels.

begin
  if ABS(fy) < minfp then
    Result := 0               // div by zero on startup.
  else
    Result := (Y + gy - by) / fy;

  if paper_bunching = True then begin
    if X < bunch_start then
      EXIT;
    if X < (bunch_start + bunch_gap) then
      Result := 0                     // in the bunch!
    else
      Result := Result - bunching_shear;
  end;

end;
//__________________________________________________________________________________________

function pad_X(x: double): integer;   // return pad X pixels at this x mm.

begin
  Result := Round(x * fx - gx + ex);
end;
//______________________________________________________________________________________

function pad_Y(y: double): integer;   // return pad Y pixels at this y mm.

begin
  Result := Round(y * fy - gy + by);
end;
//__________________________________________________________________________________________

procedure update_rollback_register;    // maintain the roll-back register.
// undo_index always points to last-entered data, i.e. matching the control template.

begin
  if turnoutx = 0 then
    EXIT;   // 0.93.a  don't put invalid (zero-length) template in register.

  Inc(undo_index);                                 // roll forward to next slot.
  if undo_index > undo_c then
    undo_index := 0;
  fill_kd(rollback_reg[undo_index].rollback_info); // put control template in slot.

  rollback_reg[undo_index].rollback_name_str := current_name_str;   // 0.93.a
  rollback_reg[undo_index].rollback_memo_str := current_memo_str;   // ...

  rollback_reg[undo_index].valid_flag := True;       // and flag it valid.
end;
//_______________________________________________________________________________________

procedure init_rollbacks;    // init all roll-backs and parking bays

var
  i: integer;

begin
  for i := 0 to undo_c do begin
    rollback_reg[i].valid_flag := False;        // initial flag no valid content.

    rollback_reg[i].rollback_name_str := '';    // 0.93.a
    rollback_reg[i].rollback_memo_str := '';    // ...

    rollback_reg[i].rollback_info.keep_shove_list := Tshoved_timber_list.Create;
  end;

  undo_index := 0;
  pad_form.undo_changes_menu_entry.Enabled := True;
  pad_form.redo_changes_menu_entry.Enabled := True;


  for i := 0 to notch_c do begin     // also init the notch rollback...
    undo_notch[i].notch_x := 0;      // x
    undo_notch[i].notch_y := 0;      // y
    undo_notch[i].notch_k := 0;      // angle
  end;//for
  notch_index := 0 - 1;         // increments to zero on first use.


  for i := 0 to 2 do
    parking_bay[i].keep_shove_list := Tshoved_timber_list.Create;

end;
//__________________________________________________________________________________________

procedure shift_all_group;  // add current xshift_keeps, yshift_keeps to all selected keeps,
// and then clear the shifts.

var
  now_kd: Tkeep_dims;
  n: integer;

begin
  try
    if keeps_list.Count < 1 then
      EXIT;     // no keeps to shift.

    for n := 0 to (keeps_list.Count - 1) do begin

      with keeps_list[n] do begin

        now_kd := template_info.keep_dims;    // get the current keep data (don't need the shoves).

        with now_kd do begin

          if group_selected = False then
            CONTINUE;     // don't shift this one.

          with box_dims1.transform_info do begin
            x2_shift := x2_shift + xshift_keeps;
            y2_shift := y2_shift + yshift_keeps * box_dims1.turnout_info1.hand;

            with notch_info do begin             // update the stored pegging data..
              notch_x := notch_x + xshift_keeps;
              notch_y := notch_y + yshift_keeps;
            end;//with

          end;//with
        end;//with

        new_stamp_wanted := True;
        // True=has been shifted/rotated/mirrored, needs a new timestamp on rebuilding.
        template_info.keep_dims := now_kd;   // update the keep record.

      end;//with
    end;//for next n

    if mouse_shift_sync_wanted = True                        // 219a ..
    then begin
      shift_all_shapes(xshift_keeps, yshift_keeps);

      shapes_saved := False;      // need a resave.
      shapes_current_state;

      do_rollback := False;
      redraw(True);

      mouse_shift_sync_wanted := False;                // only once
    end;

  finally
    xshift_keeps := 0;
    yshift_keeps := 0;
  end;//try
end;
//_______________________________________________________________________________________

procedure twist_all_group;  // rotate all keeps by kform_keeps around the notch.
// and then clear kform_keeps.

var
  now_kd: Tkeep_dims;
  n: integer;

  x, y, hand: double;

  pin, pout: Tpex;

begin
  try
    if keeps_list.Count < 1 then
      EXIT;     // no keeps to rotate.

    for n := 0 to (keeps_list.Count - 1) do begin

      with keeps_list[n] do begin

        now_kd := template_info.keep_dims;    // get the current keep data (don't need the shoves).

        with now_kd do begin

          if group_selected = False then
            CONTINUE;     // don't rotate this one.

          with box_dims1.transform_info do begin

            hand := box_dims1.turnout_info1.hand;
            k_shift := k_shift - kform_keeps * hand;    // update angle.
            normalize_angle(k_shift);

            x := x2_shift - notchx;                   // shift to origin
            y := y2_shift * hand + datum_y - notchy;

            x2_shift := x * COS(0 - kform_keeps) - y * SIN(0 - kform_keeps) + notchx;
            // rotate and shift back onto notch.
            y2_shift := (x * SIN(0 - kform_keeps) + y * COS(0 - kform_keeps) +
              notchy - datum_y) * hand;

            with notch_info do begin                 // update the stored pegging data...

              x := notch_x - notchx;                     // shift pegging data to origin.
              y := notch_y - notchy;

              notch_x := x * COS(0 - kform_keeps) - y * SIN(0 - kform_keeps) + notchx;
              // rotate and get new data.
              notch_y := x * SIN(0 - kform_keeps) + y * COS(0 - kform_keeps) + notchy;

              notch_k := notch_k - kform_keeps;
              normalize_angle(notch_k);
            end;//with

            pin.x := box_dims1.mod_text_x;      // template label position modifiers...
            pin.y := box_dims1.mod_text_y;

            dotransform((0 - kform_keeps), 0, 0, pin, pout);

            box_dims1.mod_text_x := pout.x;
            box_dims1.mod_text_y := pout.y;

          end;//with
        end;//with

        new_stamp_wanted := True;
        // True=has been shifted/rotated/mirrored, needs a new timestamp on rebuilding.
        template_info.keep_dims := now_kd;  // update the keep record.

      end;//with
    end;//for next n

    if mouse_rotate_sync_wanted = True                        // 219a ..
    then begin
      bgnd_form.rotate_notch_radiobutton.Checked := True;
      rotate_centre_code := 1;

      rotate_all_shapes(True, True, 0 - kform_keeps);
      //   True,True = doing sync, include pictures

      shapes_saved := False;      // need a resave.
      shapes_current_state;

      do_rollback := False;
      redraw(True);

      mouse_rotate_sync_wanted := False;             // only once
    end;

  finally
    kform_keeps := 0;
  end;//try
end;
//______________________________________________________________________________

procedure get_ring_size;

const
  dia_help_str: string = '    Spacing  Ring  Inner  Diameter' +
    '||Enter the required inner diameter for the spacing ring tool in mm.' +
    '||This dimension is often set to the "6ft way" minimum spacing (clear between the rails) for double track (6''-0.1/2" on GWR with rail 2.75" wide).' + '||For more notes about using the spacing-ring tool click MORE GENERAL INFORMATION below.';

var
  n: integer;
  od: Toutdim;

begin
  n := putdim(dia_help_str, 1, 'spacing-ring  inner  diameter', ring_dia, True,
    False, False, False);
  // no neg, preset ok, zero ok, don't terminate on zero.
  if n <> 0 then
    EXIT;
  if getdims('spacing-ring  size ...', ring_help_str, grid_form, n, od) = True then begin
    ring_dia := od[0];

    if ring_dia = def_req then
      ring_dia := 134 * inscale - g - railtop * 2;   // spacing ring dia. (6ft way)
    if ring_dia > screenx_max then
      ring_dia := screenx_max;

    rings[0, 2] := ring_dia;
    rings[0, 3] := ring_dia + railtop * 2;                               // outer diameter.

    grid_form.dia_label.Caption := 'dia: ' + round_str(ring_dia, 2) + ' mm';
    do_rollback := False;
    redraw(True);
  end;
end;
//______________________________________________________________________________________

procedure get_ring_location;

var
  n: integer;
  od: Toutdim;

begin
  putdim('', 1, 'spacing-ring  position  X', rings[0, 0], False, True, False, False);
  // neg ok, no preset, zero ok, don't terminate on zero.
  n := putdim('', 1, 'spacing-ring  position  Y', rings[0, 1], False, True, False, False);
  // neg ok, no preset, zero ok, don't terminate on zero.
  if n <> 1 then
    EXIT;
  if getdims('spacing-ring  position ...', ring_help_str, grid_form, n, od) = True then begin
    rings[0, 0] := od[0];
    rings[0, 1] := od[1];
    do_rollback := False;
    redraw(True);
  end;
end;
//______________________________________________________________________________________

procedure set_six_foot_ring;

begin
  rings[0, 2] := 134 * inscale - g - railtop * 2;   // spacing ring dia. (6ft way);
  rings[0, 3] := rings[0, 2] + railtop * 2;      // outer diameter.

  ring_dia := rings[0, 2];
  grid_form.dia_label.Caption := 'dia: ' + round_str(ring_dia, 2) + ' mm';
  do_rollback := False;
  redraw(True);
end;
//_______________________________________________________________________________________

procedure shift_rotate_group(x_move, y_move, k_rot: double; egg_timer: boolean);

begin
  xshift_keeps := x_move;
  yshift_keeps := y_move;
  kform_keeps := k_rot;

  if (xshift_keeps <> 0) or (yshift_keeps <> 0)      // update after mouse shift all keeps.
  then begin
    if egg_timer = True then
      Screen.Cursor := crHourglass;
    shift_all_group;
    if kform_keeps = 0 then
      rebuild_group(False, False);   // no need to do this if it will be done again below.
  end;

  if kform_keeps <> 0      // update after mouse twist all keeps.
  then begin
    if egg_timer = True then
      Screen.Cursor := crHourglass;
    twist_all_group;
    rebuild_group(False, False);
  end;

  if egg_timer = True then
    Screen.Cursor := crDefault;
end;
//________________________________________________________________________________________

procedure unlink_group;

begin
  pad_form.unlink_group_from_notch_menu_entry.Enabled := False;
  group_notch_linked := False;
  pad_form.group_linked_warning_panel.Hide;
end;
//________________________________________________________________________________________

procedure enable_slewing(mode: integer; do_peg_calcs_first: boolean);

var
  dummy: double;

begin
  if do_peg_calcs_first = True then begin
    kform_now := kform;
    // before we change the mode..
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
    // current peg data for peg_curve calcs.
  end;

  with pad_form do begin

    case mode of
      1: begin
        slew_mode1_menu_entry.Checked := True;   // radio item.
        slew_mode := 1;
        adjust_slew2_factor_menu_entry.Enabled := False;
      end;

      2: begin
        slew_mode2_menu_entry.Checked := True;   // radio item.
        slew_mode := 2;
        adjust_slew2_factor_menu_entry.Enabled := True;
      end;

      else
        run_error(13);
    end;//case

    slewing_panel.Caption := '  caution :  template  contains  a  SLEW  ( mode  ' +
      IntToStr(slew_mode) + ' )';
    info_form.slew_caution_mode_label.Caption :=
      'caution :    this  template  contains  a  SLEW  ( mode  ' + IntToStr(slew_mode) + ' )';

    if (plain_track = False) or (slew_mode = 2)
    // min rad info not available for slewed turnouts or any mode 2.
    then begin
      with info_form do begin
        min_rad_box.Hide;               // so can't focus for min rad change button...
        limit_rad_box.Hide;
        slew_warn_panel.Show;           // show warning in info form.
      end;//with
    end;

    slew_nudge_menu_entry.Checked := True;

    adjust_slew_start_menu_entry.Enabled := True;
    adjust_slew_length_menu_entry.Enabled := True;
    adjust_slew_amount_menu_entry.Enabled := True;

    if ABS(slew_angle) > (Pi / 9)  // 20 degrees
    then
      slewing_panel.Font.Color := clYellow
    else
      slewing_panel.Font.Color := clAqua;

    slewing_panel.Show;               // and on pad.

    if (info_form.Left < (slewing_panel.Left + slewing_panel.Width + 4)) and
      (info_form.Top < (slewing_panel.Top + slewing_panel.Height + 4)) then
      info_form.Top := slewing_panel.Top + slewing_panel.Height + 4;
    // ensure warning not obscured by info.

  end;//with

  slewing := True;
  peg_curve;        // slew curve onto peg.
  redraw(True);
end;
//________________________________________________________________________________________

procedure pad_mouse_up(mouse_button: TMouseButton; shift_state: TShiftState; X, Y: integer);

var
  draw_mouse_up_X, draw_mouse_up_Y: integer;
  mouse_up_x, mouse_up_y: double;

  new_shape: Tbgnd_shape;
  i, n: integer;

  bgk: integer;
  X_left, X_right, Y_bottom, Y_top: integer;

  aq: ERailData;
  nk, array_max: integer;
  xint, yint: integer;
  this_is_contained: boolean;
  first_one_found: boolean;

  time_str: string;

  x1, y1, x2, y2: double;
  wl_factor: double;

begin
  if (allow_left_button_pan = True) or (mouse_button = mbMiddle) then
    Screen.Cursor := crDefault;  // 0.91.c
  allow_left_button_pan := False;   // 0.91.c

  if (mouse_modify > 0) and (mouse_action_button_down = True)       // mouse action in progress
  then begin
    mouse_action_release(False);
    EXIT;
  end;

  if (zoom_rectangle = True) and (rectangle_in_progress = True) then begin
    zoom_rectangle := False;
    rectangle_in_progress := False;
    rectangle_exists := False;
    panning_form.zoom_rectangle_latching_toolbutton.Down := False;
    pad_form.zoom_rectangle_latching_toolbutton.Down := False;

    // zoom to show the last rectangle drawn...

    if screeny < minfp then
      EXIT;         // ??
    wl_factor := screenx / screeny;

    x1 := mouse_x(X);              // mm...
    y1 := mouse_y(X, Y);

    x2 := mouse_x(draw_mouse_down_X);
    y2 := mouse_y(draw_mouse_down_X, draw_mouse_down_Y);

    screenx := ABS(x1 - x2);

    if screenx < (ABS(y1 - y2) * wl_factor) then
      screenx := ABS(y1 - y2) * wl_factor;

    if screenx < screenx_min then
      screenx := screenx_min; // minimum for screen width (max zoom in).
    if screenx > screenx_max then
      screenx := screenx_max; // maximum zoom out.

    // centralize on pad..

    if x1 > x2 then
      zoom_offsetx := x2 - (screenx - (x1 - x2)) / 2
    else
      zoom_offsetx := x1 - (screenx - (x2 - x1)) / 2;

    if y1 > y2 then begin
      if wl_factor > minfp then
        zoom_offsety := y2 - (screenx / wl_factor - (y1 - y2)) / 2;
    end
    else begin
      if wl_factor > minfp then
        zoom_offsety := y1 - (screenx / wl_factor - (y2 - y1)) / 2;
    end;

    pad_form.lock_scaling_menu_entry.Click;    // lock pad zoom.
    gocalc(2, 0);

    cancel_adjusts(False);   // to clear the pad caption.

    if bgnd_form.Showing = True then
      bgnd_form.BringToFront;
    // clicking shapes were in progress when he clicked the zoom rectangle tool button.
    EXIT;
  end;

  if (group_fence_rectangle = True) and (rectangle_in_progress = True) then begin
    group_fence_rectangle := False;
    rectangle_in_progress := False;
    rectangle_exists := False;
    pad_form.group_fence_latching_toolbutton.Down := False;

    // group select all templates inside the last rectangle drawn...

    if any_bgnd > 0 then begin

      x1 := mouse_x(X);              // mm...
      y1 := mouse_y(X, Y);

      x2 := mouse_x(draw_mouse_down_X);
      y2 := mouse_y(draw_mouse_down_X, draw_mouse_down_Y);

      if pad_form.group_fence_whole_menu_entry.Checked = True
      // wholly contained templates?
      then begin
        X_left := Round(min(x1, x2) * 100);
        // 1/100ths mm. Use actual clicked corners.
        X_right := Round(max(x1, x2) * 100);
        Y_bottom := Round(min(y1, y2) * 100);
        Y_top := Round(max(y1, y2) * 100);
      end
      else begin
        X_left := Round((min(x1, x2) - g / 2) * 100);
        // 1/100ths mm. Add a tolerance og g/2 (arbitrary),
        X_right := Round((max(x1, x2) + g / 2) * 100);
        // so can just click on a template to select it.
        Y_bottom := Round((min(y1, y2) - g / 2) * 100);
        // !!! n.b. g/2 is per the control template, not the background template (for simplicity).
        Y_top := Round((max(y1, y2) + g / 2) * 100);
      end;

      first_one_found := False; // init.

      for bgk := 0 to (keeps_list.Count - 1) do begin

        with keeps_list[bgk] do begin

          if bg_copied = False then
            CONTINUE;  // this one not a background template.

          try
            with bgnd_keep do begin

              this_is_contained := False;  // init flag for this template.

              if pad_form.group_fence_whole_menu_entry.Checked =
                True  // wholly contained templates?

              then begin
                // yes, so only need to check the template's enclosing rectangle...

                if (xlist_min < X_left) or (xlist_max > X_right) or
                  (ylist_min < Y_bottom) or (ylist_max > Y_top) then
                  CONTINUE  // not this one, next template.
                else
                  this_is_contained := True;
              end
              else begin
                // no, to test for partially contained templates we must search the whole template...

                for aq := eRD_KCrossingCheckTurnoutSideOuterEdge downto
                  eRD_StraightStockGaugeFace do begin
                  // 205e was 25    ignore FB foot lines.

                  if Length(list_bgnd_rails[aq]) = 0 then
                    CONTINUE;                       // empty rail, next aq.

                  array_max := High(list_bgnd_rails[aq]);
                  for nk := 0 to array_max do begin

                    xint := list_bgnd_rails[aq][nk].X;
                    yint := list_bgnd_rails[aq][nk].Y;

                    if (xint > X_left) and (xint < X_right) and (yint > Y_bottom) and
                      (yint < Y_top) then begin
                      this_is_contained := True;
                      BREAK;
                      // ignore remainder of this rail.
                    end;
                  end;//next nk

                  if this_is_contained = True then
                    BREAK;   // ignore remaining rails.
                end;//next aq
              end;

              if this_is_contained = True
              // found a bgnd template for group select...
              then begin

                if (first_one_found = False) and
                  (pad_form.group_fence_new_menu_entry.Checked = True) then
                  clear_all_selections;

                first_one_found := True;

                if template_info.keep_dims.box_dims1.bgnd_code_077 = -1 then
                  group_selected := False      // library template???
                else begin
                  if pad_form.group_fence_toggle_menu_entry.Checked = True then
                    group_selected :=
                      not group_selected                                  // toggle.
                  else
                    group_selected := not pad_form.group_fence_remove_menu_entry.Checked;
                  // add or new, or remove.
                end;
              end;
            end;//with bgnd_keep
          except
            EXIT;
          end;//try
        end;//with template
      end;//next template.
    end;//if any bgnd

    cancel_adjusts(False);   // to clear the pad caption.

    if bgnd_form.Showing = True then
      bgnd_form.BringToFront;
    // clicking shapes were in progress when he clicked the zoom rectangle tool button.
    redraw_pad(True, False);
    EXIT;
  end;//if group rectangle

  // 0.93.a ...

  if (output_boundary_rectangle = True) and (rectangle_in_progress = True) then begin
    output_boundary_rectangle := False;
    rectangle_in_progress := False;
    rectangle_exists := False;
    pad_form.output_rectangle_latching_toolbutton.Down := False;

    // set globals...

    output_rectangle_x1 := mouse_x(X);              // mm...
    output_rectangle_y1 := mouse_y(X, Y);

    output_rectangle_x2 := mouse_x(draw_mouse_down_X);
    output_rectangle_y2 := mouse_y(draw_mouse_down_X, draw_mouse_down_Y);

    output_rectangle_width := ABS(output_rectangle_x2 - output_rectangle_x1);
    output_rectangle_height := ABS(output_rectangle_y2 - output_rectangle_y1);

    draw_export_rectangle_flag := True; // make sure it's visible.

    cancel_adjusts(False);   // to clear the pad caption and restore cursor.

    redraw_pad(True, False);

    if export_form_was_showing = True then begin
      export_form_was_showing := False;
      pad_form.export_file_menu_entry.Click;
    end;
    EXIT;
  end;

  if (drawn_shape_rectangle = True) and (rectangle_in_progress = True)  // add the shape...
  then begin
    drawn_shape_rectangle := False;
    rectangle_in_progress := False;
    rectangle_exists := False;

    // set globals...

    shape_rectangle_x1 := mouse_x(X);              // mm...
    shape_rectangle_y1 := mouse_y(X, Y);

    shape_rectangle_x2 := mouse_x(draw_mouse_down_X);
    shape_rectangle_y2 := mouse_y(draw_mouse_down_X, draw_mouse_down_Y);

    add_shape(0);   //   0 = by drawing
    EXIT;
  end;

  if (mouse_draw_lines = False) or (mouse_drawing_in_progress = False) then
    EXIT;

  // drawn mouse line terminates on mouse up...

  draw_mouse_up_X := X;      // screen coords.
  draw_mouse_up_Y := Y;

  mouse_up_x := mouse_x(X);    // and in mm. for shape list
  mouse_up_y := mouse_y(X, Y);

  mouse_drawing_in_progress := False;

  with pad_form.Canvas do begin
    // first draw it immediately on the pad, so no redraw of shapes needed to show it.
    Pen.Width := 1;
    Pen.Mode := pmCopy;
    if bgnd_form.dotted_radio_button.Checked = True then begin
      Brush.Color := paper_colour;  // for gaps in dotted lines
      Brush.Style := bsClear;

      TextOut(0, 0, '');    // Delphi bug?
      Pen.Style := psDot;
    end
    else
      Pen.Style := psSolid;

    Pen.Color := shapes_colour;

    MoveTo(draw_mouse_down_X, draw_mouse_down_Y);   // saved line starting point.
    LineTo(draw_mouse_up_X, draw_mouse_up_Y);       // line ends on mouse up.
  end;//with

  with new_shape do begin

    shape_name := '';  // init

    if (bgnd_form.Visible = True) and (bgnd_form.line_radio_button.Checked = True) and
      (bgnd_form.by_drawing_radiobutton.Checked = True) then
      shape_name := bgnd_form.name_editbox.Text;

    if shape_name = '' then
      shape_name := 'drawn line';

    hide_bits := 0;    // 214a  normal visibility
    option_bits := 0;     // byte;

    shape_code := 0;
    // 0=line, 1=rectangle, 2=circle.
    if bgnd_form.dotted_radio_button.Checked = True then
      shape_style := 2    // dotted line.
    else
      shape_style := 0;   // solid line.

    p1.x := mouse_down_x;  // saved line starting point..
    p1.y := mouse_down_y;

    p2.x := mouse_up_x;    // end point on mouse up..
    p2.y := mouse_up_y;

    if (p1.x = p2.x) and (p1.y = p2.y) then begin
      alert(6, 'php/301    invalid  line  shape',
        'This shape can not appear because the length of the line is zero.' +
        '||The most likely reason is that you simply clicked the trackpad instead of drawing a line.',
        '', '', '', '', 'cancel  shape', '', 0);
      EXIT;
    end;

    normalize_line(p1, p2);

    with bgnd_form.bgnd_shapes_listbox do begin
      n := Items.AddObject(new_shape.shape_name, Tbgshape.Create);
      // create and add a new line in the shapes list.
      Tbgshape(Items.Objects[n]).bgimage := nil;                   // not bitmap image 3-2-01.
      Tbgshape(Items.Objects[n]).bgnd_shape := new_shape;          // put data in list.
      ItemIndex := n;                                              // make it current.
    end;//with

  end;//with new_shape

  shapes_saved := False;   // need a fresh save.
  shapes_current_state;  // update the form.
end;
//_____________________________________________________________________________________________

function check_shove: boolean;    // check some timbers there for shove / select.

begin
  Result := False;         // init

  // 208c mods -- bug fix

  if no_timbering = True then begin
    alert(3, '    no  timbers',
      'There are no timbers to shove because the control template has been set to `0no timbering`1.'
      + '||To restore the timbers, click one of the timbering styles in the `0real > timbering >`1 menu options.',
      '', '', '', '', '', 'O K', 0);
    EXIT;
  end;


  if cl_only = True then begin
    if alert(3, '    no  timbers  showing',
      'There are no timbers to shove because the control template has been set to show track centre-lines only.'
      +
      '||Do you want to restore the rails and timbers for this template?', '',
      '', '', '', 'no  -  cancel', 'yes  -  restore  rails  and  timbers  and  continue',
      0) = 5 then
      EXIT;
    pad_form.normal_track_centre_lines_menu_radio.Click;   // radio item.
  end;

  Result := True;
end;
//__________________________________________________________________________________________

procedure delete_null_shove_entries;   // remove any unshoved entries from current shove list.

var
  n: integer;

begin
  n := 0;
  while n < current_shove_list.Count do begin
    if current_shove_list[n].can_restore then begin
      Inc(n);
    end
    else begin
      current_shove_list.Delete(n);
    end;

  end;
end;
//___________________________________________________________________________________________

function find_shove(str: string; create_new: boolean): integer;
  // find str in current shove list, or create an empty slot for it.
  // return -1 if not present and not creating new.
var
  n: integer;
  i: integer;

begin
  Result := -1;                   // init.

  delete_null_shove_entries;    // first remove any unshoved entries.

  with current_shove_list do begin               // mods for 0.71.a 27-4-01 ...

    n := -1;
    for i := 0 to Count - 1 do begin
      if Items[i].timber_string = str then begin
        n := i;
        break;
      end;
    end;
    if n >= 0 then begin
      Result := n;
      EXIT;           // already in list.
    end;

    if create_new = False then
      EXIT;

    n := Add(Tshoved_timber.Create);          // create new entry and return the index.
    Items[n].timber_string := str;

  end;//with

  Result := n;
end;
//______________________________________________________________________________________

procedure shove_along_mouse_action;

begin
  cancel_adjusts(True);
  shove_index := find_shove(current_shove_str, True);

  if shove_index <> -1 then begin
    current_shove_list[shove_index].set_shovex(shovex);

    mouse_action_selected('    shove  timber  along ...',
      'shove  timber  along', current_shove_str + '  along  by : ' + captext(shovex) + ' mm');
    shove_along_mod := 1;
    full_draw := True;     //  otherwise can't see the timbers.
    EXIT;
  end;

  shove_index := 0;   // safety - don't leave it invalid.

end;
//_________________________________________________________________________________________

procedure shove_throw_mouse_action;

begin
  cancel_adjusts(True);
  shove_index := find_shove(current_shove_str, True);

  if shove_index <> -1 then begin
    current_shove_list[shove_index].set_offset(shoveo);

    mouse_action_selected('    throw  timber  endways ...',
      'throw  timber  endways', current_shove_str + '  throw  by : ' + captext(shoveo) + ' mm');
    shove_throw_mod := 1;
    full_draw := True;         //  otherwise can't see the timbers.
    EXIT;
  end;

  shove_index := 0;   // safety - don't leave it invalid.
end;
//__________________________________________________________________________________________

procedure shove_crab_mouse_action;

begin
  cancel_adjusts(True);
  shove_index := find_shove(current_shove_str, True);

  if shove_index <> -1 then begin
    current_shove_list[shove_index].set_crab(shovec);
    mouse_action_selected('    crab  timber  sideways ...',
      'crab  timber  sideways', current_shove_str + '  crab  by : ' + captext(shovec) + ' mm');
    shove_crab_mod := 1;
    full_draw := True;         //  otherwise can't see the timbers.
    EXIT;
  end;

  shove_index := 0;   // safety - don't leave it invalid.
end;
//__________________________________________________________________________________________

procedure shove_length_mouse_action;

begin
  cancel_adjusts(True);
  shove_index := find_shove(current_shove_str, True);

  if shove_index <> -1 then begin
    current_shove_list[shove_index].set_length(shovel);
    mouse_action_selected('    lengthen  timber ...', 'lengthen  timber',
      current_shove_str + '  lengthened  by : ' + captext(shovel) + ' mm');
    shove_length_mod := 1;
    full_draw := True;      //  otherwise can't see the timbers.
    EXIT;
  end;

  shove_index := 0;   // safety - don't leave it invalid.
end;
//_________________________________________________________________________________________

procedure shove_width_mouse_action;

begin
  cancel_adjusts(True);
  shove_index := find_shove(current_shove_str, True);

  if shove_index <> -1 then begin
    current_shove_list[shove_index].set_width(shovew);
    mouse_action_selected('    widen  timber ...', 'widen  timber',
      current_shove_str + '  widened  by : ' + captext(shovew * 2) + ' mm');
    shove_width_mod := 1;
    full_draw := True;     //  otherwise can't see the timbers.
    EXIT;
  end;

  shove_index := 0;   // safety - don't leave it invalid.
end;
//__________________________________________________________________________________________

procedure shove_twist_mouse_action;

begin
  cancel_adjusts(True);
  shove_index := find_shove(current_shove_str, True);

  if shove_index <> -1 then begin
    current_shove_list[shove_index].set_twist(shovek);

    mouse_action_selected('    twist  timber ...', 'twist  timber',
      current_shove_str + '  twisted  by : ' + captext(shovek * 180 / Pi) +
      ' degrees' + k_ram_str(shovek));
    shove_twist_mod := 1;
    full_draw := True;      //  otherwise can't see the timbers.
    EXIT;
  end;

  shove_index := 0;   // safety - don't leave it invalid.
end;
//__________________________________________________________________________________________

procedure fix_approach_length(snap: boolean; lmod: double);

var
  xorg_old, t_only, dummy1: double;

begin
  startx := 0;                                 // cancel any blanking.

  if snap = True then
    pad_form.snap_approach_to_nearest_menu_entry.Click;   // must first snap to nearest.

  gocalc(0, 0);                               // and do initial pegging for.

  xorg_old := xorg;           // for pegging calcs.
  t_only := turnoutx - xorg;    // length of turnout portion.

  xorg := xorg + lmod;          // mod xorg within limits...
  if xorg < 0 then
    xorg := 0;
  if xorg > (turnoutx_max - t_only) then
    xorg := turnoutx_max - t_only;

  turnoutx := xorg + t_only;    // correct overall length.

  // belt and braces keep turnoutx within limits...

  if turnoutx < 0 then
    turnoutx := 0;
  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;
  if plain_track = True then
    turnoutx := xorg;               //  keep lengths equal for plain track.

  //startx:=startx+lmod;         // adjust any blanking.
  //if startx<0 then startx:=0;
  //if startx>(turnoutx-scale) then startx:=turnoutx-scale;     // arbitrary 1ft inside overall length maximum blanking.

  udpegx := udpegx + xorg - xorg_old;   // user-defined position.

  if peg_code <> 0 then begin
    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
    // get current peg data for peg_curve calcs.

    pegx := pegx + xorg - xorg_old;
    //  pegx changes with xorg unless peg is reset on rail-end.

    if spiral = True then
      os := os + xorg - xorg_old;           //  os transition start changes with xorg ditto.
    if slewing = True then
      slew_s := slew_s + xorg - xorg_old;  //  slewing ditto
    peg_curve;                                          //  keep turnout on the peg.
  end;

  gocalc(1, 0);
  // re-calc with new lengths for new last_xtb, but don't draw it yet.
  if snap = True then
    pad_form.snap_approach_to_nearest_menu_entry.Click;  // then snap to sleeper centre again.
end;
//_____________________________________________________________________________________________

procedure fix_exit_length(lmod: double);

var
  dummy1: double;

begin
  pad_form.snap_exit_to_nearest_menu_entry.Click;   // first snap to nearest sleeper.
  gocalc(0, 0);                                      // and do pegging for.

  turnoutx := turnoutx + lmod;                  // modify the length.

  if turnoutx < 0 then
    turnoutx := 0;           // but keep within limits...
  if turnoutx < xorg then
    turnoutx := xorg;
  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;

  if peg_code = 11 then begin               // peg is on length...
    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy1);
    // get current peg data for peg_curve calcs.

    pegx := turnoutx;
    peg_curve;        // keep peg constant.
  end;
  gocalc(1, 0);
  // re-calc with new lengths for new last_xtb, but don't draw it yet.
  pad_form.snap_exit_to_nearest_menu_entry.Click;   // then snap to sleeper centre again.
  redraw(False);
  // force draw in case he holds the shortcut key down.
end;
//__________________________________________________________________________________________

procedure normalize_keep_transforms(t_data: Ttransform_info);
// update keep shifts so that x1_shift, y1_shift can be zero,
// i.e. any subsequent rotation is about the template origin,
var
  x, y: double;

begin
  with t_data do begin
    x := x1_shift - x1_shift * COS(k_shift) + y1_shift * SIN(k_shift) + x2_shift;
    y := y1_shift - x1_shift * SIN(k_shift) - y1_shift * COS(k_shift) + y2_shift;

    x2_shift := x;                       // then normalise the data...
    y2_shift := y;

    x1_shift := 0;
    y1_shift := 0;

    normalize_angle(k_shift);
  end;//with
end;
//___________________________________________________________________________________________

procedure mirror_keeps_x;     // X mirror a group of templates about the notch.

var
  now_keep: Tkeep_dims;
  n: integer;

begin
  if keeps_list.Count < 1 then
    EXIT;     // no keeps to mirror.

  for n := 0 to (keeps_list.Count - 1) do begin

    with keeps_list[n] do begin

      now_keep := template_info.keep_dims;    // get the current keep data.

      with now_keep do begin

        if group_selected = False then
          CONTINUE;     // don't mirror this one.

        normalize_keep_transforms(box_dims1.transform_info);

        with box_dims1.transform_info do begin

          k_shift := k_shift + Pi;                    // rotate 180 degs.
          normalize_angle(k_shift);

          //x2_shift:=0-x2_shift;                 // mirror X on origin.

          x2_shift := notchx + (notchx - x2_shift);     // mirror X on notch.  15-7-01.

          y2_shift := 0 - y2_shift;                   // because of changed hand.

          with notch_info do begin
            // update the stored pegging data.. !!! bug fix 15-7-01.
            notch_x := notchx + (notchx - notch_x);
            notch_k := Pi * 2 - notch_k;
            normalize_angle(notch_k);
          end;//with

        end;//with

        box_dims1.mod_text_x := 0 - box_dims1.mod_text_x;
        // modified template label position.

        box_dims1.turnout_info1.hand := 0 - box_dims1.turnout_info1.hand;   // swap hand.

      end;//with
      new_stamp_wanted := True;
      // True=has been shifted/rotated/mirrored, needs a new timestamp on rebuilding.
      template_info.keep_dims := now_keep;   // update the keep record.

    end;//with
  end;//for next n
end;
//_______________________________________________________________________________________

procedure mouse_symbol_click;  // symbol clicked on action form.

begin
  if mouse_modify <> 0 then
    EXIT;    // 205c not while actually adjusting.

  // swap r1 or r2...

  if ((curving_mod = 1) or (orbit_mod = 1) or (both_mod = 1)) and (spiral = True)
  // curving mouse action already active for transition?
  then begin
    if adjust_trans_rad = 1 then
      pad_form.adjust_rad2_menu_entry.Click
    else
      pad_form.adjust_rad1_menu_entry.Click;
    EXIT;
  end;

  // ruler swap ends...

  if ruler1_mod = 1 then begin
    pad_form.move_ruler_2nd_end_menu_entry.Click;
    EXIT;
  end;

  if ruler2_mod = 1 then begin
    pad_form.move_ruler_1st_end_menu_entry.Click;
    EXIT;
  end;

  // swap F9 - F10

  if half_diamond = True then begin
    if vee_mod = 1 then begin
      pad_form.adjust_k_crossing_angle_menu_entry.Click;
      EXIT;
    end;

    if hdk_mod = 1 then begin
      pad_form.adjust_v_crossing_angle_menu_entry.Click;
      EXIT;
    end;
  end;


  // 205c  swap F9 - SHIFT-F12 ...

  if gaunt = True then begin
    if vee_mod = 1 then begin
      pad_form.adjust_gaunt_radius_menu_entry.Click;
      EXIT;
    end;

    if (gaunt_offset_mod = 1) or (gaunt_radius_mod = 1) then begin
      pad_form.adjust_v_crossing_angle_menu_entry.Click;
      EXIT;
    end;
  end;


  // 205c  shift group - rotate group ...

  if shift_keeps_mod = 1 then begin
    pad_form.rotate_keeps_menu_entry.Click;
    EXIT;
  end;

  if twist_keeps_mod = 1 then begin
    pad_form.shift_keeps_menu_entry.Click;
    EXIT;
  end;


  // 205c  trans start - trans length ...

  if trans_start_mod = 1 then begin
    pad_form.adjust_trans_length_menu_entry.Click;
    EXIT;
  end;

  if trans_length_mod = 1 then begin
    pad_form.adjust_trans_start_menu_entry.Click;
    EXIT;
  end;


  // 205c  F7 - F8 ...

  if shift_mod = 1 then begin
    pad_form.rotate_menu_entry.Click;
    EXIT;
  end;

  if twist_mod = 1 then begin
    pad_form.shift_menu_entry.Click;
    EXIT;
  end;


  // or repeat the last...

  pad_form.repeat_last_action_menu_entry.Click;  // normal repeat.
end;
//__________________________________________________________________________________________

procedure insert_turnout;

begin
  if plain_track = False then
    EXIT;     // ? menu should be disabled when drawing turnouts.

  if (pegx < 0) or (pegx > (turnoutx - g * 4))
  // reset peg if not in sensible position. (g*4 arbitrary).
  then begin
    pad_form.reset_peg_menu_entry.Click;
    redraw(False);
  end;

  plain_track := False;                     // swap to turnouts..
  set_plain_track(False, True);

  xorg := pegx;                             // put the toe joint at the current peg position.
  if xorg < 0 then
    xorg := 0;                 // keep within limits.
  if xorg > turnoutx then
    xorg := turnoutx;

  turnout_road_i := retpar_i;   // 206e bug fix -- need long turnout road for parallel crossing

  startx := 0;           // cancel any previous blanking (shouldn't be any for plain track!)
  tb_roll_percent := 0;  // cancel any previous timber rolling (in case he reverts to plain track).
  if peg_code = -2 then
    peg_code := -1; // so peg on joints can re-initialise.

  retain_on_make;    // do blanking, shoves, diffs, crossing entry straight, cancel platforms  213a

  if cl_only = True then
    railedges(gauge_faces, outer_edges, centre_lines);
  // 28-10-99 this is a bug fix to put aq 25 back on. Why is it sometimes off???
end;
//_______________________________________________________________________________________

procedure swap_end_for_end;

var
  saved_notch: Tnotch;
  saved_pegx, saved_pegy: double;
  saved_peg_code: integer;
  saved_peg_rail: integer;

begin
  cancel_adjusts(False);  // 0.93.a may be from toolbutton

  saved_notch := get_current_notch;   // we need to use the current notch.

  saved_pegx := pegx;
  saved_pegy := pegy;
  saved_peg_code := peg_code;
  saved_peg_rail := peg_rail;

  startx := 0;                        // cancel any blanking.

  do_rollback := False;
  pad_form.reset_peg_menu_entry.Click;
  gocalc(0, 0);

  new_notch(get_peg_for_notch, False);
  gocalc(0, 0);

  do_rollback := False;
  pad_form.rotate_current_180_menu_entry.Click;
  gocalc(0, 0);

  if plain_track = True then
    pad_form.peg_on_joint_end_menu_entry.Click
  else
    pad_form.peg_on_overall_length_menu_entry.Click;
  gocalc(0, 0);

  if slewing = True       // slewing, swap end positions..
  then begin
    slew_s := turnoutx - (slew_s + slew_l);   // neg slew_s is OK.
    slew := 0 - slew;
    gocalc(0, 0);
  end;

  if spiral = True        // transition, swap end positions and rads...
  then begin
    os := turnoutx - (os + tst);         // neg os is OK.

    clrad1 := nomrad1{+ycurv};         // centre-line 1st radius.
    clrad2 := nomrad2{+ycurv};         // centre-line 2nd radius.

    nomrad2 := clrad1{-ycurv};         // swap the radii.
    nomrad1 := clrad2{-ycurv};

    if adjust_trans_rad = 1 then
      adjust_trans_rad := 2      // and the one he was adjusting.
    else
      adjust_trans_rad := 1;

    gocalc(0, 0);
  end;

  swap_hand;
  gocalc(0, 0);

  do_rollback := False;
  shift_onto_notch(False, False);

  do_rollback := False;
  pad_form.rotate_current_180_menu_entry.Click;

  set_current_notch(saved_notch);   // restore the current notch.

  pegx := saved_pegx;
  pegy := saved_pegy;
  peg_code := saved_peg_code;
  peg_rail := saved_peg_rail;
end;
//________________________________________________________________________________________

procedure set_trans_position_from_ctrl_0(os_offset, zone_len: double);

var
  dummy: double;

begin
  if zone_len < 0 then
    zone_len := 0; // ??? menus should be disabled.

  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  os := os_offset;
  tst := zone_len;

  peg_curve;             //  adjust shifts and rotates for current peg position.
  redraw(True);
end;
//____________________________________________________________________________________________

procedure set_slew_position_from_ctrl_0(start_offset, zone_len: double);

var
  dummy: double;

begin
  if zone_len < ABS(slew) then
    zone_len := ABS(slew);    // ??? arbitrary minimum. (can't go neg).
  if zone_len < 1 then
    zone_len := 1;                    // 1 mm safety minimum (div by zero).

  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  slew_s := start_offset;
  slew_l := zone_len;

  peg_curve;             //  adjust shifts and rotates for current peg position.
  redraw(True);
end;
//____________________________________________________________________________________________

function normalize_transition: boolean; // normalize to template extents if zone outside them.

var
  dummy: double;
  new_tst, new_os, new_r1, new_r2, rad_diff, temp_ktrans: double;

begin
  Result := False;              // default init.

  if spiral = False then
    EXIT;  // ???

  if (os >= 0) and ((os + tst) <= turnoutx) then begin
    Result := True;
    EXIT;         // zone is completely within template (already normalized).
  end;

  if (os + tst) < 0   // template is all in r2...
  then begin
    if pegx < (os + tst)      // but peg not in r2..
    then begin
      pad_form.reset_peg_menu_entry.Click;   // peg on datum
      gocalc(0, 0);                           // calc it.
    end;
    fix_radius(nomrad2, False);    // set fixed radius curving.
    Result := True;
    EXIT;
  end;

  if os > turnoutx   // template is all in r1...
  then begin
    if pegx > os     // but peg not in r1..
    then begin
      pad_form.reset_peg_menu_entry.Click;   // peg on datum
      gocalc(0, 0);                           // calc it.
    end;
    fix_radius(nomrad1, False);    // set fixed radius curving.
    Result := True;
    EXIT;
  end;

  if (pegx < 0) or (pegx > turnoutx)   // peg not in template extents...
  then begin
    pad_form.reset_peg_menu_entry.Click;   // peg on datum
    gocalc(0, 0);                           // calc it.
  end;

  new_tst := tst;     // init zone adjusts (don't change trans until both rads calced)...
  new_os := os;
  new_r1 := nomrad1;
  new_r2 := nomrad2;

  if os < 0            // trans starts before template...
  then begin
    new_r1 := clrad_at_x(0);  // set new r1 from centre-line radius at datum.
    new_tst := tst + os;        // new zone is shorter.
    new_os := 0;
  end;

  if (os + tst) > turnoutx    // trans ends beyond template...
  then begin
    new_r2 := clrad_at_x(turnoutx);  // set new r2 from centre-line radius at template end.
    new_tst := turnoutx - new_os;      // new zone is shorter.
  end;

  // check for error conditions... ???

  rad_diff := ABS(new_r1 - new_r2);
  if rad_diff > minfp then
    temp_ktrans := new_r1 * new_r2 * new_tst / rad_diff   // new spiral constant???
  else
    temp_ktrans := max_spiral_constant * 2;           // force error.

  if (ABS(temp_ktrans) > max_spiral_constant) or (rad_diff < minfp) or
    (ABS(new_r1) < (g * 2))    // min rad (arbitrary).
    or (ABS(new_r2) < (g * 2)) or (new_tst < 0) then
    EXIT;

  // can now change settings...

  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  os := new_os;
  tst := new_tst;
  nomrad1 := new_r1;
  nomrad2 := new_r2;

  peg_curve;       // fix template on peg.
  Result := True;
end;
//_____________________________________________________________________________________

procedure crop_approach;

begin
  if plain_track = True then
    EXIT;      // otherwise sets zero length.

  if peg_code = 0 then
    pad_form.peg_on_joint_end_menu_entry.Click;

  fix_approach_length(False, 0 - xorg);                           // crop off all of xorg.
end;
//_______________________________________________________________________________________

procedure peg_indicator_click;

begin
  with pad_form do begin
    // toggle peg end to end.
    if peg_code <> 0 then
      reset_peg_menu_entry.Click
    else begin
      if plain_track = True then
        peg_on_joint_end_menu_entry.Click
      else
        peg_on_overall_length_menu_entry.Click;
    end;
  end;//with
end;
//_____________________________________________________________________________________

procedure new_label_position;      // modify position of  bgnd name label

var
  mod_X, mod_Y: integer;

begin
  if (any_bgnd = 0) or (clicked_keep_index < 0) or (clicked_keep_index >
    (keeps_list.Count - 1)) then
    EXIT;

  with keeps_list[clicked_keep_index] do begin

    if bg_copied = False then
      EXIT;  // ??? not on background.

    with bgnd_keep do begin

      with pad_form.dummy_label_panel do begin        // copy the dummy label position...

        mod_X := Left - text_begin_X + 22;        // distance label moved (pixels).
        mod_Y := Top - text_begin_Y + 2;

        text_begin_X := text_begin_X + mod_X;
        text_begin_Y := text_begin_Y + mod_Y;
        text_end_X := text_end_X + mod_X;
        text_end_Y := text_end_Y + mod_Y;
        //Hide;
      end;//with panel.
    end;//with bgnd_keep.

    with template_info.keep_dims.box_dims1 do begin
      mod_text_x := mod_text_x + mod_X * ffx;
      mod_text_y := mod_text_y + mod_Y * ffy;
    end;//with

  end;//with template

  save_done := False;
  backup_wanted := True;
  redraw_pad(False, False);  // force immediate redraw to move the label.
end;
//____________________________________________________________________________________________

procedure cancel_paper_bunching;

begin
  if (bunch_mod = 1) or (mouse_modify > 0) then
    cancel_adjusts(False);

  paper_bunching := False;
  pad_form.paper_bunching_off_menu_entry.Checked := True;           // radio item.
  pad_form.adjust_paper_bunching_menu_entry.Enabled := False;
end;
//________________________________________________________________________________________

procedure clear_current_name;

begin
  current_name_str := '';    // 208a         // control template reference.

  info_form.ref_name_label.Caption := current_name_str;
end;
//_______________________________________________________________________________________

procedure mint_new_current(locked_length: integer);  // 208d locked_length added

// locked_length: 0=free length, 1=locked at existing turnoutx

{
  A "mint" template is a new control template with the following settings:

  Regular crossing.
  Normal length turnout road.
  Normal length main road.
  No approach or exit track (208d if locked_length=0).
  Fixed radius curving (no slew or transition curve).
  No blanking.
  No bonus timbers.
  No timber randomizing.
  No gaunt turnout.
  Rails on.
  Timbering on.
  Normal rail joints.
  Bent flares.  213a
  No timber rolling.
  No platforms.
  No trackbed edges.
  No adjacent tracks.
  Fixing peg in the CTRL-0 reset position.
  Centre-lines only cancelled.
  //Name: 'no-name'
  Name label position restored when stored.
  Memo: cleared.
  No curviform timbering

  If the switch is REA, any customized crossing is cancelled.
  Half-diamond cancelled and timbering restored to equalized incremental.

  Other settings remain unchanged.

  If not on the datum, it is put centre-pad, with zoom settings not changed.
  If on the datum, leave it there and zoom to fit.
}
var
  on_datum: boolean;

begin
  cancel_adjusts(False);
  //update_rollback;         // ensure current is in register.

  pad_form.reset_tandem_turnout_menu_entry.Click;      // 218a

  isolated_crossing := False;   // 217a

  normalize_transforms;

  if (xshift = 0) and (yshift = 0) and (kform = 0) then begin
    clear_transform_data;  // clear shifts if not already.
    on_datum := True;        // set this now - routines below include a peg_curve.
  end
  else
    on_datum := False;

  with pad_form do begin

    do_rollback := False;

    normal_track_centre_lines_menu_radio.Click;    // 0.93.a mods

    cl_only := False;                         // in case it was out of step with the menu check.

    track_centre_lines_flag := True;

    switch_drive_flag := True;     // 0.82.a

    do_rollback := False;
    if (no_timbering = True) or (half_diamond = True) then begin
      equalized_incremental_menu_entry.Enabled := True;
      equalized_incremental_menu_entry.Click;         // radio item.
    end;

    do_rollback := False;
    cancel_blanking_menu_entry.Click;

    nomrad := ABS(nomrad);                    // cancel any contraflexure.

    if (spiral = True) or (nomrad > max_rad_test)   // transition or straight.
    then begin
      spiral := False;                // no transition.
      nomrad := 660 * scale;            // fixed 10 chains curve.
    end;

    do_rollback := False;
    disable_slewing_menu_entry.Click;

    bontimb := 0;                                // no bonus timbers 0.76.a  23-10-01.
    tb_roll_percent := 0;                        // no timber rolling 0.76.a 13-5-02.
    rjcode := 0;                                 // normal rail joints 0.76.a  23-10-01.
    half_diamond := False;                       // normal switch calcs.
    if peg_code = -2 then
      peg_code := -1;          // so peg on joints can re-initialise.
    if rail_section = 0 then
      rail_section := 1;    // rails on, bullhead default.

    if rail_section = 1 then
      flare_type := 0;      // 213a bent flares

    if retain_shoves_on_mint = False then
      clear_shovedata;  // 0.94.a mods

    if retain_diffs_on_mint = False then
      clear_check_diffs; // 0.94.a clear any check rail diffs

    if retain_entry_straight_on_mint = False then
      entry_straight_code := 0;  // 213a  re-set auto fit straight.

    do_rollback := False;

    if locked_length = 0  // length free
    then begin
      if plain_track = False then begin
        xorg := 0;         // remove any aproach track;
        turnout_i := 0;    // 0=length free. default overall turnout length.
      end
      else begin
        //xorg:=2.5*railen[pt_i]*inscale;    // give him 2.5 rail lengths (arbitrary).
        xorg := 132 * scale;
        // give him 2 chains (arbitrary). 0.93.a
        turnoutx := xorg;
        turnout_i := 1;        // length always locked at turnoutx for plain track.
      end;
    end
    else
      turnout_i := 1;        // 1 = length locked at turnoutx. xorg unchanged.   // 208 mods

    reset_peg_menu_entry.Click;  // Ctrl-0 position.

    turnout_road_i := 0;     // standard length.
    main_road_i := 0;        // 217a

    xing_type_i := 0;        // regular crossing (normal)...

    retpar_i := 0;           // no return curve.

    gaunt := False;  // 0.93.a

    cpi.random_end_pi := 0;            // no end randomizing.
    cpi.random_angle_pi := 0;          // equalizing angle not randomised.
    random_flag := False;              // and randomising turned off anyway.

    snap_exit_to_return_curve_menu_entry.Enabled := False;

    cl_options_code := 0;              // 214a    normal centre-line
    cl_options_custom_offset := 0;     // 214a

    curviform_timbering := False;   // 215a

    gocalc(0, 0);                                      // get turnoutx

    clear_transform_data;         // do this last (routines above do a peg_curve),

    copied_ref_str := current_name_str;

    clear_current_name;
    current_memo_str := ' your memo notes for this template ...|';  // 5-08-01.


    do_rollback := False;
    if on_datum = True then begin
      xshift := 0;                  // cancel any shifts.
      yshift := 0;
      gocalc(2, 0);                            // need screen calcs to set y_datum.
      set_y_datum;                            // in case RH.
      fit_current_only_menu_entry.Click;
      // 0.93.a     //fit_org_extents_current_menu_entry.Click;    // zoom to fit on datum.
    end
    else begin
      xshift := zoom_offsetx + (screenx - turnoutx) / 2;
      // or put it across the centre of the pad,
      yshift := (zoom_offsety + screeny / 2.5 - y_datum) * hand_i - g / 2;
      // 0.93.a was /2.0  // and on main centre-line (if straight turnout).
    end;

    xshift_quickset := xshift;  // 0.93.a   save these for quick-set store check next time
    yshift_quickset := yshift;  // 0.93.a

    show_and_redraw(True, False);   // in case curent hidden.

    do_rollback := False;

    if plain_track = True then begin
      redraw(False);                              // force sleeper calcs.
      snap_approach_to_nearest_menu_entry.Click;  // to nearest sleeper.
    end;

  end;//with pad_form

  if (csi.group_code = 2) and (plain_track = False)
  // REA switch, so re-set REA bullhead crossing...
  then begin
    bn_wide := 0.75;      // full-size inches.  3/4" blunt nose BH default.
    bn_to_a := 4.0;       // full-size inches - 4" to A timber centre.
    wingj_sp := 25;       // full-size inches - 25" timber spacing at wing rail joint.
    mvj_sp := 12.5;       // full-size inches - 12.5" spacing to vee point rail joint.

    wingtimb_sp := 30;
    // full-size inches - 30" timber spacing for wing rail front part of crossing (up to "A").
    veetimb_sp := 30;
    // full-size inches - 30" timber spacing for vee point rail part of crossing (on from "A").

    hd_vcheck_rails := 0;   // no shortening of check rails for slips.
    hd_timbers := 0;        // no extending of timbers for slips.

    // number of timbers spanned by vee rail including the "A" timber...

    vee_spco1 := 4;  // less than 1:4         // these are byte values...
    vee_spco2 := 5;  // up to 1:6.3/4
    vee_spco3 := 6;  // up to 1:10
    vee_spco4 := 7;  // up to 1:15
    vee_spco5 := 8;  // up to 1:20
    vee_spco6 := 9;  // over 1:20 improvised.

    // number of timbers spanned by wing rail front from joint but excluding the "A" timber...

    wing_spco1 := 2;    // less than 1:4
    wing_spco2 := 3;    // up to 1:6.3/4
    wing_spco3 := 3;    // up to 1:10
    wing_spco4 := 4;    // up to 1:15
    wing_spco5 := 5;    // up to 1:20
    wing_spco6 := 6;    // over 1:20

    // restore default REA check rails...

    with cpi do begin

      ck_ms_working1_pi := def_req;
      // full-size  78 inches - size 1 MS check rail working length (back from "A").
      ck_ms_working2_pi := def_req;
      // full-size 108 inches - size 2 MS check rail working length (back from "A").
      ck_ms_working3_pi := def_req;
      // full-size 138 inches - size 3 MS check rail working length (back from "A").

      // 0.94.a no longer used, mouse diffs instead.  ck_ts_working_mod_pi:=def_req;   // full-size 0 inches - TS check rail working length modifier.

      ck_ms_ext1_pi := def_req;
      // full-size 48 inches - size 1 MS check rail extension length (forward from "A").
      ck_ms_ext2_pi := def_req;
      // full-size 78 inches - size 2 MS check rail extension length (forward from "A").

      // 0.94.a no longer used, mouse diffs instead.  ck_ts_ext_mod_pi:=def_req;   // full-size 0 inches - TS check rail extension length modifier.

      wing_ms_reach1_pi := def_req;
      // short wing rails 48" default from centre of "A" timber.
      wing_ms_reach2_pi := def_req;
      // long wing rails 78" default from centre of "A" timber.

      // 0.94.a no longer used, mouse diffs instead.  wing_ts_reach_mod_pi:=def_req; // full-size 0 inches - TS wing rail reach length modifier.

    end;//with
  end;

  turnout_road_stock_rail_flag := True;
  turnout_road_check_rail_flag := True;
  turnout_road_crossing_rail_flag := True;
  crossing_vee_flag := True;
  main_road_crossing_rail_flag := True;
  main_road_check_rail_flag := True;
  main_road_stock_rail_flag := True;

  k_main_side_check_rail_flag := True;      // 0.93.a
  k_diagonal_side_check_rail_flag := True;  // 0.93.a

  // joint switches 0.79.a ...    19-05-06

  omit_swfj_marks := False;
  omit_swrj_marks := False;
  omit_skj_marks := False;
  omit_wj_marks := False;
  omit_vj_marks := False;
  omit_kx_marks := False;


  adjacent_edges := True;
  // 0.93.a   False=adjacent tracks,  True=trackbed edges and platform edges.

  // trackbed ...

  //trackbed_width_ins_old:=180;       // 0.82.d   180 inches full-size 15ft.      out of use 215a

  trackbed_ms_width_ins := 90;     // 215a
  trackbed_ts_width_ins := 90;     // 215a

  draw_ms_trackbed_edge := False;
  draw_ts_trackbed_edge := False;

  //cess_width_ins_old:=30;                     // 206a   out of use 215a

  cess_ms_width_ins := 27;       // 215a
  cess_ts_width_ins := 27;       // 215a

  //draw_trackbed_cess_edge_old:=False;         // 206a   out of use 215a

  draw_ms_trackbed_cess_edge := False;     // 215a
  draw_ts_trackbed_cess_edge := False;     // 215a

  // platforms ...

  platform_ms_front_edge_ins := 57;  // 215a
  platform_ts_front_edge_ins := 57;

  platform_ms_start_width_ins := 144;    // 12ft default
  platform_ms_end_width_ins := 144;      // 12ft default

  platform_ts_start_width_ins := 144;    // 12ft default
  platform_ts_end_width_ins := 144;      // 12ft default

  platform_ms_start_mm := 0;
  platform_ms_length_mm := def_req;

  platform_ts_start_mm := 0;
  platform_ts_length_mm := def_req;


  platform_ms_start_skew_mm := 0;      // 207a
  platform_ms_end_skew_mm := 0;        // 207a

  platform_ts_start_skew_mm := 0;      // 207a
  platform_ts_end_skew_mm := 0;        // 207a


  draw_ms_platform := False;

  draw_ms_platform_rear_edge := True;
  draw_ms_platform_start_edge := True;
  draw_ms_platform_end_edge := True;

  draw_ts_platform := False;

  draw_ts_platform_rear_edge := True;
  draw_ts_platform_start_edge := True;
  draw_ts_platform_end_edge := True;

  railedges(gauge_faces, outer_edges, centre_lines);

  redraw_pad(True, True);
end;
//________________________________________________________________________________________

procedure adjust_direct(code: integer);

begin
  cancel_adjusts(False);
  with pad_form do begin

    case code of
      0:
        lock_scaling_at_menu_entry.Click;   //if spot_mod=1
      1:
        lock_scaling_at_menu_entry.Click;   //if zoom_mod=1
      2:
        set_datum_menu_entry.Click;         //if datum_mod=1
      3:
        set_peg_menu_entry.Click;           //if peg_mod=1
      4:
        set_notch_menu_entry.Click;         //if notch_mod=1
      5:
        set_output_size_menu_entry.Click;   //if out_factor_mod=1

      6:
        shove_xtb_panel_click;      // shove_timber_form.data_button.Click;  //if shove_along_mod=1
      7:
        shove_throw_panel_click;    //shove_timber_form.data_button.Click;   //if shove_throw_mod=1

      8:
        curving_data_menu_entry.Click;        //if trans_length_mod=1
      9:
        curving_data_menu_entry.Click;        //if trans_start_mod=1

      10:
        slewing_data_menu_entry.Click;      //if slew_amount_mod=1
      11:
        slewing_data_menu_entry.Click;      //if slew_length_mod=1
      12:
        slewing_data_menu_entry.Click;      //if slew_start_mod=1

      13:
        lengths_mm_menu_entry.Click;        //if length_mod=1
      14:
        lengths_mm_menu_entry.Click;        //if approach_mod=1

      15:
        transform_data_menu_entry.Click;    //if shift_mod=1
      16:
        set_peg_menu_entry.Click;           //if slide_mod=1
      17:
        get_ring_location;                  //if ring_mod=1

      18:
        enter_shift_keeps_menu_entry.Click;    //if shift_keeps_mod=1
      19:
        enter_rotation_keeps_menu_entry.Click; //if twist_keeps_mod=1

      20:
        lock_scaling_at_menu_entry.Click;      //if zoffset_mod=1
      21:
        transform_data_menu_entry.Click;       //if twist_mod=1
      22:
        transform_data_menu_entry.Click;       //if orbit_mod=1
      23:
        curving_data_menu_entry.Click;         //if both_mod=1
      24:
        crossing_menu_entry.Click;             //if sx_mod=1
      25:
        curving_data_menu_entry.Click;         //if curving_mod=1
      26:
        lengths_mm_menu_entry.Click;           //if roam_mod=1

      27:
        slewing_data_menu_entry.Click;         //if slew_factor_mod=1
      28:
        EXIT;                                  //if bunch_mod=1
      29:
        set_print_origin_menu_entry.Click;     //if porg_mod=1

      30:
        bgnd_form.modify_button.Click;         //if corner1_mod=1
      31:
        bgnd_form.modify_button.Click;         //if corner2_mod=1
      32:
        bgnd_form.shift_one_to_button.Click;   //if oneshape_shift_mod=1
      33:
        bgnd_form.shift_all_by_button.Click;   //if allshapes_shift_mod=1

      34:
        set_peg_menu_entry.Click;              //if snake_mod=1

      35:
        bgnd_form.scale_all_by_button.Click;   //if allshapes_scale_mod=1
      36:
        bgnd_form.rotate_all_by_button.Click;  //if allshapes_rotate_mod=1

      37:
        bgnd_form.scale_one_to_button.Click;   //if oneshape_scale_mod=1

      38:
        shove_length_panel_click;  // shove_timber_form.data_button.Click;  //if shove_length_mod=1
      39:
        shove_width_panel_click;   // shove_timber_form.data_button.Click;  //if shove_width_mod=1
      40:
        shove_twist_panel_click;   // shove_timber_form.data_button.Click;  //if shove_twist_mod=1

      41:
        lengths_mm_menu_entry.Click;          //if blanking_mod=1

      42:
        roll_rails_by_menu_entry.Click;       //if roll_mod=1

      43:
        get_ring_size;                        //if ringdia_mod=1

      44, 45:
        set_ruler_ends_menu_entry.Click;      //if ruler1_mod=1 or ruler2_mod=1

      46:
        curving_data_menu_entry.Click;        //if swell_mod=1

      47:
        shove_crab_panel_click;               // if shove_crab_mod=1

      48:
        background_template_detail_menu_entry.Click;    // if move_labels_mod=1    // 0.82.d

      49:
        crossing_menu_entry.Click;            // if entry_straight_mod=1    // 0.91.b

      // 0.93.a platforms ...

      50:
        platform_form.ts_position_button.Click;
      // if plat_ts_start_mod=1   then repeat_last_index:=50;
      51:
        platform_form.ts_position_button.Click;
      // if plat_ts_end_mod=1     then repeat_last_index:=51;
      52:
        platform_form.ts_width_button.Click;
      // if plat_ts_width1_mod=1  then repeat_last_index:=52;
      53:
        platform_form.ts_width_button.Click;
      // if plat_ts_width2_mod=1  then repeat_last_index:=53;

      54:
        platform_form.ms_position_button.Click;
      // if plat_ms_start_mod=1   then repeat_last_index:=54;
      55:
        platform_form.ms_position_button.Click;
      // if plat_ms_end_mod=1     then repeat_last_index:=55;
      56:
        platform_form.ms_width_button.Click;
      // if plat_ms_width1_mod=1  then repeat_last_index:=56;
      57:
        platform_form.ms_width_button.Click;
      // if plat_ms_width2_mod=1  then repeat_last_index:=57;


      58:
        gaunt_offset_menu_entry.Click;     //  gaunt_offset_mod SHIFT+F12  // 0.93.a ex 081
      59:
        crossing_menu_entry.Click;         //  vee_mod F9                  // 0.93.a ex 081
      60:
        k_crossing_angle_menu_entry.Click; //  hdk_mod F10                 // 0.93.a ex 081

      61, 62, 63, 64, 65:
        set_boundary_rectangle_dims(pad_form);  // rect_left_mod etc.    // 0.93.a

      66, 67, 68:
        check_diffs_form.data_button.Click;
      // if check_diffs_len_mod=1 etc.  check rail diffs // 0.94.a

      69, 70:
        grid_form.dummy_vehicle_dimensions_button.Click;
      //  dv_mod, dv_clear_mod  dummy vehicle 0.98.a

      71, 72:
        platform_form.ms_position_button.Click;
      //  if plat_ms_skew1_mod=1 then repeat_last_index:=71;    // 207a
      //  if plat_ms_skew2_mod=1 then repeat_last_index:=72;    // 207a
      73, 74:
        platform_form.ts_position_button.Click;
      //  if plat_ts_skew1_mod=1 then repeat_last_index:=73;    // 207a
      //  if plat_ts_skew2_mod=1 then repeat_last_index:=74;    // 207a

      75, 82:
        lengths_mm_menu_entry.Click;
      //  if turnout_road_mod=1  or  main_road_mod=1    // 209a  217a

      76, 77:
        adjacent_centres_menu_entry.Click;
      // if adjacent_ts_mod=1   adjacent_ms_mod=1    // 213a

      // trackbed edges 215a ...

      78, 79:
        trackbed_form.ts_position_button.Click;       // edge_ts_start_mod    edge_ts_length_mod
      80, 81:
        trackbed_form.ms_position_button.Click;       // edge_ms_start_mod    edge_ms_length_mod

      // 82 see 75

      83:
        gaunt_radius_menu_entry.Click;     //  gaunt_radius_mod   217b

    end;//case
  end;//with
end;
//__________________________________________________________________________________________

procedure action_label_click;

// cancel adjusts and go adjust dimension by direct entry...
begin
  if spot_mod = 1 then begin
    adjust_direct(0);
    EXIT;
  end;
  if zoom_mod = 1 then begin
    adjust_direct(1);
    EXIT;
  end;
  if datum_mod = 1 then begin
    adjust_direct(2);
    EXIT;
  end;
  if peg_mod = 1 then begin
    adjust_direct(3);
    EXIT;
  end;
  if notch_mod = 1 then begin
    adjust_direct(4);
    EXIT;
  end;
  if out_factor_mod = 1 then begin
    adjust_direct(5);
    EXIT;
  end;
  if shove_along_mod = 1 then begin
    adjust_direct(6);
    EXIT;
  end;
  if shove_throw_mod = 1 then begin
    adjust_direct(7);
    EXIT;
  end;
  if trans_length_mod = 1 then begin
    adjust_direct(8);
    EXIT;
  end;
  if trans_start_mod = 1 then begin
    adjust_direct(9);
    EXIT;
  end;
  if slew_amount_mod = 1 then begin
    adjust_direct(10);
    EXIT;
  end;
  if slew_length_mod = 1 then begin
    adjust_direct(11);
    EXIT;
  end;
  if slew_start_mod = 1 then begin
    adjust_direct(12);
    EXIT;
  end;
  if length_mod = 1 then begin
    adjust_direct(13);
    EXIT;
  end;
  if approach_mod = 1 then begin
    adjust_direct(14);
    EXIT;
  end;
  if shift_mod = 1 then begin
    adjust_direct(15);
    EXIT;
  end;
  if slide_mod = 1 then begin
    adjust_direct(16);
    EXIT;
  end;
  if ring_mod = 1 then begin
    adjust_direct(17);
    EXIT;
  end;
  if shift_keeps_mod = 1 then begin
    adjust_direct(18);
    EXIT;
  end;
  if twist_keeps_mod = 1 then begin
    adjust_direct(19);
    EXIT;
  end;
  if zoffset_mod = 1 then begin
    adjust_direct(20);
    EXIT;
  end;
  if twist_mod = 1 then begin
    adjust_direct(21);
    EXIT;
  end;
  if orbit_mod = 1 then begin
    adjust_direct(22);
    EXIT;
  end;
  if both_mod = 1 then begin
    adjust_direct(23);
    EXIT;
  end;
  if sx_mod = 1 then begin
    adjust_direct(24);
    EXIT;
  end;
  if curving_mod = 1 then begin
    adjust_direct(25);
    EXIT;
  end;
  if roam_mod = 1 then begin
    adjust_direct(26);
    EXIT;
  end;
  if slew_factor_mod = 1 then begin
    adjust_direct(27);
    EXIT;
  end;
  if bunch_mod = 1 then begin
    adjust_direct(28);
    EXIT;
  end;
  if porg_mod = 1 then begin
    adjust_direct(29);
    EXIT;
  end;

  if corner1_mod = 1 then begin
    adjust_direct(30);
    EXIT;
  end;
  if corner2_mod = 1 then begin
    adjust_direct(31);
    EXIT;
  end;

  if oneshape_shift_mod = 1 then begin
    adjust_direct(32);
    EXIT;
  end;
  if allshapes_shift_mod = 1 then begin
    adjust_direct(33);
    EXIT;
  end;

  if snake_mod = 1 then begin
    adjust_direct(34);
    EXIT;
  end;

  if allshapes_scale_mod = 1 then begin
    adjust_direct(35);
    EXIT;
  end;
  if allshapes_rotate_mod = 1 then begin
    adjust_direct(36);
    EXIT;
  end;
  if oneshape_scale_mod = 1 then begin
    adjust_direct(37);
    EXIT;
  end;

  if shove_length_mod = 1 then begin
    adjust_direct(38);
    EXIT;
  end;
  if shove_width_mod = 1 then begin
    adjust_direct(39);
    EXIT;
  end;
  if shove_twist_mod = 1 then begin
    adjust_direct(40);
    EXIT;
  end;

  if blanking_mod = 1 then begin
    adjust_direct(41);
    EXIT;
  end;

  if roll_mod = 1 then begin
    adjust_direct(42);
    EXIT;
  end;

  if ringdia_mod = 1 then begin
    adjust_direct(43);
    EXIT;
  end;

  if ruler1_mod = 1 then begin
    adjust_direct(44);
    EXIT;
  end;
  if ruler2_mod = 1 then begin
    adjust_direct(45);
    EXIT;
  end;

  if swell_mod = 1 then begin
    adjust_direct(46);
    EXIT;
  end;

  if shove_crab_mod = 1 then begin
    adjust_direct(47);
    EXIT;
  end;

  if move_labels_mod = 1 then begin
    adjust_direct(48);
    EXIT;
  end;  // 0.82.d

  if entry_straight_mod = 1 then begin
    adjust_direct(49);
    EXIT;
  end;  // 0.91.b

  // 0.93.a ...

  if plat_ts_start_mod = 1 then begin
    adjust_direct(50);
    EXIT;
  end;
  if plat_ts_length_mod = 1 then begin
    adjust_direct(51);
    EXIT;
  end;
  if plat_ts_width1_mod = 1 then begin
    adjust_direct(52);
    EXIT;
  end;
  if plat_ts_width2_mod = 1 then begin
    adjust_direct(53);
    EXIT;
  end;

  if plat_ms_start_mod = 1 then begin
    adjust_direct(54);
    EXIT;
  end;
  if plat_ms_length_mod = 1 then begin
    adjust_direct(55);
    EXIT;
  end;
  if plat_ms_width1_mod = 1 then begin
    adjust_direct(56);
    EXIT;
  end;
  if plat_ms_width2_mod = 1 then begin
    adjust_direct(57);
    EXIT;
  end;

  if gaunt_offset_mod = 1 then begin
    adjust_direct(58);
    EXIT;
  end;  // SHIFT+F12  // 0.93.a ex 081
  if vee_mod = 1 then begin
    adjust_direct(59);
    EXIT;
  end;  // F9         // 0.93.a ex 081
  if hdk_mod = 1 then begin
    adjust_direct(60);
    EXIT;
  end;  // F10        // 0.93.a ex 081

  if rect_left_mod = 1 then begin
    adjust_direct(61);
    EXIT;
  end;  // output boundary rectangle 0.93.a ...
  if rect_right_mod = 1 then begin
    adjust_direct(62);
    EXIT;
  end;
  if rect_top_mod = 1 then begin
    adjust_direct(63);
    EXIT;
  end;
  if rect_bottom_mod = 1 then begin
    adjust_direct(64);
    EXIT;
  end;
  if rect_move_mod = 1 then begin
    adjust_direct(65);
    EXIT;
  end;

  if check_diffs_len_mod = 1 then begin
    adjust_direct(66);
    EXIT;
  end;    // 0.94.a  mouse check rails
  if check_diffs_flare_mod = 1 then begin
    adjust_direct(67);
    EXIT;
  end;    // 0.94.a
  if check_diffs_gap_mod = 1 then begin
    adjust_direct(68);
    EXIT;
  end;    // 0.94.a

  if dv_mod = 1 then begin
    adjust_direct(69);
    EXIT;
  end;    // 0.98.a
  if dv_clear_mod = 1 then begin
    adjust_direct(70);
    EXIT;
  end;    // 0.98.a

  if plat_ms_skew1_mod = 1 then begin
    adjust_direct(71);
    EXIT;
  end;    // 207a
  if plat_ms_skew2_mod = 1 then begin
    adjust_direct(72);
    EXIT;
  end;    // 207a
  if plat_ts_skew1_mod = 1 then begin
    adjust_direct(73);
    EXIT;
  end;    // 207a
  if plat_ts_skew2_mod = 1 then begin
    adjust_direct(74);
    EXIT;
  end;    // 207a

  if turnout_road_mod = 1 then begin
    adjust_direct(75);
    EXIT;
  end;    // 209a

  if adjacent_ts_mod = 1 then begin
    adjust_direct(76);
    EXIT;
  end;    // 213a
  if adjacent_ms_mod = 1 then begin
    adjust_direct(77);
    EXIT;
  end;    // 213a

  if edge_ts_start_mod = 1 then begin
    adjust_direct(78);
    EXIT;
  end;    // 215a ...
  if edge_ts_length_mod = 1 then begin
    adjust_direct(79);
    EXIT;
  end;

  if edge_ms_start_mod = 1 then begin
    adjust_direct(80);
    EXIT;
  end;
  if edge_ms_length_mod = 1 then begin
    adjust_direct(81);
    EXIT;
  end;

  if main_road_mod = 1 then begin
    adjust_direct(82);
    EXIT;
  end;    // 217a

  if gaunt_radius_mod = 1 then begin
    adjust_direct(83);
    EXIT;
  end;    // 217b

end;
//______________________________________________________________________________

procedure update_rail_section(var box_kd: Tkeep_dims);
// update stored rail-section data to match the control template.

// 0.94.a

begin
  with box_kd.box_dims1 do begin
    rail_info.flared_ends_ri := flare_type;  // 0=straight bent, 1=straight machined

    rail_info.knuckle_code_ri := knuckle_code;
    // 214a  integer;   0=normal, -1=sharp, 1=use knuckle_radius_ri
    rail_info.knuckle_radius_ri := knuckle_radius;   // 214a  extended;

    rail_type := rail_section;               // rail head only or head+foot(BH/FB).
    uninclined_rails := vertical_rails;      // True = rails vertical.

    proto_info.railtop_pi := cpi.railtop_pi;
    proto_info.railbottom_pi := cpi.railbottom_pi;
    proto_info.rail_height_pi := cpi.rail_height_pi;
    proto_info.rail_inclination_pi := cpi.rail_inclination_pi;
    proto_info.foot_height_pi := cpi.foot_height_pi;

  end;//with
end;
//______________________________________________________________________________

procedure update_centre_lines(var box_kd: Tkeep_dims);
// update stored track centre-line settings to match the control template.

// 0.93.a

begin
  box_kd.box_dims1.rail_info.track_centre_lines_sw := track_centre_lines_flag;
  box_kd.box_dims1.align_info.cl_only_flag := cl_only;
  box_kd.box_dims1.align_info.dummy_template_flag := dummy_template;   // 212a
end;
//______________________________________________________________________________

procedure update_centre_line_offset_options(var box_kd: Tkeep_dims);
// update stored centre-line offset options to match the control template.

// 214a

begin
  box_kd.box_dims1.align_info.cl_options_code_int := cl_options_code;
  box_kd.box_dims1.align_info.cl_options_custom_offset_ext := cl_options_custom_offset;
end;
//______________________________________________________________________________

procedure update_radius_warning(var box_kd: Tkeep_dims);
// update stored radius warning limit to match the control template.

// 206e
begin
  box_kd.box_dims1.proto_info.min_radius_pi := min_radius;
end;
//______________________________________________________________________________

procedure update_trackbed_edges(var box_kd: Tkeep_dims);
// update stored trackbed edges settings to match the control template.

// 0.93.a

begin
  with box_kd.box_dims1.platform_trackbed_info do begin

    adjacent_edges_keep := True;
    // False=adjacent tracks,  True=trackbed edges and platform edges.

    draw_ms_trackbed_edge_keep := draw_ms_trackbed_edge;
    draw_ts_trackbed_edge_keep := draw_ts_trackbed_edge;

    trackbed_ms_width_ins_keep := trackbed_ms_width_ins;    // 215a
    trackbed_ts_width_ins_keep := trackbed_ts_width_ins;    // 215a

    cess_ms_width_ins_keep := cess_ms_width_ins;     // 215a
    cess_ts_width_ins_keep := cess_ts_width_ins;     // 215a

    draw_ms_trackbed_cess_edge_keep := draw_ms_trackbed_cess_edge;   // 215a
    draw_ts_trackbed_cess_edge_keep := draw_ts_trackbed_cess_edge;   // 215a

    trackbed_ts_start_mm := 0;          // 215a
    trackbed_ts_length_mm := def_req;   // 215a

    trackbed_ms_start_mm := 0;          // 215a
    trackbed_ms_length_mm := def_req;   // 215a

  end;//with
end;
//______________________________________________________________________________

procedure update_customize_xing(var box_kd: Tkeep_dims);   // 214b  update V-crossing customizing

begin

  with box_kd.turnout_info2.crossing_info do begin

    blunt_nose_width := bn_wide;         // full-size inches.
    blunt_nose_to_timb := bn_to_a;       // full-size inches - to A timber centre.

    vee_timber_spacing := veetimb_sp;
    // full-size inches - timber spacing for vee point rail part of crossing (on from "A").
    wing_timber_spacing := wingtimb_sp;
    // full-size inches - timber spacing for wing rail front part of crossing (up to "A").

    vee_joint_half_spacing := mvj_sp;
    // full-size inches - rail overlap at vee point rail joint.
    wing_joint_spacing := wingj_sp;      // full-size inches - timber spacing at wing rail joint.

    // number of timbers spanned by vee rail incl. "A" timber...

    vee_joint_space_co1 := vee_spco1;
    vee_joint_space_co2 := vee_spco2;
    vee_joint_space_co3 := vee_spco3;
    vee_joint_space_co4 := vee_spco4;
    vee_joint_space_co5 := vee_spco5;
    vee_joint_space_co6 := vee_spco6;

    // number of timbers spanned by wing rail front excl. "A" timber...

    wing_joint_space_co1 := wing_spco1;
    wing_joint_space_co2 := wing_spco2;
    wing_joint_space_co3 := wing_spco3;
    wing_joint_space_co4 := wing_spco4;
    wing_joint_space_co5 := wing_spco5;
    wing_joint_space_co6 := wing_spco6;

  end;//with

  with box_kd.box_dims1 do begin     // check and wing rails...

    proto_info.wing_ms_reach1_pi := cpi.wing_ms_reach1_pi;
    proto_info.wing_ms_reach2_pi := cpi.wing_ms_reach2_pi;

    proto_info.ck_ms_working1_pi := cpi.ck_ms_working1_pi;
    proto_info.ck_ms_working2_pi := cpi.ck_ms_working2_pi;
    proto_info.ck_ms_working3_pi := cpi.ck_ms_working3_pi;

    proto_info.ck_ms_ext1_pi := cpi.ck_ms_ext1_pi;
    proto_info.ck_ms_ext2_pi := cpi.ck_ms_ext2_pi;

    proto_info.xing_fl_pi := cpi.xing_fl_pi;

  end;//with
end;
//______________________________________________________________________________

procedure update_lengths(var box_kd: Tkeep_dims);
// update stored template timbering and plain track settings to match the control template.

// split from update_timbering  214c

var
  n: integer;

begin
  with box_kd.turnout_info2.plain_track_info do begin

    if pt_i > 4 then
      pt_custom := True       // list index for custom plain track.
    else
      pt_custom := False;

    list_index := pt_i;
    rail_length := railen[pt_i];
    // rail length in inches (only used for custom lengths).
    sleepers_per_length := sleeper_count[pt_i];
    // number of sleepers per length.
    for n := 0 to psleep_c do
      sleeper_centres[n] := psleep[pt_i, n];   // spacings (only used for custom spacings).

    pt_spacing_name_str := Copy(plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i],
      1, 198);
    // get name from the list.

    rail_joints_code := rjcode;  // 0=normal, 1=staggered, -1=none (cwr).

  end;//with
end;
//______________________________________________________________________________

procedure update_timbering(var box_kd: Tkeep_dims);
// update stored template timbering to match the control template.

begin
  with box_kd do begin

    with turnout_info2 do begin

      timber_length_inc := timbinc;                          // length increments  212a
      diamond_proto_timbering_flag := hd_proto_timbering;    // 212a

      diamond_switch_timbering_flag := hd_switch_timbering;  // 213a

      equalizing_fixed_flag := equalizing_fixed;
      // {spare_flag1:boolean;}  equalizing style 1-4-00
      no_timbering_flag := no_timbering;                  // {spare_flag2:boolean;}  7-9-00
      angled_on_flag := square_on_angled;                 // True = angled-on timbering; 29-7-01

      crossing_info.curviform_timbering_keep := curviform_timbering;   // 215a

    end;//with

    with box_dims1 do begin

      proto_info.tbwide_pi := tbwide;           // inches full-size width of turnout timbers.
      proto_info.slwide_pi := slwide;           // inches full-size width of plain sleepers.

      proto_info.jt_slwide_pi := jt_slwide;     // inches full-size width of joint sleepers. 212a

      proto_info.ftimbspmax_pi := ftimbspmax;
      // inches full-size max timber-spacing for closure space.
      proto_info.tb_pi := tb;                   // plain sleepers length.

      proto_info.mainside_ends_pi := ms_ends;
      //  True=main side ends in line, False=ends centralized.
      proto_info.random_end_pi := randend;       //  amount of timber-end randomising.
      proto_info.random_angle_pi := randangle;   //  amount of timber_angle randomising.

      with turnout_info1 do begin

        timbering_flag := timbers_equalized;  //  True = equalized timbering.
        exit_timbering := exittb_i;           //  exit timbering style.

        front_timbers_flag := include_front_timbers;      //  218a
        switch_timbers_flag := include_switch_timbers;    //  218a
        closure_timbers_flag := include_closure_timbers;  //  218a
        xing_timbers_flag := include_xing_timbers;        //  218a

        approach_rails_only_flag := approach_rails_only;  // 218a

      end;//with

      //proto_info.xtimbsp_pi:=xtimbsp;       // !!! disused in 0.75.a 14-10-01. inches full-size timber-spacing at crossing.

      // for use in files when reloaded by versions prior to 0.75.a..

      proto_info.xtimbsp_pi := (veetimb_sp + wingtimb_sp) / 2;
      // full-size inches - timber spacing for crossing.

    end;//with
  end;//with
end;
//___________________________________________________________________________________________

function shove_number_clicked(X, Y: integer): boolean;
  // screen co-ords of a click, is it on a timber number?

var
  i, n: integer;
  code: EMarkCode;
  ptr_1st: ^Tmark;         // pointer to a Tmark record..
  markmax: integer;
  num_str, tbnum_str: string;
  num_X, num_Y, half_width, half_height: integer;

begin

  Result := False;   // 0.91.c  init.

  with enter_timber_form.Canvas do begin
    Font.Assign(pad_form.pad_timber_font_label.Font);

    // 0.91.b was Screen.Width ..

    if pad_form.ClientWidth > 1000 then
      half_width := TextWidth('MM') div 2
    // (=10 for default font) clicking area (arbitrary - bitmap fonts).
    else
      half_width := TextWidth('FF') div 2;   // (=7 for ditto).

    half_height := TextHeight('A') div 2;
  end;//with

  // find number string clicked on in control template marks list...

  if marks_list_ptr = nil then
    EXIT;        // pointer to marks list not valid.

  markmax := High(marks_list_ptr);  // max index for the present list.

  if mark_index > markmax then
    mark_index := markmax;  // ??? shouldn't be.

  tbnum_str := timb_numbers_str;
  // the full string of timber numbering for the control template.

  for i := 0 to (mark_index - 1) do begin     // (mark_index is always the next free slot)
    try
      ptr_1st := @marks_list_ptr[i];  // pointer to the next Tmark record.
      if ptr_1st = nil then
        EXIT;

      code := ptr_1st^.code;

      if code <> eMC_99_TimberNumber then
        CONTINUE;   // we are only looking for timber number entries.

      num_str := extract_tbnumber_str(tbnum_str);
      // get next timber numbering string from the acummulated string.
      if num_str = '' then
        CONTINUE;                // no string available??

      num_X := Round(ptr_1st^.p1.X * sx + ex - gx);       // and the centre co-ords for it.
      num_Y := Round((ptr_1st^.p1.Y + yd) * sy + by - gy);

      if (X >= (num_X - half_width)) and (X <= (num_X + half_width)) and
        (Y >= (num_Y - half_height)) and (Y <= (num_Y + half_height)) then begin

        Result := True;   // 0.91.c  clicked on a timber number.

        highlighted_timbnum_str := '';       // prevent de-highlighting of this one.

        num_str := timb_num_strip(num_str);
        if num_str = current_shove_str then
          EXIT;       // not if already on it.

        current_shove_str := num_str;

        n := find_shove(current_shove_str, True);
        // find it or an empty slot, or warn him if no room.
        if n >= 0                                // found a slot.
        then begin
          if current_shove_list[n].sv_code = svcEmpty then begin
            current_shove_list[n].sv_code := svcShove;
            // flag to shove this timber if not already in list.
          end;
          shove_buttons(True, n);
        end
        else begin
          current_shove_str := '';         // !!! no room for it ?
          shove_buttons(False, -1);
        end;
        redraw(True);
        EXIT;
      end;
    except
      CONTINUE;
    end;//try

  end;//next i timber number
end;
//____________________________________________________________________________________________

procedure mouse_on_timber_number(X, Y: integer);
// highlight timber number if mouse currently over it.

var
  i: integer;
  code: EMarkCode;
  ptr_1st: ^Tmark;         // pointer to a Tmark record..
  markmax: integer;
  num_str, tbnum_str: string;
  num_x, num_y: double;
  int_num_X, int_num_Y: integer;
  half_width, half_height: integer;
  move_to: TPoint;
  half_stringwidth, half_stringheight: integer;

  dummy_i: integer;

begin

  with enter_timber_form.Canvas do begin
    Font.Assign(pad_form.pad_timber_font_label.Font);

    // 0.91.b was Screen.Width

    if pad_form.ClientWidth > 1000 then
      half_width := TextWidth('MM') div 2
    // (=10 for default font) clicking area (arbitrary - bitmap fonts).
    else
      half_width := TextWidth('FF') div 2;   // (=7 for ditto).

    half_height := TextHeight('A') div 2;
  end;//with


  if marks_list_ptr = nil then
    EXIT;        // pointer to marks list not valid.

  markmax := High(marks_list_ptr);  // max index for the present list.

  if mark_index > markmax then
    mark_index := markmax;  // ??? shouldn't be.

  tbnum_str := timb_numbers_str;
  // the full string of timber numbering for the control template.

  for i := 0 to (mark_index - 1) do begin     // (mark_index is always the next free slot)
    try
      ptr_1st := @marks_list_ptr[i];  // pointer to the next Tmark record.
      if ptr_1st = nil then
        EXIT;

      code := ptr_1st^.code;

      if code <> eMC_99_TimberNumber then
        CONTINUE;   // we are only looking for timber number entries.

      num_str := extract_tbnumber_str(tbnum_str);
      // get next timber numbering string from the acummulated string.
      if num_str = '' then
        CONTINUE;                // no string available??

      num_x := ptr_1st^.p1.X * sx + ex - gx;       // and the centre co-ords for it.
      num_y := (ptr_1st^.p1.Y + yd) * sy + by - gy;

      int_num_X := Round(num_x);
      int_num_Y := Round(num_y);

      if (X >= (int_num_X - half_width)) and (X <= (int_num_X + half_width)) and
        (Y >= (int_num_Y - half_height)) and (Y <= (int_num_Y + half_height)) then begin

        if timb_num_strip(num_str) = current_shove_str then
          EXIT;  // do nothing if over the currently selected timber number.

        move_to.X := Round(limits(h_minint, h_maxint, num_x, dummy_i));
        move_to.Y := Round(limits(h_minint, h_maxint, num_y, dummy_i));

        if check_limit(True, True, move_to) = True then begin
          if num_str[1] = '!'               // it's an omitted timber
          then
            Delete(num_str, 1, 1);    // remove the omit indicator.

          with pad_form.Canvas do begin     // direct overdraw.

            Font.Assign(pad_form.pad_timber_font_label.Font);

            if (highlighted_timbnum_str <> '') and (highlighted_timbnum_str <> num_str) and
              (timb_num_strip(highlighted_timbnum_str) <> current_shove_str)
            // first de-highlight any previous number (but not this one)...
            then begin
              Brush.Color := paper_colour;
              Brush.Style := bsSolid;

              TextOut(highlighted_timbnum_X,
                highlighted_timbnum_Y, highlighted_timbnum_str + ' ');
            end;

            half_stringwidth := TextWidth(num_str) div 2;
            half_stringheight := TextHeight(num_str) div 2;

            // save new locations of highlighted timber, so can de-highlight next time...

            highlighted_timbnum_X := move_to.X - half_stringwidth;
            highlighted_timbnum_Y := move_to.Y - half_stringheight;
            highlighted_timbnum_str := num_str;

            if paper_colour = clLime then begin
              Brush.Color := clBlack;
              // highlight selected timber number for shoving.
              Font.Color := clWhite;
            end
            else begin
              Brush.Color := clLime;
              Font.Color := clBlack;
            end;

            Brush.Style := bsSolid;

            TextOut(highlighted_timbnum_X, highlighted_timbnum_Y,
              highlighted_timbnum_str + ' ');  // looks better widened.
            Font.Assign(pad_form.Font);
            Brush.Color := paper_colour;
          end;//with
        end;
        EXIT;
      end;
    except
      CONTINUE;
    end;//try

  end;//next i timber number

  // no match found, mouse moved off, so de-highlight any previous...

  if highlighted_timbnum_str <> '' then begin
    with pad_form.Canvas do begin     // direct overdraw.

      Font.Assign(pad_form.pad_timber_font_label.Font);

      Brush.Color := paper_colour;
      Brush.Style := bsSolid;

      TextOut(highlighted_timbnum_X, highlighted_timbnum_Y, highlighted_timbnum_str + ' ');

      Font.Assign(pad_form.Font);
    end;//with
    highlighted_timbnum_str := '';
  end;
end;
//____________________________________________________________________________________________

function checkrail_label_clicked(X, Y: integer): boolean;
  // 0.94.a screen co-ords of a click, is it on a check-rail label?

var
  i, n: integer;
  code: EMarkCode;
  ptr_1st: ^Tmark;         // pointer to a Tmark record..
  markmax: integer;
  //tbnum_str:string;
  num_X, num_Y, half_width, half_height: integer;

begin

  Result := False;   // 0.91.c  init.

  with enter_timber_form.Canvas do begin
    Font.Assign(pad_form.pad_timber_font_label.Font);

    // 0.91.b was Screen.Width ..

    if pad_form.ClientWidth > 1000 then
      half_width := TextWidth('MM') div 2
    // (=10 for default font) clicking area (arbitrary - bitmap fonts).
    else
      half_width := TextWidth('FF') div 2;   // (=7 for ditto).

    half_height := TextHeight('A') div 2;
  end;//with

  // find number string clicked on in control template marks list...

  if marks_list_ptr = nil then
    EXIT;        // pointer to marks list not valid.

  markmax := High(marks_list_ptr);  // max index for the present list.

  if mark_index > markmax then
    mark_index := markmax;  // ??? shouldn't be.

  for i := 0 to (mark_index - 1) do begin     // (mark_index is always the next free slot)
    try
      ptr_1st := @marks_list_ptr[i];  // pointer to the next Tmark record.
      if ptr_1st = nil then
        EXIT;

      code := ptr_1st^.code;

      if code < eMC_501_MSWorkingEnd then
        CONTINUE;   // we are only looking for check-rail label entries.


      num_X := Round(ptr_1st^.p1.X * sx + ex - gx);       // and the centre co-ords for it.
      num_Y := Round((ptr_1st^.p1.Y + yd) * sy + by - gy);

      if (X >= (num_X - half_width)) and (X <= (num_X + half_width)) and
        (Y >= (num_Y - half_height)) and (Y <= (num_Y + half_height)) then begin

        Result := True;   // 0.91.c  clicked on a timber number.

        highlighted_timbnum_str := '';       // prevent de-highlighting of this one.

        if code = current_diff_code then
          EXIT;       // not if already on it.

        current_diff_code := code;          // will now be highlighted

        redraw(True);
        EXIT;
      end;
    except
      CONTINUE;
    end;//try

  end;//next i
end;
//____________________________________________________________________________________________

procedure mouse_on_check_label(X, Y: integer);
// 0.94.a highlight check_label if mouse currently over it.

var
  i: integer;
  code: EMarkCode;
  ptr_1st: ^Tmark;         // pointer to a Tmark record..
  markmax: integer;
  num_str, tbnum_str: string;
  num_x, num_y: double;
  int_num_X, int_num_Y: integer;
  half_width, half_height: integer;
  move_to: TPoint;
  half_stringwidth, half_stringheight: integer;

  dummy_i: integer;

begin

  with enter_timber_form.Canvas do begin
    Font.Assign(pad_form.pad_timber_font_label.Font);

    if pad_form.ClientWidth > 1000 then
      half_width := TextWidth('MM') div 2
    // (=10 for default font) clicking area (arbitrary - bitmap fonts).
    else
      half_width := TextWidth('FF') div 2;   // (=7 for ditto).

    half_height := TextHeight('A') div 2;
  end;//with


  if marks_list_ptr = nil then
    EXIT;        // pointer to marks list not valid.

  markmax := High(marks_list_ptr);  // max index for the present list.

  if mark_index > markmax then
    mark_index := markmax;  // ??? shouldn't be.

  tbnum_str := timb_numbers_str;
  // the full string of timber numbering for the control template.

  for i := 0 to (mark_index - 1) do begin     // (mark_index is always the next free slot)
    try
      ptr_1st := @marks_list_ptr[i];  // pointer to the next Tmark record.
      if ptr_1st = nil then
        EXIT;

      code := ptr_1st^.code;

      if code < eMC_501_MSWorkingEnd then
        CONTINUE;   // we are only looking for check label entries.

      case code of

        eMC_501_MSWorkingEnd:
          num_str := 'MS1';
        eMC_502_MSExtensionEnd:
          num_str := 'MS2';
        eMC_503_MSWingRail:
          num_str := 'MS3';
        eMC_504_TSWorkingEnd:
          if half_diamond = True then
            num_str := 'DS1'
          else
            num_str := 'TS1';
        eMC_505_TSExtensionEnd:
          if half_diamond = True then
            num_str := 'DS2'
          else
            num_str := 'TS2';
        eMC_506_TSWingRail:
          if half_diamond = True then
            num_str := 'DS3'
          else
            num_str := 'TS3';
        eMC_507_MSKCheckRail:
          num_str := 'MS4';
        eMC_508_DSWingRail:
          num_str := 'DS4';

        else
          num_str := '';

      end;//case

      num_x := ptr_1st^.p1.X * sx + ex - gx;       // and the centre co-ords for it.
      num_y := (ptr_1st^.p1.Y + yd) * sy + by - gy;

      int_num_X := Round(num_x);
      int_num_Y := Round(num_y);

      if (X >= (int_num_X - half_width)) and (X <= (int_num_X + half_width)) and
        (Y >= (int_num_Y - half_height)) and (Y <= (int_num_Y + half_height)) then begin

        if code = current_diff_code then
          EXIT;  // do nothing if over the currently selected label.

        move_to.X := Round(limits(h_minint, h_maxint, num_x, dummy_i));
        move_to.Y := Round(limits(h_minint, h_maxint, num_y, dummy_i));

        if check_limit(True, True, move_to) = True then begin
          with pad_form.Canvas do begin     // direct overdraw.

            Font.Assign(pad_form.pad_timber_font_label.Font);

            // 0.94.a re-use shove timber variables ...

            if (highlighted_timbnum_str <> '') and (highlighted_timbnum_str <> num_str)
            // first de-highlight any previous label (but not this one)...
            then begin
              Brush.Color := paper_colour;
              Brush.Style := bsSolid;

              TextOut(highlighted_timbnum_X,
                highlighted_timbnum_Y, highlighted_timbnum_str + ' ');
            end;

            half_stringwidth := TextWidth(num_str) div 2;
            half_stringheight := TextHeight(num_str) div 2;

            // save new locations of highlighted label, so can de-highlight next time...

            highlighted_timbnum_X := move_to.X - half_stringwidth;
            highlighted_timbnum_Y := move_to.Y - half_stringheight;
            highlighted_timbnum_str := num_str;

            if paper_colour = $00FF0060   // violet
            then begin
              Brush.Color := clBlack;
              // highlight selected label for diffing.
              Font.Color := clWhite;
            end
            else begin
              Brush.Color := $00FF0060;
              Font.Color := clWhite;
            end;

            Brush.Style := bsSolid;

            Pen.Width := 1;       // draw the rectangle first...
            Pen.Mode := pmCopy;
            Pen.Style := psSolid;
            Pen.Color := Font.Color;

            RoundRect(move_to.X - half_stringwidth - 3, move_to.Y -
              half_stringheight - 2, move_to.X + half_stringwidth + 4, move_to.Y +
              half_stringheight + 3, 6, 6);

            highlighted_round_rect_x1 := move_to.X - half_stringwidth - 3;
            highlighted_round_rect_y1 := move_to.Y - half_stringheight - 2;
            highlighted_round_rect_x2 := move_to.X + half_stringwidth + 4;
            highlighted_round_rect_y2 := move_to.Y + half_stringheight + 3;

            TextOut(highlighted_timbnum_X, highlighted_timbnum_Y,
              highlighted_timbnum_str);
            Font.Assign(pad_form.Font);
            Brush.Color := paper_colour;
          end;//with
        end;
        EXIT;
      end;
    except
      CONTINUE;
    end;//try

  end;//next i

  // no match found, mouse moved off, so de-highlight any previous...

  if highlighted_timbnum_str <> '' then begin
    with pad_form.Canvas do begin     // direct overdraw.

      Font.Assign(pad_form.pad_timber_font_label.Font);

      Brush.Color := paper_colour;
      Brush.Style := bsSolid;

      Pen.Width := 1;       // draw the rectangle first...
      Pen.Mode := pmCopy;
      Pen.Style := psSolid;
      Pen.Color := Font.Color;
      RoundRect(highlighted_round_rect_x1, highlighted_round_rect_y1,
        highlighted_round_rect_x2, highlighted_round_rect_y2, 6, 6);

      TextOut(highlighted_timbnum_X, highlighted_timbnum_Y, highlighted_timbnum_str);

      Font.Assign(pad_form.Font);
    end;//with
    highlighted_timbnum_str := '';
  end;
end;
//______________________________________________________________________________

procedure enable_peg_positions;    // enable/disable the peg options (for Ctrl-# KB shortcuts).

begin
  with pad_form do begin
    case peg_code of
      -2:
        peg_on_joints_menu_entry.Checked := True;       // radio item.  'J'  on plain track joints
      -1:
        set_peg_menu_entry.Checked := True;             // radio item.  'S'  as set
      0:
        reset_peg_menu_entry.Checked := True;           // radio item.  '0'   datum
      1:
        peg_on_joint_end_menu_entry.Checked := True;    // radio item.  '1'   joint
      2:
        peg_on_tp_menu_entry.Checked := True;           // radio item.  '2'   TP
      3:
        peg_on_dp_menu_entry.Checked := True;           // radio item.  '3'   DP
      4:
        peg_on_fp_menu_entry.Checked := True;           // radio item.  '4'   FP

      5:
        peg_on_tcp_menu_entry.Checked := True;          // radio item. 'N'   TCP
      6:
        peg_on_txp_menu_entry.Checked := True;          // radio item. '5'   TXP
      7:
        peg_on_trp_menu_entry.Checked := True;          // radio item. 'N'   TRP

      8:
        peg_on_mcp_menu_entry.Checked := True;          // radio item. 'N'   MCP
      9:
        peg_on_mxp_menu_entry.Checked := True;          // radio item. '7'   MXP
      10:
        peg_on_mrp_menu_entry.Checked := True;          // radio item. 'N'   MRP
      11:
        peg_on_overall_length_menu_entry.Checked := True; // radioitem '9'   length
      12:
        peg_on_adjacent_ts_menu_entry.Checked := True;
      // radio item. 'N'   TS   adjacent turnout-side track centre
      13:
        peg_on_adjacent_ms_menu_entry.Checked := True;
      // radio item. 'N'   MS   adjacent main-side track centre
      14:
        peg_on_TORG_menu_entry.Checked := True;
      // radio item. 'N'   TORG turnout rad centre
      15:
        peg_on_trans_start_menu_entry.Checked := True;  // radio item. 'N'        transition start
      16:
        peg_on_trans_length_menu_entry.Checked := True;
      // radio item. 'N'        transition end (length)
      17:
        peg_on_MVJP_menu_entry.Checked := True;
      // radio item. '8'   MVJP vee joint (point rail end)
      18:
        peg_on_TVJP_menu_entry.Checked := True;
      // radio item. '6'   TVJP vee joint (splice rail end)
      19:
        peg_on_midlength_menu_entry.Checked := True;    // radio item  'N'   mid-length

      20:
        set_peg_menu_entry.Checked := True;             // radio item. 'M' OR 'F'  (mouse or free)

      22:
        peg_on_tp_menu_entry.Checked := True;
      // radio item. '2'   TP   toggle CTRL-2 options
      33:
        peg_on_dp_menu_entry.Checked := True;
      // radio item. '3'   DP   toggle CTRL-3 options
      44:
        peg_on_fp_menu_entry.Checked := True;
      // radio item. '4'   FP   toggle CTRL-4 options

      100:
        peg_on_planing_menu_entry.Checked := True;      // radio item. 'N'   planing end
      104:
        peg_on_heel_menu_entry.Checked := True;         // radio item. 'N'   switch heel
      108:
        peg_on_CESP_menu_entry.Checked := True;
      // radio item. 'N'   CESP (crossing entry straight point=end of turnout curve)

      200:
        peg_on_EGTP_menu_entry.Checked := True;
      // radio item. 'N'   EGTP external geometrical radius tangent point.
      201:
        peg_on_EGORG_menu_entry.Checked := True;
      // radio item. 'N'   EGORG external geometrical radius origin.
      220:
        peg_on_IGTP_menu_entry.Checked := True;
      // radio item. 'N'   IGTP internal geometrical radius tangent point.
      221:
        peg_on_IGORG_menu_entry.Checked := True;
      // radio item. 'N'   IGORG internal geometrical radius tangent point.

      222:
        peg_on_split_deflection_menu_entry.Checked := True;   // radio item. 'N'   split deflection

      240:
        peg_on_TMINP_menu_entry.Checked := True;
      // radio item. 'N'   TMINP minimum turnout road  213b
      241:
        peg_on_TEXITP_menu_entry.Checked := True;
      // radio item. 'E'   TEXITP turnout road exit  213b

      260:
        peg_on_MMINP_menu_entry.Checked := True;
      // radio item. 'N'   MMINP minimum main road  217a
      261:
        peg_on_MEXITP_menu_entry.Checked := True;
      // radio item. 'E'   MEXITP main road exit    217a

      300:
        peg_on_slew_start_menu_entry.Checked := True;   // radio item. 'N'   slewing start
      301:
        peg_on_slew_length_menu_entry.Checked := True;  // radio item. 'N'   slewing end (length)

      400:
        peg_on_trans_org_menu_entry.Checked := True;
      // radio item. 'N'   transition calcs origin

      600:
        peg_on_tolp_menu_entry.Checked := True;
      // radio item. 'N'   turnout-road opposite full-length position.  0.79.a  29-05-06
      610:
        peg_on_blanked_length_menu_entry.Checked := True;
      // radio item. 'N' blanking length. 0.82.a

      615:
        peg_on_ip_menu_entry.Checked := True;
      // radio item. 'N'   IP  Intermediate  // 208a

      999:
        peg_on_user_defined_menu_entry.Checked := True; // radio item. 'U'   user-defined position.
    end;//case

    peg_on_slew_start_menu_entry.Enabled := slewing;
    peg_on_slew_length_menu_entry.Enabled := slewing;

    peg_on_trans_start_menu_entry.Enabled := spiral;
    peg_on_trans_length_menu_entry.Enabled := spiral;
    peg_on_trans_org_menu_entry.Enabled := spiral;

    peg_on_trp_menu_entry.Enabled :={(retpar_i=1) and} not plain_track;
    peg_on_mrp_menu_entry.Enabled :={(retpar_i=1) and} not plain_track;

    peg_on_EGTP_menu_entry.Enabled := not (spiral or slewing or plain_track);
    peg_on_EGORG_menu_entry.Enabled := not (spiral or slewing or plain_track);
    peg_on_IGTP_menu_entry.Enabled := not (spiral or slewing or plain_track);
    peg_on_IGORG_menu_entry.Enabled := not (spiral or slewing or plain_track);

    peg_on_tp_menu_entry.Enabled := not plain_track;

    peg_on_split_deflection_menu_entry.Enabled := not plain_track;  // 213a

    peg_on_planing_menu_entry.Enabled :=
      not (plain_track or ((half_diamond = True) and (fixed_diamond = True)));
    // not for a fixed-diamond.
    peg_on_heel_menu_entry.Enabled := not (plain_track or (half_diamond = True));
    // not for fixed-diamond or switch-diamond
    peg_on_dp_menu_entry.Enabled := not plain_track;

    peg_on_ip_menu_entry.Enabled := not plain_track;   // 208a

    peg_on_CESP_menu_entry.Enabled :=
      not (plain_track or (tradius_is_straight = True) or (xing_type_i <> 0));
    // no CESP  205e

    peg_on_fp_menu_entry.Enabled := not plain_track;
    peg_on_tcp_menu_entry.Enabled := not plain_track;
    peg_on_txp_menu_entry.Enabled := not plain_track;
    peg_on_mcp_menu_entry.Enabled := not plain_track;
    peg_on_mxp_menu_entry.Enabled := not plain_track;

    // out 205c peg_on_length_menu_entry.Enabled:=    NOT plain_track;

    peg_on_TORG_menu_entry.Enabled :=
      not (plain_track or (ABS(nomrad) < max_rad_test) or (spiral = True) or (xing_type_i <> 1));
    peg_on_MVJP_menu_entry.Enabled := not plain_track;
    peg_on_TVJP_menu_entry.Enabled := not plain_track;

    peg_on_TMINP_menu_entry.Enabled := not plain_track;      // 213b
    peg_on_TEXITP_menu_entry.Enabled := not plain_track;      // 213b

    peg_on_MMINP_menu_entry.Enabled := not plain_track;      // 217a
    peg_on_MEXITP_menu_entry.Enabled := not plain_track;      // 217a

    peg_on_tolp_menu_entry.Enabled := not plain_track;        //   0.79.a  29-05-06
    peg_on_blanked_length_menu_entry.Enabled := not plain_track;   //   0.82.a  14-10-06

    peg_on_joints_menu_entry.Enabled := plain_track;

    case peg_rail of                                           // radio items...
      0:
        peg_is_free_menu_entry.Checked := True;
      1:
        peg_on_rail1_menu_entry.Checked := True;
      2:
        peg_on_rail2_menu_entry.Checked := True;
      3:
        peg_on_rail3_menu_entry.Checked := True;
      4:
        peg_on_rail4_menu_entry.Checked := True;
      5:
        peg_on_rail5_menu_entry.Checked := True;
      6:
        peg_on_rail6_menu_entry.Checked := True;
      7:
        peg_on_rail7_menu_entry.Checked := True;
      8:
        peg_on_rail8_menu_entry.Checked := True;
      9:
        peg_on_rail9_menu_entry.Checked := True;
      else
        peg_on_rail8_menu_entry.Checked := True;   // ms centre-line.
    end;//case

    if plain_track = True    // added 205c
    then
      peg_on_joint_end_menu_entry.Caption := 'peg  on  rail  joint           Ctrl-1'
    else
      peg_on_joint_end_menu_entry.Caption := 'peg  on  switch  front      Ctrl-1';

  end;//with
end;
//__________________________________________________________________________________________

procedure copy_template_info_from_to(delete_shoves: boolean;
  var from_info, to_info: Ttemplate_info);

// v:0.71.a 29-4-01    copy template info, including the shove list.

begin
  to_info.keep_dims := from_info.keep_dims;
  copy_shove_list(delete_shoves, from_info.keep_shove_list, to_info.keep_shove_list);
end;
//________________________________________________________________________________________

procedure warn_group_colour;

var
  i: integer;

begin
  if (pad_form.show_group_menu_entry.Checked = False) or (group_colour_msg_pref = True) or
    (any_selected < 1) then
    EXIT;

  alert_box.preferences_checkbox.Checked := False;       //%%%%
  alert_box.preferences_checkbox.Show;


  i := alert(3, '    group  showing  in  selected  group  colour',
    'Selected groups of templates are normally shown in the SELECTED GROUP colour.' +
    '||To see this group in their MARKER colours, de-select the group (GROUP > GROUP SELECT NONE menu item).',
    '', '', '', 'de-select  the  group  now', '', 'continue', 0);


  group_colour_msg_pref := alert_box.preferences_checkbox.Checked;
  alert_box.preferences_checkbox.Hide;

  if i = 4 then begin
    clear_all_selections;
    redraw(True);
  end;
end;
//______________________________________________________________________________

procedure show_switch_info(full_size_mm, already_showing: boolean);

var
  info_str, swnum_str, front_str: string;
  fs_unit_str: string;   // 208a
  fs_factor: double;   // 208a
  i: integer;
  sw_info: Tswitch_info;

  margin_size: integer;
  new_height: integer;

  /////////////////////////////////////////

  function val_str(d: double): string;   // mods 208a

    // d is in full-size inches

  begin
    if ABS(d * inscale) >= max_rad_test then
      Result := ' = straight'
    else
      Result := ' = ' + round_str(d * fs_factor, 2) + '  ( ' + round_str(d * inscale, 2) +
        ' model mm )';
  end;
  //////////////////////////////////////////

begin
  with switch_select_form.switch_selector_listbox do
    sw_info := Tswitch(Items.Objects[ItemIndex]).list_switch_info;

  if full_size_mm = True then begin
    fs_factor := 25.4;
    fs_unit_str := 'MM';
  end
  else begin
    fs_factor := 1.0;
    fs_unit_str := 'INCHES';
  end;

  info_str := 'Dimensions  for  ' + sw_info.sw_name_str +
    '  Switch :|--------------------------------' + '||Dimensions are in FULL-SIZE prototype ' +
    fs_unit_str + ',' + ' with model conversions at ' + round_str(scale, 2) + ' mm/ft.'
    //+'|Unit angles are RAM if not stated.'
    + '||This switch is a ';

  case sw_info.sw_pattern of
    // type of switch.  0 = curved planing or straight switch; -1 = semi-curved switch;  1 = double-curved switch.

    -1: begin   // semi-curved switch ...

      info_str := info_str + 'SEMI-CURVED pattern switch:';

      info_str := info_str + '||straight planing length (along blade)' + val_str(sw_info.planing);
      info_str := info_str + '|straight planing unit angle = ' +
        ram_clm_str(sw_info.planing_angle);
      //   1 : '+round_str(sw_info.planing_angle,2);
      info_str := info_str + '|lead length to heel (incl. planing)' +
        val_str(sw_info.heel_lead_inches);
      info_str := info_str + '||switch radius' + val_str(sw_info.switch_radius_inchormax);
      info_str := info_str + '||length of switch-front (stock-rail joint to toe)' +
        val_str(sw_info.switch_front_inches);
      info_str := info_str + '|length of switch-rail (blade)' + val_str(sw_info.switch_rail);
      info_str := info_str + '|length of stock-rail from joint' + val_str(sw_info.stock_rail);
    end;

    0: begin
      if sw_info.switch_radius_inchormax < max_rad_test  // not a straight switch.

      then begin       // curved switch...
        info_str := info_str + 'CURVED pattern switch:';

        info_str := info_str + '||lead length to heel (incl. planing)' +
          val_str(sw_info.heel_lead_inches);
        info_str := info_str + '|offset at the heel (heel spread)' +
          val_str(sw_info.heel_offset_inches);
        info_str := info_str + '||switch radius' + val_str(sw_info.switch_radius_inchormax);
        info_str := info_str + '||length of switch-front (stock-rail joint to toe)' +
          val_str(sw_info.switch_front_inches);
        info_str := info_str + '|length of switch-rail (blade)' + val_str(sw_info.switch_rail);
        info_str := info_str + '|length of stock-rail from joint' + val_str(sw_info.stock_rail);
      end
      else begin       // straight switch...
        info_str := info_str + 'STRAIGHT pattern switch:';

        info_str := info_str + '||lead length to heel (incl. planing)' +
          val_str(sw_info.heel_lead_inches);
        info_str := info_str + '|offset at the heel (heel spread)' +
          val_str(sw_info.heel_offset_inches);
        info_str := info_str + '||length of switch-front (stock-rail joint to toe)' +
          val_str(sw_info.switch_front_inches);
        info_str := info_str + '|length of switch-rail (blade)' + val_str(sw_info.switch_rail);
        info_str := info_str + '|length of stock-rail from joint' + val_str(sw_info.stock_rail);
      end;
    end;

    1: begin
      info_str := info_str + 'DOUBLE-CURVED pattern switch (not yet implemented)';
    end;

  end;//case

  if calc_switch(sw_info, False, False) = 0    // no error
  then begin
    //info_str:=info_str+'||deflection angle at blade tip = 1 : '+round_str(k1n,2);

    info_str := info_str + '||deflection angle at blade tip = ' + ram_clm_str(k1n);

    info_str := info_str + '|planing length (along stock-rail)' + val_str((plox - toex) / inscale);

    //info_str:=info_str+'|heel angle 1 : '+round_str(k2n,2);

    info_str := info_str + '|heel angle = ' + ram_clm_str(k2n);

    if sw_info.sw_pattern = -1 then
      info_str := info_str + '|heel offset' + val_str(h / inscale);
  end;

  info_str := info_str + '||FB switch-rail foot-width at blade tip (from stock-rail gauge-face)' +
    val_str(sw_info.fb_tip_offset);

  info_str := info_str + '||sideways depth of joggle' + val_str(sw_info.joggle_depth);
  info_str := info_str + '|joggle-length in front of blade tips' + val_str(sw_info.joggle_length);

  if sw_info.front_timbered = True then
    front_str := 'timber'
  else
    front_str := 'sleeper';

  info_str := info_str + '|-------------------|Timber spacings (to timber centres) :';
  info_str := info_str + '||switch-front is ' + front_str + 'ed:';
  info_str := info_str + '|spacing back from toe (blade tips) to first front ' +
    front_str + ' (J1)' + val_str(0 - sw_info.sleeper_j1);
  info_str := info_str + '|spacing back to next front ' + front_str + ' (J2)' +
    val_str(0 - sw_info.sleeper_j2);
  info_str := info_str + '|spacing back to next front ' + front_str + ' (J3)' +
    val_str(0 - sw_info.sleeper_j3);
  info_str := info_str + '|spacing back to next front ' + front_str + ' (J4)' +
    val_str(0 - sw_info.sleeper_j4);
  info_str := info_str + '|spacing back to next front ' + front_str + ' (J5)' +
    val_str(0 - sw_info.sleeper_j5);

  info_str := info_str + '||spacing forward from toe (blade tips) to first timber (S1)' +
    val_str(sw_info.timber_centres[0]) + '|';

  i := 1;

  while sw_info.timber_centres[i] > minfp do begin

    if sw_info.timber_centres[i + 1] < minfp then
      swnum_str := '(T1)'                         // timber number.
    else
      swnum_str := '(S' + IntToStr(i + 1) + ')';

    info_str := info_str + '|spacing forward to next timber ' + swnum_str +
      val_str(sw_info.timber_centres[i]);
    Inc(i);

  end;//while

  if already_showing = False then begin

    data_child_form.Close; // if showing elsewhere

    if data_child_form.Parent <> nil then
      data_child_form.Parent.RemoveControl(data_child_form);

    with switch_select_form do begin

      InsertControl(data_child_form);     // make it a child

      // child forms have wide borders ...

      margin_size := datestamp_label.Height;   // for program sizing

      ClientWidth := datestamp_label.Width + data_child_form.Width + margin_size * 8;
      // 8 arbitrary for child borders

      new_height := data_child_form.Height + margin_size * 16;
      // 16 arbitrary for child caption bar
      if ClientHeight < new_height then
        ClientHeight := new_height;

      data_child_form.Top := margin_size * 2;
      data_child_form.Left := datestamp_label.Width + margin_size;

    end;//with
  end;

  data_child_form.data_memo.Text := insert_crlf_str(info_str);
  //  replace embedded | chars with a CR.

  if (already_showing = False) or (data_child_form.Visible = False) then
    data_child_form.Show;
end;
//______________________________________________________________________________

function set_csi_from_switch_info(sw_info: Tswitch_info): boolean;
  // set current switch from supplied info.

var
  cu_sw_info: Tswitch_info;

begin
  Result := False;        // default init.

  if sw_info.valid_data = False then
    EXIT;

  csi := sw_info;         // set control template switch data.

  if csi.group_code < 1   // custom switch, put a copy in bottom slot in list...
  then begin
    cu_sw_info := csi;            // copy the data.

    cu_sw_info.group_code := 0;   // custom - in the info (for the bottom slot).
    cu_sw_info.size_code := 1;    // custom can only be one size (should be already 1).
    cu_sw_info.group_count := 1;  // ditto.

    with switch_select_form.switch_selector_listbox.Items do begin
      if Count > 0 then begin
        Tswitch(Objects[Count - 1]).list_switch_info := cu_sw_info;
        // put custom data in selector list.
        Strings[Count - 1] := '  custom :  ' + csi.sw_name_str;
        // put custom name in selector list.
      end;
    end;//with
  end;

  Result := True;
end;//func
//________________________________________________________________________________________

procedure convert_to_regular_half_diamond;
// change turnout or IRREGULAR half-diamond to a REGULAR half-diamond

var
  dummy: double;
  new_len: double;

begin
  if plain_track = True then
    EXIT;

  if gaunt = True then
    convert_to_or_from_gaunt(False);  // 0.93.a cancel any gaunt

  startx := 0;       // cancel any blanking.

  if half_diamond = False  // converting from turnout
  then begin

    if xorg > 0 then
      crop_approach;

    gocalc(0, 0);

    pad_form.peg_on_dp_menu_entry.Click;    // put peg at DP Ctrl-3.
    gocalc(0, 0);

    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
    // save current peg data for peg_curve calcs.

    new_len := turnoutx - dpx;                  // calc new length to end from DP.
    if new_len < 0 then
      new_len := mvjpx - dpx;

    if spiral = True then
      os := os - dpx;
    if slewing = True then
      slew_s := slew_s - dpx;

    half_diamond := True;    // to half-diamond
    hdkn := k3n;             // 0.93.a force regular pattern

    gocalc(0, 0);

    xorg := 0;                          // should have been cropped anyway.
    turnoutx := dpx + new_len;            // dpx has been re-calced for half-diamond.
    if turnoutx < 0 then
      turnoutx := 0;
    if turnoutx > turnoutx_max then
      turnoutx := turnoutx_max;

    turnout_i := 1;      // length locked at turnoutx.
    gocalc(0, 0);

    peg_curve;
  end
  else begin

    kform_now := kform;
    docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
    // save current peg data for peg_curve calcs.

    hdkn := k3n;             // 0.93.a force regular pattern

    gocalc(0, 0);

  end;

  peg_curve;

  pad_form.reset_peg_menu_entry.Click;  // to CTRL-0
end;
//_______________________________

procedure convert_to_turnout;

var
  dummy: double;
  new_len: double;

begin
  if (half_diamond = False) or (plain_track = True) then
    EXIT;

  pad_form.peg_on_dp_menu_entry.Click;    // put peg at DP Ctrl-3.
  gocalc(0, 0);

  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  new_len := turnoutx - dpx;                 // calc new length to end from DP.
  if new_len < 0 then
    new_len := mvjpx - dpx;

  half_diamond := False;
  gocalc(0, 0);

  if spiral = True then
    os := os + dpx;
  if slewing = True then
    slew_s := slew_s + dpx;

  xorg := 0;                          // should be 0 anyway.
  turnoutx := dpx + new_len;            // dpx has been re-calced for turnout.
  if turnoutx < 0 then
    turnoutx := 0;
  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;

  if startx < 0 then
    startx := 0;       // cancel the negative blanking.

  turnout_i := 1;      // length locked at turnoutx.
  gocalc(0, 0);

  peg_curve;

  pad_form.reset_peg_menu_entry.Click;  // to CTRL-0

end;
//________________________________________________________________________________________

procedure insert_half_diamond;

begin
  if plain_track = True then begin
    if gaunt = True then
      convert_to_or_from_gaunt(False);  // 0.93.a cancel any gaunt
    pad_form.reset_peg_menu_entry.Click;
    gocalc(0, 0);
    insert_turnout;
    gocalc(0, 0);
    half_diamond := True;
  end;
end;
//____________________________________________________________________________________

procedure obtain_switch(n: integer);   // obtain control template switch from template in list.

var
  dummy: double;

begin

  if (keeps_list.Count < 1) or (n < 0) or (n > (keeps_list.Count - 1)) then
    EXIT;

  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  with keeps_list[n].template_info.keep_dims.turnout_info2 do begin

    if set_csi_from_switch_info(switch_info) = False  // set current switch from supplied info.
    then begin
      if set_csi_data(2, 2) = False     // set REA B default if copied data invalid.
      then
        run_error(82);         // ?????? no B switch in list?
    end;
  end;//with

  gocalc(0, 0);     // calc new pegx.

  peg_curve;            // adjust shifts and rotates for current peg position.
  redraw_pad(True, True);
end;
//_____________________________________________________________________________________

procedure obtain_plain_track(n: integer);
// obtain control template plain-track settings from template in list.

begin
  if (keeps_list.Count < 1) or (n < 0) or (n > (keeps_list.Count - 1)) then
    EXIT;

  with keeps_list[n].template_info.keep_dims.turnout_info2.plain_track_info do begin

    if (pt_custom = True) or (list_index > 4)  // put data in bottom slot.
    then begin
      pt_i := plain_track_form.plain_track_spacings_listbox.Items.Count - 1;
      // list index for current custom plain track.
      railen[pt_i] := rail_length;
      // custom rail length in inches.
      sleeper_count[pt_i] := sleepers_per_length;
      // number of sleepers per length.
      for n := 0 to psleep_c do
        psleep[pt_i, n] := sleeper_centres[n];   // custom spacings.

      plain_track_form.plain_track_spacings_listbox.Items.Strings[pt_i] :=
        '  ' + Trim(pt_spacing_name_str);   // put name in the list.
    end
    else
      pt_i := list_index;           // copy data if custom, otherwise use index into existing list.


    rjcode := rail_joints_code;   // 0=normal, 1=staggered, -1=none (cwr).

    tb_roll_percent := pt_tb_rolling_percent;
  end;//with

  redraw_pad(True, True);
end;
//______________________________________________________________________________

procedure do_info_colours; // indicate if control template visible and accessible...

begin
  if (current_is_showing = True) and (keep_form.Active = False) then begin
    if turnoutx = 0                                        // 0.93.a
    then begin
      info_form.info_gauge_panel.Color := $00D0D0FF;  // pale red
      info_form.gauge_label.Font.Color := clRed;
      //205e pad_form.store_bgnd_toolbutton.Font.Color:=clRed;
      //205e pad_form.zero_control_toolbutton.Down:=True;
    end
    else begin
      info_form.gauge_label.Font.Color := clBlack;
      //205e pad_form.store_bgnd_toolbutton.Font.Color:=clBlack;
      //205e pad_form.zero_control_toolbutton.Down:=False;

      if ((sx_mod = 1) or (both_mod = 1)) and ((switch_free = False) or (xing_free = False)) then
        info_form.info_gauge_panel.Color := $00FFA0FF   // clFuchsia
      else
        info_form.info_gauge_panel.Color := $00FFFFA0;  // clAqua;
    end;
  end
  else
    info_form.info_gauge_panel.Color := $00E0E0E0;  // grey - hidden or pad not active.
end;
//______________________________________________________________________________

function calc_snap_peg_data(code: integer): Tnotch;      // 0.79.a  27-05-06

  // using the control template data, calculate the F7 snap_peg positions.
  // called from copy_keep_to_background (keep_select unit).

  //  !!!  217b   don't call from control template calcs,  interferes with transforms.

var
  dummy_str: string;
  x, y, k: double;
  temp_y: double;
  notch_data: Tnotch;
  turn_k, angle: double;
  curving_rad: double;
  tanx, shrink_factor: double;
  modk: double;

begin

  with Result do begin     // defalt inits.
    notch_x := 0;
    notch_y := 0;
    notch_k := 0;
  end;//with

  x := pegx;    //  default inits (for peg_code 20, peg free) ...
  y := pegy;
  k := pegangle;

  normalize_transforms;

  dummy_str := calc_peg_dims(code, x, y, k);     // code is the peg_code.

  with notch_data do begin
    normalize_transforms;

    docurving(True, True, x, y, notch_x, temp_y, turn_k, curving_rad);
    // get notch data from current peg position.
    notch_y := temp_y * hand_i + y_datum;

    // 217b  gradient correction for radial shrink/enlarge ...

    if ABS(k) < minfp then
      modk := k
    else begin
      try
        shrink_factor := (curving_rad - (y - g / 2)) / curving_rad;
        tanx := 1 / TAN(k);
        tanx := tanx * shrink_factor;
        modk := ARCTAN(1 / tanx);
      except
        modk := k;
      end;//try
    end;

    angle := modk + turn_k + kform;
    // arm angle (actual on pad including curving and transforms).
    normalize_angle(angle);
    notch_k := angle * hand_i;
  end;//with

  Result := notch_data;
end;
//______________________________________________________________________________________

procedure snap_current_to_bgnd(notch_pos: Tnotch; facing_to_trailing: boolean);   // 0.79.a

begin
  if facing_to_trailing = False then
    notch_pos.notch_k := notch_pos.notch_k + Pi;
  // facing to facing, or trailing to trailing, so rotate angle 180 degs

  set_current_notch(notch_pos);                      // move notch to bgnd template.

  Inc(notch_index);                                  // to next notch rollback slot.
  if notch_index > notch_c then
    notch_index := 0;
  undo_notch[notch_index] := notch_pos;                // save notch in this slot...
  pad_form.cycle_notch_menu_entry.Enabled := True;

  shift_onto_notch(False, False);       // shift control template to it.

  show_and_redraw(True, True);    // in case control template hidden.
end;
//______________________________________________________________________________________

procedure snap_onto_bgnd_pegs;   // 0.79.a   27-05-06

// F7 SHIFT mouse action release -- find a near background template and snap onto it.

var
  n, nc, nb: integer;
  cur_pegs, bgnd_pegs: array[0..4] of Tnotch;
  x1, y1, x2, y2, proximity: double;
  readout_str: string;

begin
  if keeps_list.Count < 1 then
    EXIT;   // no stored templates

  if (pad_form.snap_always_on_background_templates_menu_entry.Checked = False) and
    ((f7_snap_allow = False) or (pad_form.snap_on_background_templates_menu_entry.Checked =
    False)) then
    EXIT;  // 218a mod

  proximity := snap_proximity_limit * inscale;  // snap range

  // control template peg positions for snap checks...

  cur_pegs[0] := calc_snap_peg_data(0);   // ctrl-0
  cur_pegs[1] := calc_snap_peg_data(1);   // ctrl-1
  cur_pegs[2] := calc_snap_peg_data(18);  // ctrl-6
  cur_pegs[3] := calc_snap_peg_data(11);  // ctrl-9
  cur_pegs[4] := calc_snap_peg_data(600); // TOLP

  for n := 0 to (keeps_list.Count - 1) do begin

    with keeps_list[n] do begin

      if template_info.keep_dims.box_dims1.disable_f7_snap = True then
        CONTINUE;  // 0.82.a disabled for this template.

      if bg_copied = False then
        CONTINUE;  // not on background.

      bgnd_pegs[0] := snap_peg_positions.ctrl_0_pos;
      bgnd_pegs[1] := snap_peg_positions.ctrl_1_pos;
      bgnd_pegs[2] := snap_peg_positions.ctrl_6_pos;
      bgnd_pegs[3] := snap_peg_positions.ctrl_9_pos;
      bgnd_pegs[4] := snap_peg_positions.ctrl_tolp_pos;

      for nc := 0 to 4 do begin

        // check valid snap position on control template...

        if (half_diamond = True) and (nc < 2) then
          CONTINUE;    // only Ctrl-6, Ctrl-9, TOLP valid for a half-diamond.
        if (plain_track = True) and (nc > 1) then
          CONTINUE;     // only Ctrl-0 and Ctrl-1 valid for plain track.

        if (half_diamond = False) and (plain_track = False) and (nc = 1) then
          CONTINUE;  // Ctrl-1 not valid for a turnout.

        if (retpar_i <> 1) and (nc = 4) then
          CONTINUE;  // TOLP valid only for parallel crossing.

        for nb := 0 to 4 do begin

          // check valid snap position on background template...

          if (bgnd_half_diamond = True) and (nb < 2) then
            CONTINUE;    // only Ctrl-6, Ctrl-9, TOLP valid for a half-diamond.
          if (bgnd_plain_track = True) and (nb > 1) then
            CONTINUE;     // only Ctrl-0 and Ctrl-1 valid for plain track.

          if (bgnd_half_diamond = False) and (bgnd_plain_track = False) and (nb = 1) then
            CONTINUE;  // Ctrl-1 not valid for a turnout.

          if (bgnd_retpar = False) and (nb = 4) then
            CONTINUE;  // TOLP valid only for parallel crossing.

          // calc proximity...

          x1 := cur_pegs[nc].notch_x;
          y1 := cur_pegs[nc].notch_y;

          x2 := bgnd_pegs[nb].notch_x;
          y2 := bgnd_pegs[nb].notch_y;

          if (ABS(x1 - x2) < proximity) and (ABS(y1 - y2) < proximity) then begin

            with pad_form do begin
              // move current peg to snapping position...
              case nc of
                0: begin                                 // set Ctrl-0
                  peg_on_rail8_menu_entry.Click;
                  // main-road centre-line (sets peg_code=20, so do first),
                  peg_code := 0;                        // then set it.
                  peg_indicator_panel.Caption := '0';   // show him Ctrl-0
                end;

                1: begin                                 // set ctrl-1
                  peg_on_rail8_menu_entry.Click;
                  // main-road centre-line (sets peg_code=20, so do first),
                  peg_code := 1;                        // then set it.
                  peg_indicator_panel.Caption := '1';   // show him Ctrl-1
                end;

                2: begin                                 // set ctrl-6
                  peg_on_rail9_menu_entry.Click;
                  // turnout-road centre-line (sets peg_code=20, so do first),
                  peg_code := 18;                       // then set it.
                  peg_indicator_panel.Caption := '6';   // show him Ctrl-6
                end;

                3: begin                                 // set ctrl-9
                  peg_on_rail8_menu_entry.Click;
                  // main-road centre-line (sets peg_code=20, so do first),
                  peg_code := 11;                       // then set it.
                  peg_indicator_panel.Caption := '9';   // show him Ctrl-9
                end;

                4: begin                                 // set TOLP
                  peg_on_rail9_menu_entry.Click;
                  // main-road centre-line (sets peg_code=20, so do first),
                  peg_code := 600;                      // then set it.
                  peg_indicator_panel.Caption := 'N';   // show him TOLP
                end;

                else
                  EXIT; // ???
              end;//case

            end;//with

            gocalc(0, 0);  // calc new peg.

            // rotate bgnd angle for facing-facing or trailing-trailing connections...

            if (nc = nb) or ((nc = 1) and (nb = 2)) or ((nc = 1) and (nb = 3)) or
              ((nc = 1) and (nb = 4)) or ((nc = 2) and (nb = 1)) or
              ((nc = 2) and (nb = 3)) or ((nc = 2) and (nb = 4)) or
              ((nc = 3) and (nb = 1)) or ((nc = 3) and (nb = 2)) or ((nc = 3) and (nb = 4)) or
              ((nc = 4) and (nb = 1)) or ((nc = 4) and (nb = 2)) or ((nc = 4) and (nb = 3)) then
              bgnd_pegs[nb].notch_k := bgnd_pegs[nb].notch_k + Pi;   // rotate angle 180 degs

            set_current_notch(bgnd_pegs[nb]);
            // move notch to bgnd template.

            Inc(notch_index);
            // to next notch rollback slot.
            if notch_index > notch_c then
              notch_index := 0;
            undo_notch[notch_index] := bgnd_pegs[nb];          // save notch in this slot...
            pad_form.cycle_notch_menu_entry.Enabled := True;

            shift_onto_notch(False, False);

            // 0.82.a  update readouts on F7 snap...

            redraw_pad(False, True);  // immediate redraw, so we can update the readouts

            readout_str := 'X : ' + captext(xshift) + ' mm      Y : ' + captext(yshift) + ' mm';
            caption_add(readout_str);
            action_update(readout_str);

            EXIT;   // found a snap.
          end;

        end;//next nb
      end;//next nc

    end;//with
  end;//next template
end;
//__________________________________________________________________________________________

procedure match_rolled_lengths(ctrl: integer);

// 0.82.c  match rolled rail lengths across template boundaries.
// ctrl=0 for Ctrl-0 , ctrl=1 for Ctrl-1 , boundary on background.
//
// control template boundary must be Ctrl-1.

var
  bgnd_template_len_mm, bgnd_rail_len_in, bgnd_rail_len_mm, rolled_out_mm,
  match_percent, bgnd_roll_percent: double;

begin
  try
    if (clicked_keep_index < 0) or (clicked_keep_index > (keeps_list.Count - 1)) or
      (keeps_list.Count < 1) then
      EXIT;

    with keeps_list[clicked_keep_index].template_info.keep_dims do begin

      if (box_dims1.turnout_info1.plain_track_flag = False) or (plain_track = False) then begin
        alert(6, '      roll  rails  to  match  background  template',
          '|Templates are not both plain track.' +
          '||The ROLL RAILS TO MATCH BACKGROUND TEMPLATE function requires that both the control template and the selected background template must be plain track templates.' + '||For approach or exit tracks on a turnout or half-diamond template, these should first be split off as separate plain track templates.' + ' Click the TOOLS > MAKE SPLIT > menu items.',
          '', '', '', '', 'cancel', '', 0);
        EXIT;
      end;

      if ABS(scale - box_dims1.proto_info.scale_pi) > minfp then begin
        alert(6, '      roll  rails  to  match  background  template',
          '|Template scales differ.' +
          '||The ROLL RAILS TO MATCH BACKGROUND TEMPLATE function requires that both the control template and the selected background template must be to the same scale.' + ' (The track gauges may differ, where gauge-widening is wanted on one of them.)',
          '', '', '', '', 'cancel', '', 0);
        EXIT;
      end;

      // on bgnd template...

      bgnd_template_len_mm := ABS(box_dims1.turnout_info1.turnout_length);
      //  mm overall length.
      bgnd_rail_len_in := ABS(turnout_info2.plain_track_info.rail_length);
      // proto inches
      bgnd_roll_percent := ABS(turnout_info2.plain_track_info.pt_tb_rolling_percent);
      // rolled in percent.

    end;//with

    if ABS(railen[pt_i] - bgnd_rail_len_in) > minfp then begin
      alert(6, '      roll  rails  to  match  background  template',
        '|Template rail length settings differ.' +
        '||The ROLL RAILS TO MATCH BACKGROUND TEMPLATE function requires that both the control template and the selected background template must be set for the same prototype rail length.' + '||To change the settings, click the REAL > PLAIN TRACK OPTIONS > RAIL LENGTHS AND SLEEPER SPACINGS... menu item.',
        '', '', '', '', 'cancel', '', 0);
      EXIT;
    end;

    while (bgnd_roll_percent > 100) do
      bgnd_roll_percent := bgnd_roll_percent - 100;   // ???

    // calc percent of rail needed to be matched...

    match_percent := 0;  // keep compiler happy.

    case ctrl of

      0: begin   // Ctrl-0 on background
        bgnd_rail_len_mm := bgnd_rail_len_in * inscale;  // rail length in mm.
        if ABS(bgnd_rail_len_mm) < minfp then
          EXIT;    //  ??? div 0

        rolled_out_mm := bgnd_template_len_mm - bgnd_roll_percent * bgnd_rail_len_mm / 100;
        // length beyond first (rolled in) joint.
        match_percent := Frac(rolled_out_mm / bgnd_rail_len_mm) * 100;
      end;

      1:
        match_percent := bgnd_roll_percent;  // Ctrl-1 on background

    end;//case

    // set roll percent on control template...

    if (match_percent < minfp) or (match_percent > 100) or (ABS(match_percent - 100) < minfp)
    // 0 or 100%
    then
      tb_roll_percent := 0                                 // full length needed on current.
    else
      tb_roll_percent := 100 - match_percent;                // remainder needed on current.

  finally
    clicked_keep_index := -1;       // so can popup again.
    show_and_redraw(True, True);   // show current and redraw pad when ready. (allow rollback).
  end;
end;
//____________________________________________________________________________________

procedure tick_not_normal;   // not printing 100% or fit single, change menu tick.

begin
  pad_form.enlarge_reduce_size_menu_entry.Checked := True; // radio item.
  fit_single_sheet := False;
  redraw(True);                                         // for the page outlines on the pad.
end;
//_______________________________________________________________________________________

procedure normal_adjust_menu_entry_click;

begin
  cancel_adjusts(False);                                // need a recalc from now_X etc.
  pad_form.normal_adjust_menu_entry.Checked := True;      // radio item.
  fine_adjust := 1;                                       // modify mouse response factors.
end;
//______________________________________________________________________________

function check_limit(bunch, shear: boolean; var p: TPoint): boolean;
  // safety check on one pair of drawing co-ordinates.

  // at present this routine is called for timber numbering, grid lines, and grid and scalebar labels on the pad, and name label locations.
var
  bunch_end, bunch_length, X: integer;       // in pixels for paper bunching calcs 13-11-99.
  n: integer;
  m: double;

begin
  Result := False;                            // init default.

  if slow_run <> 0      // do slow-running delay...
  then begin
    try
      for n := 0 to Round(slow_run * 100) do
        m := SIN(SQR(Pi));
    except
      EXIT;
    end;//try
  end;

  if paper_bunching = True then begin
    bunch_length := bunch_gap + bunch_jump_i;
    if bunch_length < 1 then
      EXIT;          // div zero or neg!!!

    bunch_end := bunch_start + bunch_length;

    if p.X > bunch_end then begin
      if bunch = True then
        p.X := p.X - bunch_jump_i;
      if shear = True then
        p.Y := p.Y + bunch_shear_i;
    end
    else begin
      if p.X > bunch_start then begin
        X := p.X;
        if bunch = True then
          p.X := bunch_start + (bunch_gap * (X - bunch_start) div bunch_length);
        if shear = True then
          p.Y := p.Y + (bunch_shear_i * (X - bunch_start) div bunch_length);
      end;               // must do multiply first - these are integers!
    end;
  end;

  if export_limits = True      // 0.93.a
  then begin
    if p.x > max_export_y then
      EXIT;
    if p.x < min_export_y then
      EXIT;

    if p.y > max_export_x then
      EXIT;
    if p.y < min_export_x then
      EXIT;
  end;

  if graphics_limits = True      // 0.76.a 25-5-02.
  then begin
    if p.x > max_draw_int then
      EXIT;
    if p.x < min_draw_int then
      EXIT;

    if p.y > max_draw_int then
      EXIT;
    if p.y < min_draw_int then
      EXIT;
  end;

  Result := True;
end;
//_____________________________________________________________________________________

function check_limits(var p1, p2: TPoint): boolean;
  // limit checks on both pairs of drawing co-ordinates.

var
  bunch_end, X: integer;       // for paper bunching calcs 13-11-99.
  bunch_length: integer;       // pixels.
  n: integer;
  m: double;

begin
  Result := False;                            // init default.

  if slow_run <> 0    // do slow-running delay...
  then begin
    try
      for n := 0 to Round(slow_run * 100) do
        m := SIN(SQR(Pi));
    except
      EXIT;
    end;//try
  end;

  if paper_bunching = True then begin
    bunch_length := bunch_gap + bunch_jump_i;
    if bunch_length < 1 then
      EXIT;          // div zero or neg!!!

    bunch_end := bunch_start + bunch_length;

    if p1.X > bunch_end then begin
      p1.X := p1.X - bunch_jump_i;
      p1.Y := p1.Y + bunch_shear_i;
    end
    else begin
      if p1.X > bunch_start then begin
        X := p1.X;
        p1.X := bunch_start + (bunch_gap * (X - bunch_start) div bunch_length);
        p1.Y := p1.Y + (bunch_shear_i * (X - bunch_start) div bunch_length);
      end;             // must do multiply first - these are integers!
    end;

    if p2.X > bunch_end then begin
      p2.X := p2.X - bunch_jump_i;
      p2.Y := p2.Y + bunch_shear_i;
    end
    else begin
      if p2.X > bunch_start then begin
        X := p2.X;
        p2.X := bunch_start + (bunch_gap * (X - bunch_start) div bunch_length);
        p2.Y := p2.Y + (bunch_shear_i * (X - bunch_start) div bunch_length);
      end;             // must do multiply first - these are integers!
    end;

  end;//if paper_bunching.


  if export_limits = True      // 0.93.a
  then begin
    if p1.x > max_export_y then
      EXIT;
    if p1.x < min_export_y then
      EXIT;

    if p1.y > max_export_x then
      EXIT;
    if p1.y < min_export_x then
      EXIT;

    if p2.x > max_export_y then
      EXIT;
    if p2.x < min_export_y then
      EXIT;

    if p2.y > max_export_x then
      EXIT;
    if p2.y < min_export_x then
      EXIT;
  end;

  if graphics_limits = True      // 0.76.a 25-5-02.
  then begin
    if p1.x > max_draw_int then
      EXIT;
    if p1.x < min_draw_int then
      EXIT;

    if p1.y > max_draw_int then
      EXIT;
    if p1.y < min_draw_int then
      EXIT;

    if p2.x > max_draw_int then
      EXIT;
    if p2.x < min_draw_int then
      EXIT;

    if p2.y > max_draw_int then
      EXIT;
    if p2.y < min_draw_int then
      EXIT;
  end;

  Result := True;
end;
//_____________________________________________________________________________________

function check_draw_dim_l(d: integer): boolean;
  // length limit check on a single drawing dimension.

begin
  Result := False;  //init

  if export_limits = True      // 0.93.a
  then begin
    if d > max_export_x then
      EXIT;
    if d < min_export_x then
      EXIT;
  end;

  if graphics_limits = True      // !!! Bug Fix 0.78.b 10-12-02.
  then begin
    if d > max_draw_int then
      EXIT;
    if d < min_draw_int then
      EXIT;
  end;

  Result := True;
end;
//______________________________________________________________________________

function check_draw_dim_w(d: integer): boolean;
  // width limit check on a single drawing dimension.

begin
  Result := False;  //init

  if export_limits = True      // 0.93.a
  then begin
    if d > max_export_y then
      EXIT;
    if d < min_export_y then
      EXIT;
  end;

  if graphics_limits = True      // !!! Bug Fix 0.78.b 10-12-02.
  then begin
    if d > max_draw_int then
      EXIT;
    if d < min_draw_int then
      EXIT;
  end;

  Result := True;
end;
//______________________________________________________________________________

function SGN(x: double): double;

  //  return sign of x. (+1,  -1,  0)
begin
  Result := 0;
  if x = 0 then
    EXIT;
  if x > 0 then
    Result := 1.0;
  if x < 0 then
    Result := 0 - 1.0;
end;
//_________________________________________________________________________________________

function SGZ(x: double): double;

  //  return sign of x. (+1,  -1)   (Zero returns +1)
begin
  Result := 1;
  if x < 0 then
    Result := 0 - 1.0;
end;
//_________________________________________________________________________________________

function round_str(x: double; n: integer): string;

  //  round x to n decimal places and return as a string.
begin
  if n < 0 then
    run_error(56);
  if x = 0 then
    Result := '0'
  else begin         //  use Delphi string formatting for up to 4 decimal places
    case n of
      0:
        Result := FormatFloat('0', x);
      1:
        Result := FormatFloat('0.0', x);       // show at least one decimal place, even if zero...
      2: begin
        case zero_supp of
          2:
            Result := FormatFloat('0.##', x);
          1:
            Result := FormatFloat('0.0#', x);
          0:
            Result := FormatFloat('0.00', x);
          else
            run_error(33);
        end;//case
      end;

      else
        Result := FormatFloat('0.0' + StringOfChar('#', n - 1), x)   // 206e
    end;//case

  end;
  if (omit_neg_brackets = False) and (x < 0) then
    Result := '[ ' + Result + ' ]';
end;
//______________________________________________________________________________

function round_float(x: double; n: integer): double;

  //  round x to n decimal places and return as a float.
var
  mul, mulx: double;

begin
  if n < 0 then
    run_error(57);
  if x = 0 then
    Result := 0
  else begin
    mul := POWER(10, n);
    mulx := INT(x * mul + 0.5 * SGN(x));
    Result := mulx / mul;
  end;
end;
//_________________________________________________________________________________________

function limits(min, max, d: double; var return_code: integer): double;
  // return d within limits min and max

begin
  return_code := 0;             // default, no change.

  if max < min then
    d := 0;       // ???

  if d > max then begin
    d := max;
    return_code := 1;   // set to max.
  end;

  if d < min then begin
    d := min;
    return_code := -1;  // set to min.
  end;

  Result := d;
end;
//_____________________________________________________________________________________

function limits_i(min, max, i: integer): integer;    // return i within limits min and max

begin
  if max < min then
    run_error(50);       // abandon ship

  if i > max then
    i := max;
  if i < min then
    i := min;

  Result := i;
end;
//_______________________________________________________________________________________

function max_i(n, m: integer): integer;                    // return greatest of 2 integers.

begin
  Result := m;                 // init.
  if n > m then
    Result := n;
end;
//_______________________________________________________________________________________

function max(a, b: double): double;              // return greatest of 2 floats.

begin
  Result := a;                 // init.
  if b > a then
    Result := b;
end;
//________________________________________________________________________________________

function min(a, b: double): double;              // return smallest of 2 floats.

begin
  Result := a;                 // init.
  if b < a then
    Result := b;
end;
//________________________________________________________________________________________

function insert_crlf_str(msg_str: string): string;

var
  i: integer;

begin
  repeat                                 //  replace any | chars in string with a CR/LF.
    i := Pos('|', msg_str);
    if i > 0 then
      msg_str[i] := Chr(13);     //  replace with CR.
  until i = 0;
  Result := AdjustLineBreaks(msg_str);     //  and add LF.
end;
//____________________________________________________________________________________

function remove_esc_str(msg_str: string): string;

var
  i: integer;

begin
  repeat
    i := Pos(Chr(27), msg_str);          // remove any ESC characters.
    if i > 0 then
      Delete(msg_str, i, 1);
  until i = 0;

  Result := msg_str;
end;
//_______________________________________________________________________________________

function space_lead(s: string): string;
  //  replace any leading 0 chars in string with a space.
  //  unless followed by decimal point or 0 is only char in string.
var
  i: integer;

begin
  try
    if s = '' then
      EXIT;
    if s = '0' then
      EXIT;
    if Length(s) < 2 then
      EXIT;

    for i := 1 to (Length(s) - 1) do
      if (s[i] = '0') and (s[i + 1] <> '.') then
        s[i] := ' '
      else
        BREAK;
  finally
    Result := s;
  end;//try
end;
//____________________________________________________________________________________

function captext(d: double): string;

begin
  if ABS(d) >= max_rad_test then
    Result := ' straight '
  else begin
    Result := FormatFloat('###0.00;"- "###0.00', d);
    if (omit_neg_brackets = False) and (d < 0) then
      Result := '[ ' + Result + ' ]';
  end;
end;
//___________________________________________________________________________________

function remove_invalid_str(msg_str: string): string;    // remove characters invalid in filenames.

var
  a, i: integer;

begin

  // mods 0.79.a

  msg_str := Trim(msg_str);

  for a := $00 to $1F do
    repeat
      i := Pos(Chr(a), msg_str);
      if i > 0 then
        Delete(msg_str, i, 1);
    until i = 0;

  // allow spaces $20 -- will be replaced with underscores later.

  for a := $21 to $2F do
    repeat
      i := Pos(Chr(a), msg_str);
      if i > 0 then
        Delete(msg_str, i, 1);
    until i = 0;

  // allow $30 - $39    0-9

  for a := $3A to $40 do
    repeat
      i := Pos(Chr(a), msg_str);
      if i > 0 then
        Delete(msg_str, i, 1);
    until i = 0;

  // allow $41 - $5A    A-Z

  for a := $5B to $5E do
    repeat
      i := Pos(Chr(a), msg_str);
      if i > 0 then
        Delete(msg_str, i, 1);
    until i = 0;

  // allow $5F  underscore

  repeat
    i := Pos(Chr($60), msg_str);
    if i > 0 then
      Delete(msg_str, i, 1);
  until i = 0;

  // allow $61 - $7A   a-z

  for a := $7B to $FF do
    repeat
      i := Pos(Chr(a), msg_str);
      if i > 0 then
        Delete(msg_str, i, 1);
    until i = 0;

  Result := lower_case_filename(msg_str);
end;
//________________________________________________________________________________________

function lower_case_filename(name_str: string): string;
  // 0.79.a lower case all filenames and change spaces to underscores.

var
  i: integer;

begin
  Result := name_str;  // default init.

  repeat
    i := Pos(' ', name_str);                        // find next space
    if i > 0 then begin
      Delete(name_str, i, 1);
      Insert('_', name_str, i);
    end;
  until i = 0;

  Result := LowerCase(name_str);
end;
//_________________________________________________________________________________________

function invalid_85a_file_name(str: string): boolean;

var
  s: string;

begin
  Result := False;  // default init.

  s := ExtractFileName(str);

  if Copy(s, 1, 5) = '_85a_' then begin
    alert(6, '    invalid  file  name',
      '|||Sorry,   ' + s + '   is not a valid file name.' +
      '|||The prefix   _85a_   is reserved for use internally by Templot0.' +
      '|||Please choose a different name for your file.',
      '', '', '', '', '', 'O K      ', 0);
    Result := True;
  end;
end;
//______________________________________________________________________________

function remove_space_str(msg_str: string): string;    // remove all space characters from string.

var
  i: integer;

begin
  repeat
    i := Pos(' ', msg_str);
    if i > 0 then
      Delete(msg_str, i, 1);
  until i = 0;

  Result := msg_str;
end;
//____________________________________________________________________________________________

function remove_multispace_str(msg_str: string): string;
  // reduce multiple spaces in string to singles.

var
  i: integer;

begin
  repeat
    i := Pos('  ', msg_str);
    if i > 0 then
      Delete(msg_str, (i + 1), 1);
  until i = 0;
  Result := msg_str;
end;

//__________________________________________________________________________________________

// NEW TRANSITION CODING - MANY MORE TERMS IN EXPANSION TO PERMIT 360 DEGREES SWING

// 1-3-98
//____________________________________________________

function fact(a: integer): double;        // return (a! = a factorial)

var
  n: integer;
  acc: double;

begin
  if a < 1 then begin
    Result := 0;
    EXIT;
  end;
  try
    acc := 1;
    for n := 1 to a do
      acc := acc * n;
    Result := acc;
  except
    Result := maxfp;       // overflowed.
  end;//try
end;
//__________________________________________________________________________________________

procedure normalize_angle(var k: double);

begin

  while k > (Pi * 2) do
    k := k - (Pi * 2);       // range +/- 360 degs.  !!! mod 16-8-00
  while k < (0 - Pi * 2) do
    k := k + (Pi * 2);

end;
//_________________________________________________________________________________________

function k_ram_str(k: double): string;     // get k angle as 1:n RAM string (up to 1:1)

var
  kn: double;

begin
  Result := '';   // init default

  while k > Pi / 2 do
    k := k - Pi;                 // force k into range +/- 90 degs..
  while k < (0 - Pi / 2) do
    k := k + Pi;

  if (ABS(k) > (Pi / 4)) or (ABS(k) < minfp) then
    EXIT;     // more than 1:1 (45 degs) or 1:INF.

  kn := 1 / TAN(k);

  if kn > 0 then
    Result := ' ( 1 in ' + round_str(ABS(kn), 2) + ' RAM )'
  else
    Result := ' ( [ -1 in ' + round_str(ABS(kn), 2) + ' ] RAM )';
end;
//__________________________________________________________________________________________

function calc_transition(rad1, rad2, zonel: double;
  var cen1x, cen1y, cen2x, cen2y, apartl, kval: double): boolean;

  // calc transition constant and rad centres for transition from rad1 to rad2 in length zonel.
  // return True if calc OK, False otherwise.
  // all dimensions from TRANSITION origin.
var
  rad_diff: double;
  len1, len2: double;  // lengths along curve to r1, r2 points.
  t1, t2: double;      // angle turned trhrough at ditto.
  xat1, xat2: double;  // x dims at ditto (from TRANSITION origin).
  yat1, yat2: double;  // y ditto.

  apartx, aparty: double;  // distance centres apart.

  dummy1, dummy2: double;

begin
  Result := False;            // init.
  rad_diff := rad1 - rad2;
  if ABS(rad_diff) < 0.01 then
    EXIT;    // limit to minimum difference of +/- 0.01 mm.

  try
    len1 := zonel * rad2 / rad_diff;
    // length along curve from transition origin to r1 point.
    len2 := len1 + zonel;

    kval := len1 * rad1;                   // transition constant.

    t1 := len1 / 2 / rad1;                   // angle at r1 point.
    t2 := len2 / 2 / rad2;                   // angle at r2 point.

    if transcalcs(False, True, kval, len1, xat1, yat1, dummy1, dummy2) = False then
      EXIT;  // get  x,y at r1 point).

    cen1x := xat1 - rad1 * SIN(t1);      // x to centre of r1.
    cen1y := yat1 + rad1 * COS(t1);      // y to centre of r1.

    if transcalcs(False, True, kval, len2, xat2, yat2, dummy1, dummy2) = False then
      EXIT;    // ditto for r2 point...

    cen2x := xat2 - rad2 * SIN(t2);      // x to centre of r2.
    cen2y := yat2 + rad2 * COS(t2);      // y to centre of r2.

    apartx := cen2x - cen1x;
    aparty := cen2y - cen1y;

    apartl := SQRT(SQR(apartx) + SQR(aparty));

    Result := True;
  except
    EXIT;
  end;//try
end;
//___________________________________________________________________________________________

function transcalcs(draw_in_progress, auto_terms: boolean; k, tsn: double;
  var xn, yn, tn, rn: double): boolean;
  //  Transition equations.

  //  return xn,yn,tn,rn at tsn for transition constant k.

  //  ( tsn is measured along the curve from the transition datum.
  //    xn and yn are co-ordinates to this point on the curve from the transition datum.
  //    tn is the swing to this point from the transition datum. )

  //  returns True if results valid, False otherwise.

  //  if auto_terms is true, overide custom terms if nec.

  //  if draw_in_progress=True, the caller is drawing a template, use 0.01mm accuracy limit for auto terms.
  //  if draw_in_progress=False, this is a set up calc, use 0.000001mm accuracy.

  //  All calculations are carried out in kilometres to reduce the possibility of overflow errors.
var
  nt: integer;                   // power for numerators.
  nb: integer;                   // power for denominators.

  sign_of_xn: double;           // + or -1 sign of next term in expansion
  sign_of_yn: double;

  acc_limit: double;

  k_trans, s_trans, x_trans, y_trans, x_term, y_term: double;

  i, n: integer;

begin
  n := 0;                        // keep compiler happy.
  try
    if ABS(tsn) < minfp          // transition origin (no div by zero later).
    then begin
      xn := 0;
      yn := 0;
      tn := 0;
      rn := max_rad;
      Result := True;    // infinite radius.
      EXIT;
    end;

    s_trans := tsn / 1.0E6;    // convert mm to kilometres.
    y_trans := 0;            // initialise for summing terms...
    x_trans := s_trans;
    k_trans := k / 1.0E12;     // k units are length^2.

    sign_of_xn := -1.0;
    sign_of_yn := 1.0;

    if (trans_auto = False) and (auto_terms = False)      // use custom number of terms
    then begin
      for n := 1 to trans_terms do    // number of terms in expansion.
      begin
        nt := n * 4;
        nb := n * 2;
        // calculate terms...

        x_term := POWER(s_trans, (nt + 1)) / (nt + 1) / POWER(2, nb) / fact(nb) /
          POWER(k_trans, nb);

        y_term := POWER(s_trans, (nt - 1)) / (nt - 1) / POWER(2, (nb - 1)) /
          fact(nb - 1) / POWER(k_trans, (nb - 1));

        x_trans := x_trans + (sign_of_xn * x_term);    // add next term, swapping signs.
        y_trans := y_trans + (sign_of_yn * y_term);

        sign_of_xn := 0 - sign_of_xn;                // and swap the signs for the next term.
        sign_of_yn := 0 - sign_of_yn;
      end;//for
      n := trans_terms;     // keep compiler happy.
    end
    else begin
      // use less accuracy if for drawing or mouse action in progress..

      if (draw_in_progress = True) or (mouse_modify <> -1) then
        acc_limit := 1.0E-8                         // in km = 0.01mm/1E6
      else
        acc_limit := 1.0E-12;                       // in km = 0.000001mm/1E6

      n := 0;
      repeat
        Inc(n);
        nt := n * 4;
        nb := n * 2;          // calculate terms...

        x_term := POWER(s_trans, (nt + 1)) / (nt + 1) / POWER(2, nb) / fact(nb) /
          POWER(k_trans, nb);

        y_term := POWER(s_trans, (nt - 1)) / (nt - 1) / POWER(2, (nb - 1)) /
          fact(nb - 1) / POWER(k_trans, (nb - 1));

        x_trans := x_trans + (sign_of_xn * x_term);    // add next term, swapping signs.
        y_trans := y_trans + (sign_of_yn * y_term);

        sign_of_xn := 0 - sign_of_xn;                // and swap the signs for the next term.
        sign_of_yn := 0 - sign_of_yn;

      until (ABS(x_term) < acc_limit) and (ABS(y_term) < acc_limit);
      //  keep going until terms less than accuracy limit.
    end;

    //control_room_form.statusbar_label.Caption:='number of terms used = '+IntToStr(n);

    xn := x_trans * 1.0E6;               // set outputs
    yn := y_trans * 1.0E6;

    tn := SQR(tsn) / 2 / k;                // angle turned through.
    rn := k / tsn;                       // and the radius.

    Result := True;
  except
    Result := False;
    reset_trans;

    cancel_adjusts(False); // 0.93.a

    repeat                             // reset transition defaults.
      i := alert(0, '    transition  error',
        '||The calculations for this transition have exceeded the capabilities of your system,' +
        ' and your transition curve has been cancelled.' +
        '||Re-try using a less exotic transition.' +
        '||( It may be necessary to change a radius or length dimension by only a few millimetres.)',
        '', '', '', '?  help', '', 'O K', 4);

      if i = 4 then
        if alert_help(0,
          'If you are using the normal AUTO TERMS option, this error has probably been caused' +
          ' by the need for too many terms in the expansion to reach the required level of accuracy.'
          +
          ' The number of terms being used when the error occurred was ' + IntToStr(n) +
          '.' + '||If this number is more than about 60, or less for older processors, this transition'
          + ' is not really a practical proposition because of the very long re-draw times (during which Templot0 may'
          + ' appear to have crashed but probably hasn''t - coffee while you wait?).' +
          '||If you can accept less accuracy, you could try using the CUSTOM TERMS option instead,'
          +
          ' and setting fewer terms than this. ' + '||Do you want to do this now?| ',
          'yes - use custom terms') = 1 then
          control_room_form.custom_terms_menu_entry.Click;
    until i <> 4;
  end;//try

end;
//_______________________________________________________________________________________

procedure Tmath_form.colour_panelClick(Sender: TObject);

begin
  Color := get_colour('choose  a  new  colour  for  the  dialog', Color);
end;
//___________________________________________________________________________________________

procedure Tmath_form.size_updownClick(Sender: TObject; Button: TUDBtnType);

begin
  if size_updown.Position > size_updown.Tag
  // ! position goes up, size goes down.
  then
    ScaleBy(9, 10);                                           // scale the form contents down.

  if size_updown.Position < size_updown.Tag then
    ScaleBy(10, 9);                                           // scale the form contents up.

  ClientHeight := VertScrollBar.Range;                               // allow 4 pixel right margin.
  ClientWidth := HorzScrollBar.Range + 4;
  // don't need bottom margin - datestamp label provides this.
  ClientHeight := VertScrollBar.Range;
  // do this twice, as each affects the other.

  size_updown.Tag := size_updown.Position;
  // and save for the next click.
end;
//________________________________________________________________________________________

function xy_to_dwg100(pin: Tpex): TPex;     // this function and next prepare x,y data for lists.

  //  apply distortions and re-originations,
  //  set hand, and ensure all inputs are within range for 31-bits.
  //  mirror to 1/100th mm

  //  n.b. h_minint, h_maxint are floats.
  //  = max, min integer values divided by 2 to give 31 bit range - this allows for any arithmetic on the stored values,
  //  e.g. for shift keeps, re-origination in keeps box, etc.
  //  (the only case likely to arise is the rad centre marks for very large radii, e.g when
  //  doing transitions to the straight.)

var
  xscaled, yscaled: double;
  xconed, yconed: double;
  xskewed, yskewed: double;
  dummy: integer;

begin
  xscaled := pin.x * list_factor_x;                                      // these are all in mm ...
  yscaled := pin.y * list_factor_y * hand_i;

  xconed := xscaled + (x_coning_distortion_factor * xscaled * yscaled);
  yconed := yscaled + (y_coning_distortion_factor * yscaled * xscaled);

  xskewed := xconed + (x_skewing_distortion_factor * yconed);
  yskewed := yconed + (y_skewing_distortion_factor * xconed);

  Result.x := limits(h_minint, h_maxint, (xskewed * mirror_x + re_org_x), dummy);
  // but now in 1/100ths mm.
  Result.y := limits(h_minint, h_maxint, (yskewed * mirror_y + re_org_y), dummy);
end;
//_________________________________________________________________________________________

function xy_to_list(pin: Tpex): TPoint;     // prepare x,y data for list.
  // round off and convert to integer.
var
  pout: Tpex;

begin
  pout := xy_to_dwg100(pin);                  // call above function to do conversions.
  Result.X := Round(pout.x);
  Result.Y := Round(pout.y);
end;
//_________________________________________________________________________________________

function blank_start(x: double): double;   // 17-10-02 0,76.a  blanking mods.

begin
  if x < startx then
    Result := startx
  else
    Result := x;
end;
//_______________________________________________________________________________________

function extract_tbnumber_str(var tbnum_str: string): string;
  // return next timber numbering string from the acummulated string.

var
  str_pos: integer;

begin
  str_pos := Pos(Chr($1B), tbnum_str);    // find next separator.

  if str_pos <> 0 then begin
    Result := Copy(tbnum_str, 1, str_pos - 1);
    // extract next number string (without the separator).
    Delete(tbnum_str, 1, str_pos);          // and remove it (including the separator).
  end
  else
    Result := '';      // no more numbers in the string, or the string got corrupted in some way.
end;
//_________________________________________________________________________________________

function set_font(fname: string; fsize: integer; fstyle: TFontStyles; fcolour: integer): TFont;

begin
  with temp_font do begin
    Name := fname;
    Size := fsize;
    Style := fstyle;
    Color := fcolour;
  end;//with
  Result := temp_font;
end;
//___________________________________________________________________________________________

procedure Tmath_form.FormCreate(Sender: TObject);

begin
  if Screen.Height < 500 then
    Top := 4;    // move form up the screen for lo-res.
  // OT-FIRST ClientWidth:=542;
  // OT-FIRST ClientHeight:=440;
  AutoScroll := True;

  temp_font := TFont.Create;      // RESULT font for set_font.
end;
//__________________________________________________________________________________________

function time_now_modified(def: integer): integer;
  // modify Delphi float time format to a unique integer code;
  // return default def if conversion problem, or if new code is same as last one generated.
  // (def is intended to be supplied as a random integer).
var
  now_float: double;
  code: integer;

begin
  try
    now_float := ABS((Date + Time) * 2.0E5);
    // convert date/time to integer in 1/200000 ths of days (0.432 seconds intervals). ABS in case of millenium bug?
    // at mid-day on 3-4-99 this gives now_float = 7,250,700,000
    // less maxint currently three times          -2,147,483,647  * 3
    //                                         (= -6,442,450,941)
    //  RESULT                                  =    808,249,059.
    // (result repeats every 2147483647/200000  = 10737 days = 29 years.)

    while now_float > maxint do
      now_float := now_float - maxint;
    while now_float < minint do
      now_float := now_float - minint;    // minint -ve

    code := Trunc(now_float);
    // check if we have been called twice in quick succession (e.g. roll-back functions), (or wonky date/time function)...

    if code = last_code_generated then
      Result := def        // date/time has failed to change, so return default.
    else
      Result := code;
  except
    Result := def;
    code := def;
  end;//try

  last_code_generated := code;
  // save this calc for check next time. !!! mod version 0.22 18-10-99 was :=RESULT; (so third quick call generates first code again).
end;
//________________________________________________________________________________________

procedure memory_alert;      // do memory fail message.

begin
  alert(5, '    memory  problem',
    'There is insufficient memory available on your system to meet the current requirements.' +
    '||You could try :' + '||1. Closing other applications and/or waiting for any printing to finish.'
    + '|2. Saving and clearing your storage box contents and background drawing.' +
    '|3. Shortening the control template.' +
    '|4. Having fewer background items on the trackpad by wiping finalised templates to become unused templates.'
    +
    '|5. Simplifying the background items, for example rail gauge-faces only or no timbering (GENERATOR menu items).'
    +
    '|6. Increasing the step-size (PROGRAM > EXPERT menu on the PROGRAM PANEL menus).' +
    '||Do a background REBUILD for items 5 and 6 to take effect.',
    '', '', '', '', '', 'OK', 0);
end;
//________________________________________________________________________________________

procedure Tmath_form.font_buttonClick(Sender: TObject);

begin
  big_label.Font.Assign(get_font('choose  a  new  font  and  text  colour  for  this  window',
    big_label.Font, True));
end;
//___________________________________________________________________________________________

function rad_str(r: double; dp: integer): string; // get radius as a string.

begin
  if ABS(r) < (max_rad_test - 2) then
    Result := round_str(r, dp)  // 212a -2 kludge for make transition
  else
    Result := 'straight';
end;
//__________________________________________________________________________________________

procedure dotransform(krot, xrot, yrot: double; pin: Tpex; var pout: Tpex);

//  perform any rotations/transformations.
//  enter with rotation angle and centre point krot, xrot, yrot.
//  and input point pin.

//  result point pout returned.
var
  x, y: double;

begin
  x := pin.x - xrot;                             // shift to origin.
  y := pin.y - yrot;

  pout.x := x * COS(krot) - y * SIN(krot) + xrot;      // rotate and shift back.
  pout.y := x * SIN(krot) + y * COS(krot) + yrot;
end;
//______________________________________________________________________________________

// new geometry routines  15-9-99...

function rad_tanp1_p2(p1, p2: Tpex; tn: double; var rad, swing: double): boolean;    // 15-9-99.

  // return radius through 2 given points p1,p2 given the tangent swing angle tn at p1...
  // also return the swing angle for the length of curve.
  // return False if radius is infinity (straight) or zero or swing cannot be calculated.
  // otherwise return True.

var
  x, y, h, cosk: double;

begin
  Result := False;    // default init.
  x := p2.x - p1.x;
  y := p2.y - p1.y;
  h := x * SIN(tn) - y * COS(tn);
  if ABS(h) < minfp then begin
    rad := SGZ(h) * max_rad;   // "straight"
    swing := 0;
    EXIT;
  end
  else
    rad := (SQR(x) + SQR(y)) / 2 / h;

  if ABS(rad) < minfp then begin
    swing := 0;
    EXIT;
  end;

  cosk := (rad - h) / rad;     // cosine of swing along curve.

  if ABS(cosk) > (1 - minfp) then begin
    swing := 0;
    EXIT;
  end;

  swing := ARCCOS(cosk);
  Result := True;
end;
//________________________________________________

//  8th May 2001 v:0.71.a

function calc_geo_radius(rout, xp, yp, kp: double; var rin, kin, krin, gpx: double): boolean;

  // for geometrical radius calcs.
  // enter with rout radius in main road centre-line,
  // xp, yp tangent point on turnout road (xp from template datum, yp from main road track centre-line at datum).
  // kp turnout road angle at xp,yp (from template datum).

  // return rin radius of arc tangential to main road and turnout road at xp,yp
  // and angle kin from template datum to tangent point on main road
  // and angle krin total swing on rin between tangent points
  // and length gpx along main road curve from template datum to tangent point (+ve towards the crossing)
  // and gorgx,gorgy geometrical radial centres (!!! from the main-road centre-line).
  // see diagram.

var
  a, b, c, d, e, k, q, z: double;

begin
  Result := False;     // default init
  try

    if ABS(rout) < max_rad_test{curved} = True        // curved template.
    then begin
      z := TAN(kp);
      if ABS(z) < minfp then
        EXIT;

      a := rout - yp - xp / z;

      z := SIN(kp);
      if ABS(z) < minfp then
        EXIT;

      b := a * z;
      c := a * COS(kp);
      d := xp / z;

      e := c + d;

      z := 2 * (e - rout);
      if ABS(z) < minfp then
        EXIT;

      rin := (SQR(b) + SQR(e) - SQR(rout)) / z;

      q := e - rin;

      if ABS(b) < minfp then
        EXIT;

      k := ARCTAN(q / b);

      kin := Pi / 2 - kp - k;

      while kin > (Pi / 2) do
        kin := kin - Pi;       // needed by experiment.
      while kin < (0 - Pi / 2) do
        kin := kin + Pi;     // now in range -90 to 90

      krin := kin + kp;

      gpx := 0 - kin * rout;    // along the curve.

    end
    else begin      // straight template

      z := SIN(kp);
      if ABS(z) < minfp then
        EXIT;

      a := yp / z;
      b := a * COS(kp);

      gpx := xp - b - a;

      z := TAN(kp / 2);
      if ABS(z) < minfp then
        EXIT;

      rin := a / z;

      krin := kp;

      kin := 0;

    end;

    Result := True;
  except
    EXIT;   // f.p. errors.
  end;
end;
//______________________________________________________________________________

procedure check_pad_views;   // 0.91.c  process pad view rollbacks once per second.
// this routine runs every 1 second. called from rad_lamp_timer (pad_unit)
var
  i, n: integer;

begin
  // see if view has remained unchanged for 5 seconds...

  with pad_view_now do begin
    if (offset_x = zoom_offsetx) and (offset_y = zoom_offsety) and (width_x = screenx) then begin
      if view_delay_count < 6 then
        Inc(view_delay_count);  // no need to count beyond 6 seconds.
    end
    else begin                        // update current view..
      offset_x := zoom_offsetx;
      offset_y := zoom_offsety;
      width_x := screenx;

      view_delay_count := 0;   // view changed, restart count.

      panning_form.rollback_panel.Color := $0066AAFF;   // show view is changing.

    end;
  end;//with

  if view_delay_count <> 5 then
    EXIT;   // do nothing while view is changing, or has previously been updated (count=6).

  // has remained static for 5 seconds.
  // see if current view is in list..

  panning_form.next_view_button.Enabled := False;      // time's up on allowing reverse action.
  panning_form.rollback_panel.Color := $00CCEEEE;      // show view is static.

  pad_view_index := 0;   // for rollback -- now at top of list.

  i := -1;  // init

  for n := 0 to (pad_view_list.Count - 1) do begin
    with Tpad_view(pad_view_list.Objects[n]).pad_view_data do begin
      if (offset_x = pad_view_now.offset_x) and (offset_y = pad_view_now.offset_y) and
        (width_x = pad_view_now.width_x) then begin
        i := n;    // found match in list.
        BREAK;
      end;
    end;//with
  end;//next n

  if i = 0 then
    EXIT;  // current view is at top of list anyway.

  // put it at the top...

  pad_view_list.InsertObject(0, 'null', Tpad_view.Create);            // string not used.
  Tpad_view(pad_view_list.Objects[0]).pad_view_data := pad_view_now;


  if (i > 0) and (i < pad_view_list.Count)  // if in list, remove old entry from list
  then begin
    Tpad_view(pad_view_list.Objects[i]).Free;
    pad_view_list.Delete(i);
  end;

  while pad_view_list.Count > 8 do begin
    // not more than 8 views wanted in list, so delete the bottom entry...

    Tpad_view(pad_view_list.Objects[(pad_view_list.Count - 1)]).Free;
    pad_view_list.Delete(pad_view_list.Count - 1);

  end;//while

end;
//______________________________________________________________________________

function store_and_background(click, zero_it: boolean): boolean;
  // 0.93.a click=True means direct click by user.

  // return False if he cancels, or zero-length template not stored

var
  i, keeps_count: integer;
  //beginner_help_str:string;

begin
  Result := False;      //
  keep_added := False;  // init.

  //if check_t_55_ok=False then EXIT;   // check he wants it if T-55.

  if click = True then begin
    if check_control_template_is_valid('store') = False then
      EXIT;  // 0.93.a  zero length
  end
  else begin
    if turnoutx = 0 then
      EXIT;    // 0.93.a  zero length
  end;

  keeps_count := keeps_list.Count;

  store_unused(False, False);
  copy_or_wipe_background;

  // 0.93.a   ...

  if (click = True) and (classic_templot = True) and
    (keep_form.briefly_hide_on_store_menu_entry.Checked = True)
  // 205e now radio item.  205c
  then begin
    do_hide_current;
    hidden_on_store := 8;         // 205c count down in timer to show it again.
  end;

  if (click = True) and (classic_templot = True) and
    (keep_form.hide_on_store_menu_entry.Checked = True)
  // 205e radio item
  then begin
    do_hide_current;
    hidden_on_store := 0;   // cancel any countdown in progress
  end;

  if (click = True) and (classic_templot = True) and (hide_current_flag = False) and
    (keep_form.reveal_on_store_menu_entry.Checked = True)  // 206a radio item
  then begin
    stored_xshift := xshift;
    stored_yshift := yshift;
    slide_inc := g / 25;
    slide_on_store := 51;    // counts down 51-1 (50)

    xshift := stored_xshift + (slide_on_store - 1) * slide_inc;
    // 50 = displace by g*2 before sliding back
    yshift := stored_yshift + (slide_on_store - 1) * slide_inc * hand_i;

    math_form.reveal_timer.Interval := 750;   // 3/4 second wait
    math_form.reveal_timer.Enabled := True;

  end;

  if (click = True) and (classic_templot = True) and
    (keep_form.alert_on_store_menu_entry.Checked = True)
  // 206c radio item
  then begin

    alert_box.preferences_checkbox.Checked := False;
    alert_box.preferences_checkbox.Show;

    repeat
      i := alert(2, 'php/123    store  &  background',
        '`0store &amp; background  -  notes for beginners`9' +
        '||A copy of the control template has been stored in your `0storage box`3, and displayed as a `0background template`3 on the trackpad as part of your track plan.' + '||You can''t see much of it yet, because the control template is in front of it on the screen. When you move the control template away, the background template will become fully visible.' + '||green_panel_begin tree.gif If you want to see the new background template without moving the control template, press the `0HOME`2 key on the keyboard to hide the control template.' + ' Press the `0HOME`2 key again to see the control template again.' + '||You can see a little of the background template because the most recently stored template is always shown with bold timber outlines.green_panel_end' + '|If you don''t want to see this message again, tick the|`0don''t show this message again`1 box at the bottom|of this dialog window.', '', '', 'more  information  and  options', 'show  storage  box', '', 'continue', 3);

      if i = 3 then
        alert_help(0, get_store_beginner_help, '');

      if i = 4 then
        pad_form.view_box_menu_entry.Click;

    until i <> 3;

    keep_form.dont_hide_on_store_menu_entry.Checked :=
      alert_box.preferences_checkbox.Checked;
    // 208a change option setting -- radio item
    alert_box.preferences_checkbox.Hide;

  end;

  if (zero_it = True) and (classic_templot = False)  // Quick mode
  then begin
    pad_form.snap_to_zero_menu_entry.Click;
    // 0.93.a invalidate after storing.
    xshift := zoom_offsetx + (screenx - turnoutx) / 2;
    // put it on the centre of the pad,
    yshift := (zoom_offsety + screeny / 2.5 - y_datum) * hand_i - g / 2;
    // 0.93.a was /2.0 // and on main centre-line (if straight turnout).
  end;

  if keeps_list.Count > keeps_count then
    keep_added := True;   // check if it kept or he cancelled (for the make tools).

  Result := True;
end;
//______________________________________________________________________________

function get_store_beginner_help: string;  // 208a

begin
  Result := 'php/123    `0store  &amp;  background`9' +
    '||After storing a copy of it, the control template remains unchanged and is ready for you to use again in building up your track plan of background templates.' + ' The control template is always shown in front of any background templates. It is not itself part of your track plan.' + '||If you want the control template to be temporarily hidden when you store a copy of it on the background, there are some option settings on the `0options`1 menu on the `0storage box`3:' + '||<IMG SRC="' + Config.GetFilePath(csfiStoreBgnd) + '">' + '||To see the storage box, click the `0main > storage box`1 menu item, or press `0CTRL+B`2.';
end;
//______________________________________________________________________________

procedure Tmath_form.reveal_timerTimer(Sender: TObject);
// 206a  slide control template back over stored copy

var
  now_now: double;

begin
  reveal_timer.Enabled := False;  // delay over, slide it back...

  gocalc(2, 8);   // 8 updates pad background bitmap

  reveal_limit_count := 10;  // for red-lamp timer  10 arbitrary

  now_now := Now;

  repeat
    repeat                         // wait if back here too soon.
      Application.ProcessMessages;
    until Now > (now_now + 1E-7);
    // = 1E-7*1day = 8.64mS  prevent to rapid slide on fast systems
    // 50 steps * 8.64mS = 432mS minimum slide time.
    now_now := Now;

    if slide_on_store < 1 then
      BREAK;  // mouse click or key down sets zero.

    if reveal_limit_count < 1 then
      BREAK;  // taking too long, so abandon slide and jump back.

    xshift := stored_xshift + (slide_on_store - 1) * slide_inc;
    yshift := stored_yshift + (slide_on_store - 1) * slide_inc * hand_i;
    Dec(slide_on_store);
    gocalc(2, 7);           // control template over bgnd bitmap

  until slide_on_store < 1;  // not =0 (may have been set to zero by clicks, keys)

  slide_on_store := 0;  // cancel any unwanted decrements after set to zero elsewhere

  xshift := stored_xshift;   // ensure back in place.
  yshift := stored_yshift;

  show_and_redraw(True, False);  // and showing there
end;
//______________________________________________________________________________

procedure convert_to_or_from_gaunt(to_gaunt: boolean); // 0.93.a ex 081

var
  dummy: double;
  old_dp, new_dp: double;

begin
  if (half_diamond = True) or (plain_track = True) then
    EXIT;

  startx := 0;     // cancel any blanking.
  gocalc(0, 0);

  kform_now := kform;
  docurving(True, True, pegx, pegy, now_peg_x, now_peg_y, now_peg_k, dummy);
  // save current peg data for peg_curve calcs.

  old_dp := dpx - xorg;   // deflection point from switch front.

  gaunt := to_gaunt;
  gocalc(0, 0);

  new_dp := dpx - xorg;
  xorg := xorg + old_dp - new_dp;
  // adjust xorg approach length to maintain overall length constant.

  if xorg < 0        // approach length can't go negative.
  then begin
    turnoutx := turnoutx - xorg;
    // increase overall length to keep V-crossing and exit track on alignment.
    if spiral = True then
      os := os - xorg;
    if slewing = True then
      slew_s := slew_s - xorg;
    xorg := 0;
  end;

  if turnoutx > turnoutx_max then
    turnoutx := turnoutx_max;
  if xorg > turnoutx then
    xorg := turnoutx;

  gocalc(0, 0);

  turnout_i := 1;      // length locked at turnoutx.
  gocalc(0, 0);

  peg_curve;

end;
//______________________________________________________________________________

procedure trail_check_len_mm(X: integer);    // 0.94.a  check rail diffs

begin
  mouse_diff.len_diff := (mouse_check_len_mm_now + (X - mouse_diffs_now_X) *
    diff_dir / fx) / inscale;

  if mouse_diff.len_diff < min_diff then
    mouse_diff.len_diff := min_diff;

  set_checkrail_diff(current_diff_code, mouse_diff);
end;
//______________________________________________________________________________

procedure trail_check_flare_mm(X: integer);    // 0.94.a  check rail diffs

begin
  mouse_diff.flr_diff := (mouse_check_flare_mm_now + (X - mouse_diffs_now_X) *
    diff_dir / fx / 1.5) / inscale;
  // 1.5 arbitrary finer control

  if mouse_diff.flr_diff < min_diff then
    mouse_diff.flr_diff := min_diff;

  if mouse_diff.flr_diff > max_diff then
    mouse_diff.flr_diff := max_diff;

  set_checkrail_diff(current_diff_code, mouse_diff);
end;
//______________________________________________________________________________

procedure trail_check_gap_mm(Y: integer);    // 0.94.a  check rail diffs

begin
  mouse_diff.gap_diff := (mouse_check_gap_mm_now + (Y - mouse_diffs_now_Y) * diff_dir / fy / 4);
  // 4 arbitrary finer control

  if mouse_diff.gap_diff < min_diff then
    mouse_diff.gap_diff := min_diff;    // bend-out can't go negative.

  if mouse_diff.gap_diff > max_diff then
    mouse_diff.gap_diff := max_diff;    // or more than 1/2 track gauge

  set_checkrail_diff(current_diff_code, mouse_diff);
end;
//______________________________________________________________________________

function get_arc_centre(p1, p2, p3: Tpex; var arc_centre: Tpex): boolean;

var
  x, y, len1, len2: double;

  ////////////////////////////////////////////////////////////////////

  procedure swap_points(var p1, p2: Tpex);

  // swap p1 and p2

  var
    temp: Tpex;

  begin
    temp := p1;
    p1 := p2;
    p2 := temp;
  end;
  ////////////////////////////////////////////////////////////////////

  function same_point(p1, p2: Tpex): boolean;

    // returns True if p1 and p2 are coincident

  begin
    Result := ((ABS(p1.x - p2.x) < minfp) and (ABS(p1.y - p2.y) < minfp));
  end;
  ////////////////////////////////////////////////////////////////////

begin
  Result := True;  // init

  if (same_point(p1, p2) = True) or (same_point(p1, p3) = True) or
    (same_point(p2, p3) = True) or ((ABS(p1.x - p2.x) < minfp) and (ABS(p1.x - p3.x) < minfp)) then
  begin
    arc_centre.x := 0;
    arc_centre.y := 0;
    Result := False;
    EXIT;
  end;

  if (ABS(p1.x - p2.x) < minfp) or (ABS(p1.y - p2.y) < minfp) then
    swap_points(p2, p3);

  if ABS(p2.x - p3.x) < minfp then
    swap_points(p1, p2);

  if ABS(p1.x - p2.x) > minfp then
    len1 := (p2.y - p1.y) / (p2.x - p1.x)
  else
    len1 := maxfp;

  if ABS(p2.x - p3.x) > minfp then
    len2 := (p3.y - p2.y) / (p3.x - p2.x)
  else
    len2 := maxfp;

  if (ABS(len1) < minfp) and (ABS(len2) < minfp) then
    Result := False;

  if Result = True then begin
    x := (len1 * len2 * (p1.y - p3.y) + len2 * (p1.x + p2.x) - len1 * (p2.x + p3.x)) /
      (2 * (len2 - len1));

    if ABS(len1) > minfp then
      y := 0 - (x - (p1.x + p2.x) / 2) / len1 + (p1.y + p2.y) / 2
    else
      y := 0 - (x - (p2.x + p3.x) / 2) / len2 + (p2.y + p3.y) / 2;

    arc_centre.x := x;
    arc_centre.y := y;
  end;
end;
//______________________________________________________________________________

function calculate_turnout_radius(curving_rad: double;
  var heel_notch, mid_notch, xing_notch: Tnotch): double;
  // 218a

  // using a Tnotch for convenience, no effect on the pegging notch

  // calculate radius through 3 points on turnout curve -- at switch heel, crossing, and mid-way between them (track centre-line, tradius-g/2)

  // curving_rad is used only to find sign of result

  // if curving_rad=0, return positive rad anyway

var
  xx1, yy1: double;
  xx2, yy2: double;
  xxmid, yymid: double;

  turn_rad: double;
  hsum: double;
  a, b, c: double;

begin
  Result := max_rad;   // init straight

  heel_notch := get_snap_peg_xy_data(104);           // switch heel
  mid_notch := get_snap_peg_xy_data(270);            // mid-way

  if xing_calc_i = 0 then
    xing_notch := get_snap_peg_xy_data(108)    // regular   curve ends at CESP
  else
    xing_notch := get_snap_peg_xy_data(5);     // cuviform or generic   calc ends at TCP

  xx1 := heel_notch.notch_x;
  yy1 := heel_notch.notch_y;

  xxmid := mid_notch.notch_x;
  yymid := mid_notch.notch_y;

  xx2 := xing_notch.notch_x;
  yy2 := xing_notch.notch_y;

  // calc the radius from 3 points on arc ...

  try
    a := SQRT(SQR(xx1 - xxmid) + SQR(yy1 - yymid));
    b := SQRT(SQR(xxmid - xx2) + SQR(yymid - yy2));
    c := SQRT(SQR(xx2 - xx1) + SQR(yy2 - yy1));
    hsum := (a + b + c) / 2;

    turn_rad := ABS((a * b * c) / (4 * SQRT(hsum * (hsum - a) * (hsum - b) * (hsum - c))));
  except
    turn_rad := max_rad;   // straight
  end;//try

  if turn_rad > max_rad then
    EXIT;

  if turn_rad < (2 * g) then
    EXIT;     // ???   arbitrary

  if curving_rad = 0 then
    Result := turn_rad
  else
    Result := turn_rad * SGZ(curved_onto_calc(tradius - g / 2, curving_rad));

end;
//______________________________________________________________________________

function calculate_turnout_radius_beyond(curving_rad: double;
  var xing_notch, mid_notch, end_notch: Tnotch): double;  // 218b

  // USE FOR CURVIFORM ONLY

  // using Tnotch for convenience, no effect on the pegging notch

  // calculate radius through 3 points on turnout curve beyond crossing -- at TCP, at TMINP, at TVJP  (track centre-line, tradius-g/2)

  // curving_rad is used only to find sign of result

  // if curving_rad=0, return positive rad anyway

var
  xx1, yy1: double;
  xx2, yy2: double;
  xxmid, yymid: double;

  turn_rad: double;
  hsum: double;
  a, b, c: double;

begin
  Result := max_rad;   // init straight

  xing_notch := get_snap_peg_xy_data(5);       // TCP
  mid_notch := get_snap_peg_xy_data(240);      // TMINP
  end_notch := get_snap_peg_xy_data(18);       // TVJP

  xx1 := xing_notch.notch_x;
  yy1 := xing_notch.notch_y;

  xxmid := mid_notch.notch_x;
  yymid := mid_notch.notch_y;

  xx2 := end_notch.notch_x;
  yy2 := end_notch.notch_y;

  // calc the radius from 3 points on arc ...

  try
    a := SQRT(SQR(xx1 - xxmid) + SQR(yy1 - yymid));
    b := SQRT(SQR(xxmid - xx2) + SQR(yymid - yy2));
    c := SQRT(SQR(xx2 - xx1) + SQR(yy2 - yy1));
    hsum := (a + b + c) / 2;

    turn_rad := ABS((a * b * c) / (4 * SQRT(hsum * (hsum - a) * (hsum - b) * (hsum - c))));
  except
    turn_rad := max_rad;   // straight
  end;//try

  if turn_rad > max_rad then
    EXIT;

  if turn_rad < (2 * g) then
    EXIT;     // ???   arbitrary

  if curving_rad = 0 then
    Result := turn_rad
  else
    Result := turn_rad * SGZ(curved_onto_calc(tradius - g / 2, curving_rad));
end;
//______________________________________________________________________________

function calculate_return_curve_radius(var exit_notch, mid_notch, trp_notch: Tnotch): double;
  // 218d

  // using Tnotch for convenience, no effect on the pegging notch

  // calculate radius through 3 points on return curve -- at TVJP exit, TRP curve end, and mid-way between them (track centre-line, tradius-g/2)

var
  xx1, yy1: double;
  xx2, yy2: double;
  xxmid, yymid: double;

  turn_rad: double;
  hsum: double;
  a, b, c: double;

begin
  Result := max_rad;   // init straight

  exit_notch := get_snap_peg_xy_data(18);     // TVJP
  mid_notch := get_snap_peg_xy_data(275);     // mid-way
  trp_notch := get_snap_peg_xy_data(7);       // TRP curve end

  xx1 := exit_notch.notch_x;
  yy1 := exit_notch.notch_y;

  xxmid := mid_notch.notch_x;
  yymid := mid_notch.notch_y;

  xx2 := trp_notch.notch_x;
  yy2 := trp_notch.notch_y;

  // calc the radius from 3 points on arc ...

  try
    a := SQRT(SQR(xx1 - xxmid) + SQR(yy1 - yymid));
    b := SQRT(SQR(xxmid - xx2) + SQR(yymid - yy2));
    c := SQRT(SQR(xx2 - xx1) + SQR(yy2 - yy1));
    hsum := (a + b + c) / 2;

    turn_rad := ABS((a * b * c) / (4 * SQRT(hsum * (hsum - a) * (hsum - b) * (hsum - c))));
  except
    turn_rad := max_rad;   // straight
  end;//try

  if turn_rad > max_rad then
    EXIT;

  if turn_rad < (2 * g) then
    EXIT;     // ???   arbitrary

  Result := turn_rad;
end;
//______________________________________________________________________________


function tpex_from_tnotch(notch: Tnotch): Tpex;

begin
  Result.x := notch.notch_x;
  Result.y := notch.notch_y;
end;
//______________________________________________________________________________

function get_nearer_pex(p0, p1, p2: Tpex): Tpex;

  // return nearer of p1 or p2 to p0

var
  a, b: double;

begin
  a := SQRT(SQR(p1.x - p0.x) + SQR(p1.y - p0.y));
  b := SQRT(SQR(p2.x - p0.x) + SQR(p2.y - p0.y));

  if a < b then
    Result := p1
  else
    Result := p2;
end;
//______________________________________________________________________________

function get_notch_distance(n1, n2: Tnotch): double;

  // return distance between notches

begin
  Result := SQRT(SQR(n1.notch_x - n2.notch_x) + SQR(n1.notch_y - n2.notch_y));
end;
//______________________________________________________________________________

function get_snap_peg_xy_data(code: integer): Tnotch;

  // angle ignored

var
  dummy_str: string;
  x, y, k: double;
  temp_y, dummy2, temp_k: double;

begin
  with Result do begin     // defalt inits.
    notch_x := 0;
    notch_y := 0;
    notch_k := 0;   // not used
  end;//with

  x := pegx;    //  default inits (for peg_code 20, peg free) ...
  y := pegy;
  k := pegangle;

  dummy_str := calc_peg_dims(code, x, y, k);     // code is the peg_code.

  with Result do begin
    docurving(True, True, x, y, notch_x, temp_y, temp_k, dummy2);
    // get notch data from current peg position.
    notch_y := temp_y * hand_i + y_datum;
  end;//with

end;
//______________________________________________________________________________

function draw_xing_label(k, xlabel, yms, yts, ymid, xnote, ynote: double): Tpex;
  // 211b mark the crossing labels

var
  p1, p2, p3, p4, pk1, pk2, pk3, pk4, ponpad, pp1, pp2, pp3, pp4: Tpex;

  dummy: double;

  x_curmod, x_curlabel, y_curmod, y_curlabel, k_curlabel: double;

begin

  Result.x := 0;  // init
  Result.y := 0;

  if xlabel < (startx - minfp) then
    EXIT;    // blanking
  if xlabel > (turnoutx + scale) then
    EXIT;  // overall length

  p1.x := xlabel;
  p1.y := yts;
  p2.x := xlabel;
  p2.y := yms;

  docurving(False, True, xlabel, ymid, x_curlabel, y_curlabel, k_curlabel, dummy);
  // calc curving for the rotation point.

  x_curmod := x_curlabel - xlabel;   // shift required to rotation point, to suit the curving..
  y_curmod := y_curlabel - ymid;

  // long line across template ...

  dotransform(k + k_curlabel, xlabel, ymid, p1, pk1);
  // equalising + curving line angle, transform p1 to pk1 (relative to equalising centre).
  dotransform(k + k_curlabel, xlabel, ymid, p2, pk2);       // ditto p2

  pk1.x := pk1.x + x_curmod;      // shift p1 to final position for the curving.
  pk1.y := pk1.y + y_curmod;

  dotransform(kform, xform, yform, pk1, ponpad);  // transform to template position on pad..
  pp1.x := ponpad.x + xshift;
  pp1.y := ponpad.y + yshift;

  pk2.x := pk2.x + x_curmod;      // shift p2 to final position for the curving.
  pk2.y := pk2.y + y_curmod;

  dotransform(kform, xform, yform, pk2, ponpad);     // transform to template position on pad..
  pp2.x := ponpad.x + xshift;
  pp2.y := ponpad.y + yshift;

  fill_mark(convert_point(pp1), convert_point(pp2), eMC_700_XingLongMark, '');
  // into marks list.

  Result := pp1;     // in case label note needed (TS side) (half-diamonds)

  if (xnote = 0) and (ynote = 0) then
    EXIT;  // note line not wanted

  // short line to note ...

  p3.x := xlabel;
  p3.y := yts - ynote;
  p4.x := xlabel + xnote;
  p4.y := p3.y;

  dotransform(k + k_curlabel, xlabel, ymid, p3, pk3);
  // equalising + curving line angle, transform p3 to pk3 (relative to equalising centre).
  dotransform(k + k_curlabel, xlabel, ymid, p4, pk4);       // ditto p4

  pk3.x := pk3.x + x_curmod;      // shift p3 to final position for the curving.
  pk3.y := pk3.y + y_curmod;

  dotransform(kform, xform, yform, pk3, ponpad);  // transform to template position on pad..
  pp3.x := ponpad.x + xshift;
  pp3.y := ponpad.y + yshift;

  pk4.x := pk4.x + x_curmod;      // shift p4 to final position for the curving.
  pk4.y := pk4.y + y_curmod;

  dotransform(kform, xform, yform, pk4, ponpad);     // transform to template position on pad..
  pp4.x := ponpad.x + xshift;
  pp4.y := ponpad.y + yshift;

  fill_mark(convert_point(pp3), convert_point(pp4), eMC_700_XingLongMark, '');
  // into marks list.

  Result := pp4;  // return position for note

end;
//______________________________________________________________________________

function do_show_modal(modal_form: TForm): TModalResult;   // 212a wine bug

begin
  if running_under_wine = True then begin
    Inc(modal_form_count);

    if modal_form_count > 12 then
      modal_form_count := 12;  // 12 nested modal forms? !!!

    modal_form_array[modal_form_count] := modal_form;

    Result := modal_form.ShowModal;   // do it under wine

    Dec(modal_form_count);

    if modal_form_count < 0 then
      modal_form_count := 0;    // error? !!!
  end

  else
    Result := modal_form.ShowModal;  // do it under Windows

end;
//______________________________________________________________________________

procedure show_modal_message(msg: string);                // 212a Wine bug

begin
  showing_message := True;
  ShowMessage(msg);
  showing_message := False;
end;
//______________________________________________________________________________

procedure Tmath_form.FormDestroy(Sender: TObject);

begin
  temp_font.Free;
end;
//______________________________________________________________________________

procedure Tmath_form.overwrite_labelClick(Sender: TObject);  // 214a

begin
  form_overwrite_mode := not form_overwrite_mode;
  if form_overwrite_mode = True then
    overwrite_label.Caption := 'OVR'
  else
    overwrite_label.Caption := 'INS';
end;
//______________________________________________________________________________

procedure Tmath_form.math_editboxKeyPress(Sender: TObject; var Key: Char);

// 214a  overwrite mode ...

begin
  if (Sender is TCustomEdit) and (form_overwrite_mode = True) then begin
    with TCustomEdit(Sender) do begin
      if (SelLength = 0) and (SelStart < Length(Text)) then begin
        case Key of
          ' '..#126, #128..#255:
            SelLength := 1;    // select next character
        end;//case
      end;
    end;//with
  end;
end;
//______________________________________________________________________________

procedure companion_help(topic_url_str: string);

begin
  go_to_url('http://templot.com/companion/' + topic_url_str);
end;
//______________________________________________________________________________

initialization

  int_size := SizeOf(integer);     // only need to call this once.
  cdvi := Tdummy_vehicle_info.Create;
  centre_line_path := Tcentre_line_path.Create;
  dv_envelopes := Tdv_envelope_list.Create;

  //______________________________________________________________________________

end.
